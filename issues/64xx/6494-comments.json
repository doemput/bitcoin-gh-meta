[
   {
      "body" : "This isn't really needed is it? If a node is already sending \"getheaders\" then presumably a node can assume it prefers headers rather than invs, perhaps?",
      "created_at" : "2015-07-30T20:55:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-126483990",
      "id" : 126483990,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-07-30T20:55:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/126483990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "@rebroad  Sorry, I just realized I should have emphasized more clearly that this PR also includes code to enable direct-fetching of blocks based on headers messages.  Without that change, nodes that received a headers message would otherwise wait to download blocks through the existing parallel fetch mechanism, which would generally make headers-announcement inferior to inv-announcements (because we have direct-fetch code in the inv-processing logic, which means we'd be quicker to request a new block).\r\n\r\nConsequently I think it makes sense for nodes to somehow opt-in to the new behavior.  0.10 and 0.11 nodes should continue to receive inv's even after this code is merged.\r\n\r\nOne thing that wasn't clear to me was whether it's really necessary to do the protocol version bump in order to deploy the new p2p message, given that the new message is backwards compatible -- nodes are free to ignore it.  However I'm not sure I have a good grasp of how the protocol versions should be thought about.\r\n",
      "created_at" : "2015-07-31T00:28:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-126529816",
      "id" : 126529816,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-07-31T00:28:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/126529816",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "@sdaftuar Why not use the existing parallel fetch mechanism? I don't see any advantage in fetching the block outside of that.",
      "created_at" : "2015-07-31T11:35:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-126661302",
      "id" : 126661302,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-07-31T11:35:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/126661302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "The existing parallel fetch mechanism has a delay and an extra roundtrip,\nbecause it first needs to ask for headers before it can start fetching any\nblock.\n\nSending all headers immediately when announcing the block avoids that\nround-trip, potentially improving propagation speed significantly over\nhigh-latency links.\n",
      "created_at" : "2015-07-31T12:37:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-126677054",
      "id" : 126677054,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-07-31T12:37:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/126677054",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Fixed @casey's nits",
      "created_at" : "2015-08-03T17:44:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-127344879",
      "id" : 127344879,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-08-03T17:44:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/127344879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Rebased.",
      "created_at" : "2015-09-09T17:09:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-138978021",
      "id" : 138978021,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-09-09T17:09:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/138978021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I'm planning to send the draft BIP out to the mailing list for comments, but before I do so, does anyone here have any guidance about whether it is necessary to bump the protocol version to introduce the new ```sendheaders``` p2p message?  It is safe to ignore the message, but I'm not sure if its generally considered helpful to change the protocol version when adding even an optional message...",
      "created_at" : "2015-09-24T15:38:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-142966413",
      "id" : 142966413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-09-24T15:38:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/142966413",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I think it's helpful to bump the protocol version in this case. Although it's only an optional hint, it may provide more clarity (eg when documenting) and help troubleshooting.",
      "created_at" : "2015-09-24T15:58:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-142972322",
      "id" : 142972322,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-09-24T15:58:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/142972322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "How is the BIP for this coming along? Need any help?",
      "created_at" : "2015-10-06T09:52:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-145803573",
      "id" : 145803573,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-06T09:52:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145803573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@theuni suggested some alternate ideas to the \"sendheaders\" p2p message: either extend the version message to include a bool that indicates the preference to receive headers announcements, or even just allocate a service bit that indicates that preference.\r\n\r\nBetween those 3 options I don't feel strongly about the best way to deploy -- and in particular I can understand why it might not be great to go with adding a new p2p message that causes node state/behavior to change.  @theuni mentioned he might respond on-list with his alternate suggestions; any thoughts here on those ideas?",
      "created_at" : "2015-10-06T14:34:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-145875499",
      "id" : 145875499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-06T14:34:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145875499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "@sdaftuar @theuni Extending \"version\" continuously isn't a very scalable approach, and requires pretty strong consensus to do, as the order of entries matters. I don't really understand why we kept doing that for so long.\r\n\r\nA service bit has the same \"synchronization\" problem, but does have the extra advantage of making the property searchable.",
      "created_at" : "2015-10-06T14:42:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-145878356",
      "id" : 145878356,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-06T14:42:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145878356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "I don't think it's important that the property is searchable.  For me I'd ask should this be its own message, or should we define a \"flags\" message, for sending more, non-searchable capabilities.",
      "created_at" : "2015-10-06T16:25:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-145918734",
      "id" : 145918734,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-06T16:25:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145918734",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@sipa @gmaxwell My preference for not sending a new messages comes from an event-driven implementor's POV. If a remote nodes are allowed to switch preferences mid-stream, it can greatly (and needlessly) complicate the local node's sending logic.\r\n\r\nThe easy way to avoid that is to disallow changing the preference _back_ once set (this seems to be the case in @sdaftuar's BIP). Taking that a step further, it also makes sense to only accept the message early in the connection process, say directly after version/verack, and before any inv. And if that's the case, it may as well just be considered as part of the handshake.\r\n\r\nEssentially, I would much prefer to avoid making life-of-the-connection properties stateful unless necessary. Extending the version message makes sense to me, but I understand @sipa's objection there. \r\n\r\n@gmaxwell's suggestion seems reasonable, assuming that the \"flags\" message had the requirement of being sent directly after version/verack. Absence of the message would actively (though perhaps unknowingly) communicate the desire for default flags (historic behavior). Again, this just seems like an extension of the version message to me, but if changes there are deemed problematic, this would be my preference.",
      "created_at" : "2015-10-08T02:16:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-146395507",
      "id" : 146395507,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-08T02:16:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/146395507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Rebased.",
      "created_at" : "2015-10-16T18:27:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-148794761",
      "id" : 148794761,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-16T18:27:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/148794761",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "This significantly speeds up new block propagation in the normal, build-on-the-best-chain case.\r\n\r\nBenchmark numbers from a 5-node, 4-network-hop test network I created that relays empty blocks from massachusetts to los angeles and back, twice (round-trip latency of 100 msec):\r\n\r\nBefore:  1,300 msec latency from first block-creating node sending an 'inv' to last node in the chain receiving the 'block' message\r\n\r\nWith this pull:  670 msec\r\n\r\nSo concept ACK: I haven't reviewed the code yet, and have no opinion on bumping protocol version versus new message.\r\n",
      "created_at" : "2015-10-21T19:34:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-150002489",
      "id" : 150002489,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-21T19:35:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/150002489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/331997?v=3",
         "events_url" : "https://api.github.com/users/gavinandresen/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gavinandresen/followers",
         "following_url" : "https://api.github.com/users/gavinandresen/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gavinandresen/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gavinandresen",
         "id" : 331997,
         "login" : "gavinandresen",
         "organizations_url" : "https://api.github.com/users/gavinandresen/orgs",
         "received_events_url" : "https://api.github.com/users/gavinandresen/received_events",
         "repos_url" : "https://api.github.com/users/gavinandresen/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gavinandresen/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gavinandresen"
      }
   },
   {
      "body" : "@gavinandresen Any chance you could repeat your test with the code in #6867?  (This change is great, and we should do it, but I expect that almost all of the improvement in that benchmark will be from setting TCP_NODELAY.)",
      "created_at" : "2015-10-21T23:56:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-150057108",
      "id" : 150057108,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-21T23:56:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/150057108",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Yes, I'll re-run tomorrow when I'm back in my office.\n\n--\nGavin Andresen\n\n\n> On Oct 21, 2015, at 7:56 PM, Gregory Maxwell <notifications@github.com> wrote:\n> \n> @gavinandresen Any chance you could repeat your test with the code in #6867? (This change is great, and we should do it, but I expect that almost all of the improvement in that benchmark will be from setting TCP_NODELAY.)\n> \n> Ã¢ÂÂ\n> Reply to this email directly or view it on GitHub.\n> \n",
      "created_at" : "2015-10-22T00:18:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-150061027",
      "id" : 150061027,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-22T00:18:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/150061027",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/331997?v=3",
         "events_url" : "https://api.github.com/users/gavinandresen/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gavinandresen/followers",
         "following_url" : "https://api.github.com/users/gavinandresen/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gavinandresen/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gavinandresen",
         "id" : 331997,
         "login" : "gavinandresen",
         "organizations_url" : "https://api.github.com/users/gavinandresen/orgs",
         "received_events_url" : "https://api.github.com/users/gavinandresen/received_events",
         "repos_url" : "https://api.github.com/users/gavinandresen/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gavinandresen/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gavinandresen"
      }
   },
   {
      "body" : "I believe this is ready for review; so far it doesn't seem like the BIP (which relates to activation/deployment only) is likely to change substantively from what was originally proposed (see bitcoin/bips#221).  It would be great to get this merged for 0.12 if possible.",
      "created_at" : "2015-10-23T20:46:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-150686158",
      "id" : 150686158,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-10-23T20:46:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/150686158",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "> I don't think it's important that the property is searchable. For me I'd ask should this be its own message, or should we define a \"flags\" message, for sending more, non-searchable capabilities.\r\n\r\nLate to the party, but I prefer the way how it is implemented now - to have a separate message for requesting this feature - to a generic 'flags' message, as well as to adding a version bit.\r\n\r\nRationale: If centralization bottlenecks can be avoided (\"another set of flags to allocate\"), that's strongly preferable.\r\n\r\nutACK, intend to test.\r\n\r\n",
      "created_at" : "2015-11-13T12:22:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-156417477",
      "id" : 156417477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-13T13:20:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156417477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44799570"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44799570"
         }
      },
      "body" : "Can't this result in duplicate in-flights? The fact that it's not yet our tip does not imply we're not downloading it yet.\r\n\r\nEDIT: nevermind, those aren't added to vToFetch.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T16:10:59Z",
      "diff_hunk" : "@@ -4439,6 +4527,28 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256());\n         }\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+        // If this set of headers is valid and ends in a block with more work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44799570",
      "id" : 44799570,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 243,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44799570",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44800419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44800419"
         }
      },
      "body" : "Do we still want to inv in this case?",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T16:17:20Z",
      "diff_hunk" : "@@ -4970,6 +5080,92 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44800419",
      "id" : 44800419,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 297,
      "path" : "src/main.cpp",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44800419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Concept ACK. Thorough code review ACK with one small nit. Lightly tested (two peers with this pull succesfully relay blocks across the internet, verified with -debug=net).",
      "created_at" : "2015-11-13T16:22:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-156478436",
      "id" : 156478436,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-13T16:22:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156478436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Needs rebase.",
      "created_at" : "2015-11-13T16:25:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-156479219",
      "id" : 156479219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-13T16:25:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156479219",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44812615"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44812615"
         }
      },
      "body" : "It's possible (probable?) that the last entry in vBlockHashesToAnnounce is our current tip (so we do want to inv it), but it is also possible that it hasn't made it there yet, and that last entry is some old tip that has now been reorged out.\r\n\r\nI think it would be safe to add a check below to only inv the last item if it's an ancestor of our current tip; does that sound right?  ",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T17:58:21Z",
      "diff_hunk" : "@@ -4970,6 +5080,92 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44812615",
      "id" : 44812615,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 297,
      "path" : "src/main.cpp",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44812615",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44813816"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44813816"
         }
      },
      "body" : "I think it's harmless, as the current code in this PR mimicks the old behaviour. But if we're doing the check anyway, I think we can skip the entry.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T18:09:19Z",
      "diff_hunk" : "@@ -4970,6 +5080,92 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44813816",
      "id" : 44813816,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 297,
      "path" : "src/main.cpp",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44813816",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44814050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44814050"
         }
      },
      "body" : "I think the code to address this edge case is easy to write, but I believe this situation is so rare that it might be better to not add this code that we can't really test?  (At least I can't figure out how I'd test it...)\r\n\r\nI think it might be better to just add a `LogPrint(\"net\", ...)` debug message in the event that we're sending an inv for a block that is not on the main chain, rather than change network behavior.  The downside to sending an extra inv in what we think is a rare situation is quite small, whereas if there's a bug in this code somehow and it overly suppresses inv's that could be both problematic and difficult to track down.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T18:11:46Z",
      "diff_hunk" : "@@ -4970,6 +5080,92 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44814050",
      "id" : 44814050,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 297,
      "path" : "src/main.cpp",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44814050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44814190"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44814190"
         }
      },
      "body" : "Fair enough. It won't hurt.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-13T18:13:10Z",
      "diff_hunk" : "@@ -4970,6 +5080,92 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r44814190",
      "id" : 44814190,
      "original_commit_id" : "83602363a391633f0fdb9a836c5d40e94ec8db98",
      "original_position" : 297,
      "path" : "src/main.cpp",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44814190",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Rebased and added log message when trying to announce a stale block.",
      "created_at" : "2015-11-13T18:25:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-156509115",
      "id" : 156509115,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-13T18:25:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156509115",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I'm looking into an issue @morcos noticed this afternoon; it seems problematic to update pindexBestKnownBlock from a locator received with a getheaders message, because that would imply we can download such blocks from our peer. Yet our peer can generate locators from headers they have rather than from blocks they have.\n\nI am testing just removing that block of code; will update this PR once I confirm that is safe.",
      "created_at" : "2015-11-16T22:03:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-157185700",
      "id" : 157185700,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-16T22:03:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/157185700",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "@sdaftuar @morcos Good catch, and too bad. I doubt it matters much.",
      "created_at" : "2015-11-16T22:42:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-157195256",
      "id" : 157195256,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-16T22:42:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/157195256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Updated this PR to eliminate updating `pindexBestKnownBlock` from the locator, and squashed back down to one commit.\r\n\r\nThe reason I had put this in initially was that I was concerned about there being a potential bootstrapping problem, but after further thought and some light testing I don't think there's a problem.  The initial getheaders sync that happens after a connection is established should ensure that headers announcements start flowing immediately.\r\n\r\n",
      "created_at" : "2015-11-17T15:40:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-157407642",
      "id" : 157407642,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-17T16:02:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/157407642",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45095904"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45095904"
         }
      },
      "body" : "It might be better to delete this check.  pindexLast shouldn't be set to a block that returns false from AcceptBlockHeader even if we already have the header.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T18:10:35Z",
      "diff_hunk" : "@@ -4515,12 +4574,21 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         CBlockIndex *pindexLast = NULL;\n+        std::vector<CBlockIndex *> vToFetch;\n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n         BOOST_FOREACH(const CBlockHeader& header, headers) {\n             CValidationState state;\n             if (pindexLast != NULL && header.hashPrevBlock != pindexLast->GetBlockHash()) {\n                 Misbehaving(pfrom->GetId(), 20);\n                 return error(\"non-continuous headers sequence\");\n             }\n+            BlockMap::iterator it = mapBlockIndex.find(header.GetHash());\n+            if (it != mapBlockIndex.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45095904",
      "id" : 45095904,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 192,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45095904",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45097901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45097901"
         }
      },
      "body" : "add !fimporting && !fReindex",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T18:24:50Z",
      "diff_hunk" : "@@ -4515,12 +4574,21 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         CBlockIndex *pindexLast = NULL;\n+        std::vector<CBlockIndex *> vToFetch;\n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45097901",
      "id" : 45097901,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 184,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45097901",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45098001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45098001"
         }
      },
      "body" : "nit: already checked fCanDirectFetch above.   maybe check vToFetch.size() ",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T18:25:28Z",
      "diff_hunk" : "@@ -4542,6 +4616,28 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256());\n         }\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+        // If this set of headers is valid and ends in a block with more work\n+        // than our tip, download as much as possible.\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork < pindexLast->nChainWork) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45098001",
      "id" : 45098001,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 221,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45098001",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45111900"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45111900"
         }
      },
      "body" : "comment incorrect\r\n",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T19:59:07Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+SendHeadersTest -- test behavior of headers messages to announce blocks.\n+\n+Setup: \n+\n+- Two nodes, two p2p connections to node0. One p2p connection should only ever\n+  receive inv's (omitted from testing description below, this is our control).\n+  Second node is used for creating reorgs.\n+\n+Part 1: No headers announcements before \"sendheaders\"\n+a. node mines a block [expect: inv]\n+   send getdata for the block [expect: block]\n+b. node mines another block [expect: inv]\n+   send getheaders and getdata [expect: headers, then block]\n+c. node mines another block [expect: inv]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45111900",
      "id" : 45111900,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 27,
      "path" : "qa/rpc-tests/sendheaders.py",
      "position" : 27,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45111900",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45112773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45112773"
         }
      },
      "body" : "this shouldn't be necessary",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T20:04:34Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+SendHeadersTest -- test behavior of headers messages to announce blocks.\n+\n+Setup: \n+\n+- Two nodes, two p2p connections to node0. One p2p connection should only ever\n+  receive inv's (omitted from testing description below, this is our control).\n+  Second node is used for creating reorgs.\n+\n+Part 1: No headers announcements before \"sendheaders\"\n+a. node mines a block [expect: inv]\n+   send getdata for the block [expect: block]\n+b. node mines another block [expect: inv]\n+   send getheaders and getdata [expect: headers, then block]\n+c. node mines another block [expect: inv]\n+   send getheaders/getdata [expect headers, then block]\n+   peer mines a block, announces with header [expect: getdata]\n+d. node mines another block [expect: inv]\n+\n+Part 2: After \"sendheaders\", headers announcements should generally work.\n+a. peer sends sendheaders [expect: no response]\n+   peer sends getheaders with current tip [expect: no response]\n+b. node mines a block [expect: tip header]\n+   peer sends getdata [expect: block]\n+c. for N in 1, ..., 10:\n+   * for announce-type in {inv, header}\n+     - peer mines N blocks, announces with announce-type\n+       [ expect: getheaders/getdata or getdata, deliver block(s) ]\n+     - node mines a block [ expect: 1 header ]\n+\n+Part 3: Headers announcements stop after large reorg and resume after getheaders or inv from peer.\n+- For response-type in {inv, getheaders}\n+  * node mines a 7 block reorg [ expect: headers announcement of 8 blocks ]\n+  * node mines an 8-block reorg [ expect: inv at tip ]\n+  * peer responds with getblocks/getdata [expect: inv, blocks ]\n+  * node mines another block [ expect: inv at tip, peer sends getdata, expect: block ]\n+  * node mines another block at tip [ expect: inv ]\n+  * peer responds with getheaders with an old hashstop more than 8 blocks back [expect: headers]\n+  * peer requests block [ expect: block ]\n+  * node mines another block at tip [ expect: inv, peer sends getdata, expect: block ]\n+  * peer sends response-type [expect headers if getheaders, getheaders/getdata if mining new block]\n+  * node mines 1 block [expect: 1 header, peer responds with getdata]\n+'''\n+\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.last_getdata = None\n+        self.sleep_time = 0.05\n+        self.block_announced = False\n+\n+    def clear_last_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Request data for a list of block hashes\n+    def get_data(self, block_hashes):\n+        msg = msg_getdata()\n+        for x in block_hashes:\n+            msg.inv.append(CInv(2, x))\n+        self.connection.send_message(msg)\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_block_inv(self, blockhash):\n+        msg = msg_inv()\n+        msg.inv = [CInv(2, blockhash)]\n+        self.connection.send_message(msg)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    # Test whether the last announcement we received had the\n+    # right header or the right inv\n+    # inv and headers should be lists of block hashes\n+    def check_last_announcement(self, headers=None, inv=None):\n+        expect_headers = headers if headers != None else []\n+        expect_inv = inv if inv != None else []\n+        test_function = lambda: self.block_announced\n+        self.sync(test_function)\n+        with mininode_lock:\n+            self.block_announced = False\n+\n+            success = True\n+            compare_inv = []\n+            if self.last_inv != None:\n+                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if compare_inv != expect_inv:\n+                success = False\n+\n+            hash_headers = []\n+            if self.last_headers != None:\n+                # treat headers as a list of block hashes\n+                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+            if hash_headers != expect_headers:\n+                success = False\n+\n+            self.last_inv = None\n+            self.last_headers = None\n+        return success\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+    def send_getblocks(self, locator):\n+        getblocks_message = msg_getblocks()\n+        getblocks_message.locator.vHave = locator\n+        self.send_message(getblocks_message)\n+\n+# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n+# \"sendheaders\" message.\n+class InvNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class SendHeadersTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes = start_nodes(2, self.options.tmpdir, [[\"-debug\"]]*2)\n+        connect_nodes(self.nodes[0], 1)\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count):\n+        self.nodes[0].generate(count)\n+        return int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+    # mine a reorg that invalidates length blocks (replacing them with\n+    # length+1 blocks).\n+    # peers is the p2p nodes we're using; we clear their state after the\n+    # to-be-reorged-out blocks are mined, so that we don't break later tests.\n+    # return the list of block hashes newly mined\n+    def mine_reorg(self, length, peers):\n+        self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n+        sync_blocks(self.nodes, wait=0.1)\n+        [x.clear_last_announcement() for x in peers]\n+\n+        tip_height = self.nodes[1].getblockcount()\n+        hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n+        self.nodes[1].invalidateblock(hash_to_invalidate)\n+        all_hashes = self.nodes[1].generate(length+1) # Must be longer than the orig chain\n+        sync_blocks(self.nodes, wait=0.1)\n+        return [int(\"0x\" + x + \"L\", 0) for x in all_hashes]\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        inv_node = InvNode()\n+        test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n+        inv_node.add_connection(connections[0])\n+        test_node.add_connection(connections[1])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        inv_node.wait_for_verack()\n+        test_node.wait_for_verack()\n+\n+        tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+        # PART 1\n+        # 1. Mine a block; expect inv announcements each time\n+        print \"Part 1: headers don't start before sendheaders message...\"\n+        for i in xrange(4):\n+            old_tip = tip\n+            tip = self.mine_blocks(1)\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            # Try a few different responses; none should affect next announcement\n+            if i == 0:\n+                # first request the block\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip, timeout=5)\n+            elif i == 1:\n+                # next try requesting header and block\n+                test_node.get_headers(locator=[old_tip], hashstop=tip)\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip)\n+                test_node.clear_last_announcement() # since we requested headers...\n+            elif i == 2:\n+                # this time announce own block via headers\n+                height = self.nodes[0].getblockcount()\n+                last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+                block_time = last_time + 1\n+                new_block = create_block(tip, create_coinbase(height+1), block_time)\n+                new_block.solve()\n+                test_node.send_header_for_blocks([new_block])\n+                test_node.wait_for_getdata([new_block.sha256], timeout=5)\n+                test_node.send_message(msg_block(new_block))\n+                test_node.sync_with_ping() # make sure this block is processed\n+                inv_node.clear_last_announcement()\n+                test_node.clear_last_announcement()\n+\n+        print \"Part 1: success!\"\n+        print \"Part 2: announce blocks with headers after sendheaders message...\"\n+        # PART 2\n+        # 2. Send a sendheaders message and test that headers announcements\n+        # commence and keep working.\n+        test_node.send_message(msg_sendheaders())\n+        prev_tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        test_node.get_headers(locator=[prev_tip], hashstop=0L)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45112773",
      "id" : 45112773,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 290,
      "path" : "qa/rpc-tests/sendheaders.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45112773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45112859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45112859"
         }
      },
      "body" : "why do you do this?",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T20:05:17Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+SendHeadersTest -- test behavior of headers messages to announce blocks.\n+\n+Setup: \n+\n+- Two nodes, two p2p connections to node0. One p2p connection should only ever\n+  receive inv's (omitted from testing description below, this is our control).\n+  Second node is used for creating reorgs.\n+\n+Part 1: No headers announcements before \"sendheaders\"\n+a. node mines a block [expect: inv]\n+   send getdata for the block [expect: block]\n+b. node mines another block [expect: inv]\n+   send getheaders and getdata [expect: headers, then block]\n+c. node mines another block [expect: inv]\n+   send getheaders/getdata [expect headers, then block]\n+   peer mines a block, announces with header [expect: getdata]\n+d. node mines another block [expect: inv]\n+\n+Part 2: After \"sendheaders\", headers announcements should generally work.\n+a. peer sends sendheaders [expect: no response]\n+   peer sends getheaders with current tip [expect: no response]\n+b. node mines a block [expect: tip header]\n+   peer sends getdata [expect: block]\n+c. for N in 1, ..., 10:\n+   * for announce-type in {inv, header}\n+     - peer mines N blocks, announces with announce-type\n+       [ expect: getheaders/getdata or getdata, deliver block(s) ]\n+     - node mines a block [ expect: 1 header ]\n+\n+Part 3: Headers announcements stop after large reorg and resume after getheaders or inv from peer.\n+- For response-type in {inv, getheaders}\n+  * node mines a 7 block reorg [ expect: headers announcement of 8 blocks ]\n+  * node mines an 8-block reorg [ expect: inv at tip ]\n+  * peer responds with getblocks/getdata [expect: inv, blocks ]\n+  * node mines another block [ expect: inv at tip, peer sends getdata, expect: block ]\n+  * node mines another block at tip [ expect: inv ]\n+  * peer responds with getheaders with an old hashstop more than 8 blocks back [expect: headers]\n+  * peer requests block [ expect: block ]\n+  * node mines another block at tip [ expect: inv, peer sends getdata, expect: block ]\n+  * peer sends response-type [expect headers if getheaders, getheaders/getdata if mining new block]\n+  * node mines 1 block [expect: 1 header, peer responds with getdata]\n+'''\n+\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.last_getdata = None\n+        self.sleep_time = 0.05\n+        self.block_announced = False\n+\n+    def clear_last_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Request data for a list of block hashes\n+    def get_data(self, block_hashes):\n+        msg = msg_getdata()\n+        for x in block_hashes:\n+            msg.inv.append(CInv(2, x))\n+        self.connection.send_message(msg)\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_block_inv(self, blockhash):\n+        msg = msg_inv()\n+        msg.inv = [CInv(2, blockhash)]\n+        self.connection.send_message(msg)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    # Test whether the last announcement we received had the\n+    # right header or the right inv\n+    # inv and headers should be lists of block hashes\n+    def check_last_announcement(self, headers=None, inv=None):\n+        expect_headers = headers if headers != None else []\n+        expect_inv = inv if inv != None else []\n+        test_function = lambda: self.block_announced\n+        self.sync(test_function)\n+        with mininode_lock:\n+            self.block_announced = False\n+\n+            success = True\n+            compare_inv = []\n+            if self.last_inv != None:\n+                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if compare_inv != expect_inv:\n+                success = False\n+\n+            hash_headers = []\n+            if self.last_headers != None:\n+                # treat headers as a list of block hashes\n+                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+            if hash_headers != expect_headers:\n+                success = False\n+\n+            self.last_inv = None\n+            self.last_headers = None\n+        return success\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+    def send_getblocks(self, locator):\n+        getblocks_message = msg_getblocks()\n+        getblocks_message.locator.vHave = locator\n+        self.send_message(getblocks_message)\n+\n+# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n+# \"sendheaders\" message.\n+class InvNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class SendHeadersTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes = start_nodes(2, self.options.tmpdir, [[\"-debug\"]]*2)\n+        connect_nodes(self.nodes[0], 1)\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count):\n+        self.nodes[0].generate(count)\n+        return int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+    # mine a reorg that invalidates length blocks (replacing them with\n+    # length+1 blocks).\n+    # peers is the p2p nodes we're using; we clear their state after the\n+    # to-be-reorged-out blocks are mined, so that we don't break later tests.\n+    # return the list of block hashes newly mined\n+    def mine_reorg(self, length, peers):\n+        self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n+        sync_blocks(self.nodes, wait=0.1)\n+        [x.clear_last_announcement() for x in peers]\n+\n+        tip_height = self.nodes[1].getblockcount()\n+        hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n+        self.nodes[1].invalidateblock(hash_to_invalidate)\n+        all_hashes = self.nodes[1].generate(length+1) # Must be longer than the orig chain\n+        sync_blocks(self.nodes, wait=0.1)\n+        return [int(\"0x\" + x + \"L\", 0) for x in all_hashes]\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        inv_node = InvNode()\n+        test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n+        inv_node.add_connection(connections[0])\n+        test_node.add_connection(connections[1])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        inv_node.wait_for_verack()\n+        test_node.wait_for_verack()\n+\n+        tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+        # PART 1\n+        # 1. Mine a block; expect inv announcements each time\n+        print \"Part 1: headers don't start before sendheaders message...\"\n+        for i in xrange(4):\n+            old_tip = tip\n+            tip = self.mine_blocks(1)\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            # Try a few different responses; none should affect next announcement\n+            if i == 0:\n+                # first request the block\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip, timeout=5)\n+            elif i == 1:\n+                # next try requesting header and block\n+                test_node.get_headers(locator=[old_tip], hashstop=tip)\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip)\n+                test_node.clear_last_announcement() # since we requested headers...\n+            elif i == 2:\n+                # this time announce own block via headers\n+                height = self.nodes[0].getblockcount()\n+                last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+                block_time = last_time + 1\n+                new_block = create_block(tip, create_coinbase(height+1), block_time)\n+                new_block.solve()\n+                test_node.send_header_for_blocks([new_block])\n+                test_node.wait_for_getdata([new_block.sha256], timeout=5)\n+                test_node.send_message(msg_block(new_block))\n+                test_node.sync_with_ping() # make sure this block is processed\n+                inv_node.clear_last_announcement()\n+                test_node.clear_last_announcement()\n+\n+        print \"Part 1: success!\"\n+        print \"Part 2: announce blocks with headers after sendheaders message...\"\n+        # PART 2\n+        # 2. Send a sendheaders message and test that headers announcements\n+        # commence and keep working.\n+        test_node.send_message(msg_sendheaders())\n+        prev_tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        test_node.get_headers(locator=[prev_tip], hashstop=0L)\n+        test_node.sync_with_ping()\n+        test_node.clear_last_announcement() # Clear out empty headers response\n+\n+        # Now that we've synced headers, headers announcements should work\n+        tip = self.mine_blocks(1)\n+        assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+        assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+        test_node.get_data([tip])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45112859",
      "id" : 45112859,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 298,
      "path" : "qa/rpc-tests/sendheaders.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45112859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45117256"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45117256"
         }
      },
      "body" : "This block of code already has a guard so that we don't process headers received while importing/reindexing.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T20:40:45Z",
      "diff_hunk" : "@@ -4515,12 +4574,21 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         CBlockIndex *pindexLast = NULL;\n+        std::vector<CBlockIndex *> vToFetch;\n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45117256",
      "id" : 45117256,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 184,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45117256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45120068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45120068"
         }
      },
      "body" : "Surprisingly, this code is necessary to make the test work.  Turns out there's an unusual feature in the getheaders handling, where we set `pindexBestHeaderSent` to `chainActive.Tip()` in two situations: if we actually are sending the tip, or if we have nothing to send.  I think the latter case can only happen if our peer has our tip in their locator, so I believe this behavior is desirable, if surprising.\r\n\r\nI've added a comment to the relevant line of code in main.cpp explaining this behavior.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-17T21:02:29Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+SendHeadersTest -- test behavior of headers messages to announce blocks.\n+\n+Setup: \n+\n+- Two nodes, two p2p connections to node0. One p2p connection should only ever\n+  receive inv's (omitted from testing description below, this is our control).\n+  Second node is used for creating reorgs.\n+\n+Part 1: No headers announcements before \"sendheaders\"\n+a. node mines a block [expect: inv]\n+   send getdata for the block [expect: block]\n+b. node mines another block [expect: inv]\n+   send getheaders and getdata [expect: headers, then block]\n+c. node mines another block [expect: inv]\n+   send getheaders/getdata [expect headers, then block]\n+   peer mines a block, announces with header [expect: getdata]\n+d. node mines another block [expect: inv]\n+\n+Part 2: After \"sendheaders\", headers announcements should generally work.\n+a. peer sends sendheaders [expect: no response]\n+   peer sends getheaders with current tip [expect: no response]\n+b. node mines a block [expect: tip header]\n+   peer sends getdata [expect: block]\n+c. for N in 1, ..., 10:\n+   * for announce-type in {inv, header}\n+     - peer mines N blocks, announces with announce-type\n+       [ expect: getheaders/getdata or getdata, deliver block(s) ]\n+     - node mines a block [ expect: 1 header ]\n+\n+Part 3: Headers announcements stop after large reorg and resume after getheaders or inv from peer.\n+- For response-type in {inv, getheaders}\n+  * node mines a 7 block reorg [ expect: headers announcement of 8 blocks ]\n+  * node mines an 8-block reorg [ expect: inv at tip ]\n+  * peer responds with getblocks/getdata [expect: inv, blocks ]\n+  * node mines another block [ expect: inv at tip, peer sends getdata, expect: block ]\n+  * node mines another block at tip [ expect: inv ]\n+  * peer responds with getheaders with an old hashstop more than 8 blocks back [expect: headers]\n+  * peer requests block [ expect: block ]\n+  * node mines another block at tip [ expect: inv, peer sends getdata, expect: block ]\n+  * peer sends response-type [expect headers if getheaders, getheaders/getdata if mining new block]\n+  * node mines 1 block [expect: 1 header, peer responds with getdata]\n+'''\n+\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.last_getdata = None\n+        self.sleep_time = 0.05\n+        self.block_announced = False\n+\n+    def clear_last_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Request data for a list of block hashes\n+    def get_data(self, block_hashes):\n+        msg = msg_getdata()\n+        for x in block_hashes:\n+            msg.inv.append(CInv(2, x))\n+        self.connection.send_message(msg)\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_block_inv(self, blockhash):\n+        msg = msg_inv()\n+        msg.inv = [CInv(2, blockhash)]\n+        self.connection.send_message(msg)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    # Test whether the last announcement we received had the\n+    # right header or the right inv\n+    # inv and headers should be lists of block hashes\n+    def check_last_announcement(self, headers=None, inv=None):\n+        expect_headers = headers if headers != None else []\n+        expect_inv = inv if inv != None else []\n+        test_function = lambda: self.block_announced\n+        self.sync(test_function)\n+        with mininode_lock:\n+            self.block_announced = False\n+\n+            success = True\n+            compare_inv = []\n+            if self.last_inv != None:\n+                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if compare_inv != expect_inv:\n+                success = False\n+\n+            hash_headers = []\n+            if self.last_headers != None:\n+                # treat headers as a list of block hashes\n+                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+            if hash_headers != expect_headers:\n+                success = False\n+\n+            self.last_inv = None\n+            self.last_headers = None\n+        return success\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+    def send_getblocks(self, locator):\n+        getblocks_message = msg_getblocks()\n+        getblocks_message.locator.vHave = locator\n+        self.send_message(getblocks_message)\n+\n+# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n+# \"sendheaders\" message.\n+class InvNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class SendHeadersTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes = start_nodes(2, self.options.tmpdir, [[\"-debug\"]]*2)\n+        connect_nodes(self.nodes[0], 1)\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count):\n+        self.nodes[0].generate(count)\n+        return int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+    # mine a reorg that invalidates length blocks (replacing them with\n+    # length+1 blocks).\n+    # peers is the p2p nodes we're using; we clear their state after the\n+    # to-be-reorged-out blocks are mined, so that we don't break later tests.\n+    # return the list of block hashes newly mined\n+    def mine_reorg(self, length, peers):\n+        self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n+        sync_blocks(self.nodes, wait=0.1)\n+        [x.clear_last_announcement() for x in peers]\n+\n+        tip_height = self.nodes[1].getblockcount()\n+        hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n+        self.nodes[1].invalidateblock(hash_to_invalidate)\n+        all_hashes = self.nodes[1].generate(length+1) # Must be longer than the orig chain\n+        sync_blocks(self.nodes, wait=0.1)\n+        return [int(\"0x\" + x + \"L\", 0) for x in all_hashes]\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        inv_node = InvNode()\n+        test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n+        inv_node.add_connection(connections[0])\n+        test_node.add_connection(connections[1])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        inv_node.wait_for_verack()\n+        test_node.wait_for_verack()\n+\n+        tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+        # PART 1\n+        # 1. Mine a block; expect inv announcements each time\n+        print \"Part 1: headers don't start before sendheaders message...\"\n+        for i in xrange(4):\n+            old_tip = tip\n+            tip = self.mine_blocks(1)\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            # Try a few different responses; none should affect next announcement\n+            if i == 0:\n+                # first request the block\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip, timeout=5)\n+            elif i == 1:\n+                # next try requesting header and block\n+                test_node.get_headers(locator=[old_tip], hashstop=tip)\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip)\n+                test_node.clear_last_announcement() # since we requested headers...\n+            elif i == 2:\n+                # this time announce own block via headers\n+                height = self.nodes[0].getblockcount()\n+                last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+                block_time = last_time + 1\n+                new_block = create_block(tip, create_coinbase(height+1), block_time)\n+                new_block.solve()\n+                test_node.send_header_for_blocks([new_block])\n+                test_node.wait_for_getdata([new_block.sha256], timeout=5)\n+                test_node.send_message(msg_block(new_block))\n+                test_node.sync_with_ping() # make sure this block is processed\n+                inv_node.clear_last_announcement()\n+                test_node.clear_last_announcement()\n+\n+        print \"Part 1: success!\"\n+        print \"Part 2: announce blocks with headers after sendheaders message...\"\n+        # PART 2\n+        # 2. Send a sendheaders message and test that headers announcements\n+        # commence and keep working.\n+        test_node.send_message(msg_sendheaders())\n+        prev_tip = int(\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        test_node.get_headers(locator=[prev_tip], hashstop=0L)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45120068",
      "id" : 45120068,
      "original_commit_id" : "4faca45a67b7a075813c748fb98c60d3d9f41482",
      "original_position" : 290,
      "path" : "qa/rpc-tests/sendheaders.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-23T20:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45120068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Pushed a commit to address @morcos' comments.\r\n\r\nIn cleaning up the RPC test I was surprised with what happens to `pindexBestHeaderSent` when a peer sends a getheaders with a locator that is up-to-date with our tip.  Though I took out the code to parse the locator and update `pindexBestKnownBlock`, it turns out that if we generate no headers to return then we will end up setting `pindexBestHeaderSent` to equal `chainActive.Tip()`.  \r\n\r\nThis behavior was just due to a quirk in the code (the test that does that is checking to see if we've walked off the end of chainActive and assumes that if we're at a NULL pointer then we must have returned our tip to the peer), but I believe this is correct behavior.  I added a comment to the code explaining this quirk, but am leaving it in because I think it's correct and beneficial.\r\n\r\nOn a separate note: I was reminded when I looked at this again that if a peer sends us a getheaders with a locator that is caught up to our tip, then we'll send back an empty headers message.  Is it important that this behavior be preserved?  I left it unchanged for now, but I can clean this up and suppress an empty response if it's safe to do so, either in this pull or separately.\r\n",
      "created_at" : "2015-11-18T13:17:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-157709651",
      "id" : 157709651,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-18T13:17:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/157709651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I discovered there were some problems in the direct fetch logic.\r\n\r\nThe code was structured so that we could only direct fetch blocks which were announced in a set of headers.  However, in the case of a reorg, we may have some of the headers on the reorged-to-chain, which our peers will not re-announce to us -- meaning that the direct-fetch logic wouldn't request needed missing blocks immediately.\r\n\r\nI've restructured the direct fetch logic so that if we want to download towards the latest block a peer has announced to us, then we walk back from that tip and consider every block until we find one that is on our current chain.  (We try to download every block that we don't have that is not already in-flight, and we bail out if we're walking back too many blocks.)\r\n\r\nI also realized that `sendheaders.py` had no tests for the direct fetch logic, so I updated it to exercise that part of the code as well.",
      "created_at" : "2015-11-23T20:49:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-159060094",
      "id" : 159060094,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-23T20:49:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/159060094",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Great work @sdaftuar ",
      "created_at" : "2015-11-24T01:39:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-159124255",
      "id" : 159124255,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-24T01:39:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/159124255",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45733142"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45733142"
         }
      },
      "body" : "Looks like I forgot to remove this.",
      "commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "created_at" : "2015-11-24T13:18:42Z",
      "diff_hunk" : "@@ -4521,6 +4584,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 Misbehaving(pfrom->GetId(), 20);\n                 return error(\"non-continuous headers sequence\");\n             }\n+            BlockMap::iterator it = mapBlockIndex.find(header.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#discussion_r45733142",
      "id" : 45733142,
      "original_commit_id" : "9fa8c48abbee1fe9d765705897e105274421d385",
      "original_position" : 187,
      "path" : "src/main.cpp",
      "position" : 187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6494",
      "updated_at" : "2015-11-24T13:18:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/45733142",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Needs rebase.",
      "created_at" : "2015-11-28T13:03:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-160294074",
      "id" : 160294074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-28T13:03:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/160294074",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Closed via #7129.",
      "created_at" : "2015-11-29T12:06:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6494#issuecomment-160411793",
      "id" : 160411793,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6494",
      "updated_at" : "2015-11-29T12:06:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/160411793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
