[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169"
         }
      },
      "body" : "`le` is the same name as the first argument here, it will bring shadow warning.",
      "commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "created_at" : "2017-02-24T07:19:20Z",
      "diff_hunk" : "@@ -0,0 +1,788 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (!isLogRowContinuation(row)) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169",
      "id" : 102890169,
      "original_commit_id" : "563ec9e94744e0050ced5aff9d3db54c2fffb3ee",
      "original_position" : 552,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 23659997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2017-02-24T20:29:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "This is how it looks like here on testnet:\r\n\r\n<img width=\"1167\" alt=\"screen shot 2017-02-24 at 08 22 39\" src=\"https://cloud.githubusercontent.com/assets/6848764/23294190/86f5186e-fa6a-11e6-83bd-dfa5811b8b68.png\">\r\n",
      "created_at" : "2017-02-24T07:24:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282222921",
      "id" : 282222921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "updated_at" : "2017-02-24T07:24:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282222921",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Thanks. Will review.\r\nI just played a bit with it and had massive locking issues on mainnet during catch-up of 2-3 weeks.",
      "created_at" : "2017-02-24T07:30:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282223846",
      "id" : 282223846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "updated_at" : "2017-02-24T07:30:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282223846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Running this PR (built over gitian: https://bitcoin.jonasschnelli.ch/build/54) makes Bitcoin-Qt and also the rest of my apps almost unusable. Had to force kill the process.",
      "created_at" : "2017-03-17T15:26:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-287385325",
      "id" : 287385325,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "updated_at" : "2017-03-17T15:26:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/287385325",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794"
         }
      },
      "body" : "IMO reading each block will cause a massive slow down during IBD / catchup.",
      "commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "created_at" : "2017-03-17T15:29:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794",
      "id" : 106676794,
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 619,
      "pull_request_review_id" : 27613799,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2017-03-17T15:29:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143"
         }
      },
      "body" : "What we probably should do is adding each blocks size and vtx.size() to CBlockIndex* (would require to alter the block index, migration, etc. yes).",
      "commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "created_at" : "2017-03-17T15:30:54Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143",
      "id" : 106677143,
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 623,
      "pull_request_review_id" : 27614161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2017-03-17T15:30:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495"
         }
      },
      "body" : "The OS should have the data cached already?",
      "commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "created_at" : "2017-03-17T22:49:33Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495",
      "id" : 106759495,
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 619,
      "pull_request_review_id" : 27703245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2017-03-17T22:49:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594"
         }
      },
      "body" : "That wouldn't change anything here...?",
      "commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "created_at" : "2017-03-17T22:50:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594",
      "id" : 106759594,
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 623,
      "pull_request_review_id" : 27703327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2017-03-17T22:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   }
]
