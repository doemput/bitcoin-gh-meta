[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95224058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95224058"
         }
      },
      "body" : "couple of years out of date :)",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-09T19:09:29Z",
      "diff_hunk" : "@@ -0,0 +1,395 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95224058",
      "id" : 95224058,
      "original_commit_id" : "7fd784a6345e929ac77c6ec7bd1796a77f1cf312",
      "original_position" : 1,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 15772203,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95224058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95226580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95226580"
         }
      },
      "body" : "will fix!",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-09T19:22:04Z",
      "diff_hunk" : "@@ -0,0 +1,395 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95226580",
      "id" : 95226580,
      "original_commit_id" : "7fd784a6345e929ac77c6ec7bd1796a77f1cf312",
      "original_position" : 1,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 15774812,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95226580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Sorry for the line noise; the earlier build error should be addressed now.",
      "created_at" : "2017-01-09T23:55:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-271445743",
      "id" : 271445743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-01-09T23:55:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271445743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680199"
         }
      },
      "body" : "Maybe add a comment noting BasicTestingSetup can't be used because it doesn't set nScriptCheckThreads.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T21:51:00Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680199",
      "id" : 95680199,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 21,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680298"
         }
      },
      "body" : "Maybe declare 128 and any other common parameters as constants above.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T21:51:42Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680298",
      "id" : 95680298,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 122,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680298",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95681211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95681211"
         }
      },
      "body" : "Maybe replace the loop with vCheck.resize(min(total, r)).",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T21:56:34Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95681211",
      "id" : 95681211,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 135,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95681211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95682154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95682154"
         }
      },
      "body" : "Why is small_queue a shared pointer, not a unique pointer or just plain stack variable? Maybe add a comment explaining. Also, you could probably use make_shared if it does need to be a shared pointer.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:01:40Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95682154",
      "id" : 95682154,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 122,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95682154",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683341"
         }
      },
      "body" : "Would seem more direct to just BOOST_CHECK the control.Wait() call instead of putting the results in an intermediate array. This way is ok too, though.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:08:22Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683341",
      "id" : 95683341,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 241,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683957"
         }
      },
      "body" : "Replacing [=] with [&] might allow small_queue not to be a shared_ptr.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:11:31Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683957",
      "id" : 95683957,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 125,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683957",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685002"
         }
      },
      "body" : "Maybe also check that UniqueCheck::results.size == COUNT.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:17:24Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685002",
      "id" : 95685002,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 275,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685133"
         }
      },
      "body" : "pathological (spelling)\r\n",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:18:15Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685133",
      "id" : 95685133,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 283,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685133",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95686968"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95686968"
         }
      },
      "body" : "Instead of having the test be nondeterministic in this way, would anything be lost if you had the MemoryCheck constructor increment a static counter when passed a true arg, and the MemoryCheck destructor decrement the counter if the object was constructed with a true arg. Then you could detect the error case explicitly by checking the counter, and not have to allocate big chunks of memory.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:28:56Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+//\n+// This test (failing) is dependent on not being able to handle",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95686968",
      "id" : 95686968,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 287,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95686968",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95688870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95688870"
         }
      },
      "body" : "I think you could easily make this test deterministic as well, eliminating the long sleep and the while (frozen) busy loops. Would just need to have ~FrozenCleanupCheck increment a counter and signal a conditional variable so you could wait here for enough jobs to be frozen, and then do the boost check. Then this could signal another condition variable to unfreeze the jobs. I think it would be worth changing this to make the test more efficient and reliable.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-11T22:39:50Z",
      "diff_hunk" : "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+//\n+// This test (failing) is dependent on not being able to handle\n+// 1000*200 MB of memory, and able to handle 600MB of memory\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::shared_ptr<Memory_Queue>(new Memory_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::shared_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+    }\n+    std::atomic<bool> finished{false};\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        FrozenCleanupCheck::frozen = true;\n+        std::vector<FrozenCleanupCheck> vChecks;\n+        vChecks.emplace_back();\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+        finished = true;\n+    });\n+    // We should never read a finished status\n+    //\n+    // Try waiting a second (which should be plenty of time to reach the hang\n+    // point in t0)\n+    //\n+    // Note that this cannot cause a spurious failure, only could mean that\n+    // the test doesn't actually end up checking that control waited.\n+    MilliSleep(1000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95688870",
      "id" : 95688870,
      "original_commit_id" : "f4f14263ad74cf612b9d948e304f0052254de6de",
      "original_position" : 343,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16244421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95688870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96090665"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96090665"
         }
      },
      "body" : "It might be clearer to replace all these bools with an enum like { STARTED, TRY_LOCK, TRY_LOCK_DONE, DONE, DONE_ACK }.\r\n\r\n",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-13T22:58:32Z",
      "diff_hunk" : "@@ -372,29 +381,40 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n     }\n     {\n         boost::thread_group tg;\n-        std::atomic<bool> has_lock {false};\n-        std::atomic<bool> done {false};\n-        std::atomic<bool> done_ack {false};\n-        tg.create_thread([&, queue]{\n-                CCheckQueueControl<FakeCheck> control(queue.get());\n-                has_lock = true;\n-                MilliSleep(1000);\n-                done = true;\n-                // Wait until the done is acknowledged\n-                while (!done_ack) {\n-                }\n-                });\n-        // Wait for thread to get the lock\n-        while (!has_lock) {}\n-        bool fails2 = false;\n-        // Agressively check that we can never aquire the lock, once\n-        // the thread has stopped check that we never got it.\n-        while (!done && !fails2) {\n-            fails2 = queue->ControlMutex.try_lock();\n+        std::mutex m;\n+        bool has_lock {false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96090665",
      "id" : 96090665,
      "original_commit_id" : "27b8cbaea84e8d31b4499e11340ed798c501c737",
      "original_position" : 237,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16669547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96090665",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96304542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96304542"
         }
      },
      "body" : "Going to ignore this, I don't think it makes it more clear (to me, it's easier to debug several variables). If someone disagrees strongly, will change.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-16T21:03:50Z",
      "diff_hunk" : "@@ -372,29 +381,40 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n     }\n     {\n         boost::thread_group tg;\n-        std::atomic<bool> has_lock {false};\n-        std::atomic<bool> done {false};\n-        std::atomic<bool> done_ack {false};\n-        tg.create_thread([&, queue]{\n-                CCheckQueueControl<FakeCheck> control(queue.get());\n-                has_lock = true;\n-                MilliSleep(1000);\n-                done = true;\n-                // Wait until the done is acknowledged\n-                while (!done_ack) {\n-                }\n-                });\n-        // Wait for thread to get the lock\n-        while (!has_lock) {}\n-        bool fails2 = false;\n-        // Agressively check that we can never aquire the lock, once\n-        // the thread has stopped check that we never got it.\n-        while (!done && !fails2) {\n-            fails2 = queue->ControlMutex.try_lock();\n+        std::mutex m;\n+        bool has_lock {false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96304542",
      "id" : 96304542,
      "original_commit_id" : "27b8cbaea84e8d31b4499e11340ed798c501c737",
      "original_position" : 237,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 16882485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96304542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "ACK, needs squashing",
      "created_at" : "2017-01-19T15:32:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-273807134",
      "id" : 273807134,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-01-19T15:32:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273807134",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Squashed!",
      "created_at" : "2017-01-19T17:07:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-273835825",
      "id" : 273835825,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-01-19T17:07:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273835825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Rebased to be on top of https://github.com/bitcoin/bitcoin/pull/9495.",
      "created_at" : "2017-01-20T22:19:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-274195370",
      "id" : 274195370,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-01-20T22:19:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/274195370",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98392131"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98392131"
         }
      },
      "body" : "The MemoryCheck struct destructor does not --, so this should not be == 0 unless no MemoryCheck constructors are ever called.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-30T08:05:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98392131",
      "id" : 98392131,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 331,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 19030165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98392131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395364"
         }
      },
      "body" : "`fake_allocated_memory -= 1`",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-30T08:38:37Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395364",
      "id" : 98395364,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 93,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 19033484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395928"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395928"
         }
      },
      "body" : "Unused variable.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-30T08:43:30Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395928",
      "id" : 98395928,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 246,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 19034083,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395928",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396352"
         }
      },
      "body" : "Doing `!fails && x < 100` here and simply `fails = queue->ControlMutex.try_lock();` would break iteration on first fail rather than iterate over all 100 (e.g. if first `try_lock()` fails).",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-30T08:46:39Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396352",
      "id" : 98396352,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 362,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 19034549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396462"
         }
      },
      "body" : "Same here with `!fails && x < 100` as above.",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-01-30T08:47:30Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {\n+            fails = fails || queue->ControlMutex.try_lock();\n+        }\n+        // Unfreeze\n+        FrozenCleanupCheck::nFrozen = 0;\n+    }\n+    // Awaken frozen destructor\n+    FrozenCleanupCheck::cv.notify_one();\n+    // Wait for control to finish\n+    t0.join();\n+    tg.interrupt_all();\n+    tg.join_all();\n+    BOOST_REQUIRE(!fails);\n+}\n+\n+\n+/** Test that CCheckQueueControl is threadsafe */\n+BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n+{\n+    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});\n+    {\n+        boost::thread_group tg;\n+        std::atomic<int> nThreads {0};\n+        std::atomic<int> fails {0};\n+        for (size_t i = 0; i < 3; ++i) {\n+            tg.create_thread(\n+                    [&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    // While sleeping, no other thread should execute to this point\n+                    auto observed = ++nThreads;\n+                    MilliSleep(10);\n+                    fails += observed  != nThreads;\n+                    });\n+        }\n+        tg.join_all();\n+        BOOST_REQUIRE(fails == 0);\n+    }\n+    {\n+        boost::thread_group tg;\n+        std::mutex m;\n+        bool has_lock {false};\n+        bool has_tried {false};\n+        bool done {false};\n+        bool done_ack {false};\n+        std::condition_variable cv;\n+        {\n+            std::unique_lock<std::mutex> l(m);\n+            tg.create_thread([&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    std::unique_lock<std::mutex> l(m);\n+                    has_lock = true;\n+                    cv.notify_one();\n+                    cv.wait(l, [&]{return has_tried;});\n+                    done = true;\n+                    cv.notify_one();\n+                    // Wait until the done is acknowledged\n+                    //\n+                    cv.wait(l, [&]{return done_ack;});\n+                    });\n+            // Wait for thread to get the lock\n+            cv.wait(l, [&](){return has_lock;});\n+            bool fails = false;\n+            for (auto x = 0; x < 100; ++x) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396462",
      "id" : 98396462,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 424,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 19034660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396462",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452594"
         }
      },
      "body" : "Yes, it was the latter. The for loop never made anything (i = 9999; i<9999). Will fix :) ",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-02-16T06:26:59Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452594",
      "id" : 101452594,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 331,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 22180743,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452594",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452623"
         }
      },
      "body" : "sure..\r\n",
      "commit_id" : "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at" : "2017-02-16T06:27:10Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452623",
      "id" : 101452623,
      "original_commit_id" : "0949835100e60901f51ce2b7cd95d912d13241a5",
      "original_position" : 362,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 22180772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
      "updated_at" : "2017-02-16T06:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Fixed the issues that @kallewoof raised, and squashed.\r\n\r\nUnsquashed preserved here https://github.com/JeremyRubin/bitcoin/tree/checkqueue-tests-unsquashed.",
      "created_at" : "2017-02-16T06:42:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-280245368",
      "id" : 280245368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-02-16T06:42:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/280245368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "utACK 96c7f2c\r\n\r\nI'm a bit concerned about non-deterministic behavior in tests as this tends to be a pain when you do run into a problem. Or is this fixed seed / PRNG so that the numbers are always the same each time? (for `GetRand()`)",
      "created_at" : "2017-02-25T17:58:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282500634",
      "id" : 282500634,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-02-25T17:58:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282500634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "body" : "I could make them deterministic if that's desirable, but realistically these tests are already non-deterministic by virtue of being multithreaded. None of the uses of GetRand are particularly dangerous here, although perhaps they area a little slower than could be.",
      "created_at" : "2017-02-25T19:22:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282506083",
      "id" : 282506083,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-02-25T19:22:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282506083",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "I think that would be desirable, even if the multithreading makes it not 100%.",
      "created_at" : "2017-02-25T21:31:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282513878",
      "id" : 282513878,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-02-25T21:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282513878",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "body" : "ACK 96c7f2c",
      "created_at" : "2017-02-26T19:22:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282579755",
      "id" : 282579755,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
      "updated_at" : "2017-02-26T19:22:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282579755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/250224?v=3",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   }
]
