[
   {
      "body" : "Concept ACK on warning re: invalid version headers.",
      "created_at" : "2017-01-05T19:02:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#issuecomment-270728086",
      "id" : 270728086,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9443",
      "updated_at" : "2017-01-05T19:02:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/270728086",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r95077250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95077250"
         }
      },
      "body" : "knwo -> know",
      "commit_id" : "cded151650835585e9b7c61bbeff0ff447d94aa2",
      "created_at" : "2017-01-08T11:55:23Z",
      "diff_hunk" : "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+Test large work fork and large work invalid chain warning\n+'''\n+\n+BASIC_WARNING = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\"\n+INVALID_WARNING = \"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+FORK_WARNING = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+\n+class BaseNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.last_getdata = None\n+        self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n+        self.last_blockhash_announced = None\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        assert(wait_until(test_function, timeout=timeout))\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class ForkWarningTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n+        with open(self.alert_filename, 'w', encoding='utf8') as f:\n+            pass  # Just open then close to create zero-length file\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n+                                     [\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]))\n+        self.is_network_split = False\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count, node = 0):\n+        # Clear out last block announcement from each p2p listener\n+        self.nodes[node].generate(count)\n+        return int(self.nodes[node].getbestblockhash(), 16)\n+\n+    def run_test(self):\n+        self.test_node = TestNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=0))\n+        self.test_node.add_connection(connections[0])\n+        NetworkThread().start()\n+        self.test_node.wait_for_verack()\n+\n+        # Generate 10 blocks\n+        tip = self.mine_blocks(10)\n+        height = self.nodes[0].getblockcount()\n+        last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        forkbase = [];\n+        forkbase.append(self.nodes[0].getblock(self.nodes[0].getbestblockhash())['hash'])\n+        block_time = last_time + 1\n+        height += 1\n+\n+        print(\"Test 1: Invalid chain warning\")\n+        # Generate 1 block with valid header but invalid nLockTime coinbase tx\n+        new_block = create_block(tip, create_coinbase(height), block_time)\n+        new_block.vtx[0].nLockTime = 100\n+        new_block.vtx[0].vin[0].nSequence = 0\n+        new_block.vtx[0].rehash()\n+        new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+        new_block.rehash()\n+        new_block.solve()\n+        tip_invalid = new_block.sha256\n+        self.submit_header_and_block(new_block)\n+        assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+\n+        # Build 10 blocks on top of the invalid block (Invalid block 21)\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 5):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                assert_equal(warning, INVALID_WARNING)\n+\n+        print(\"Test 2: Stop invalid chain warning\")\n+        # Build 20 valid blocks on top of the best valid block (Block 11-30)\n+        height = self.nodes[0].getblockcount()\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 4):\n+                assert_equal(warning, INVALID_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 15 is found\n+\n+        print(\"Test 3: Large-work fork warning (header only)\")\n+        # Build 10 valid blocks on top of the block 20 to create a valid fork (Block 21a-30a)\n+        height = 20\n+        forkbase.append(self.nodes[0].getblockhash(height))\n+        tip = int(forkbase[1], 16)\n+        new_blocks = []\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header(new_block)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j >= 7):\n+                assert_equal(warning, FORK_WARNING) # Warning starts when block 28 is found\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        # Submit the blocks\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        print(\"Test 4: Large-work fork warning (orphaning the original chain)\")\n+        # Build 75 valid blocks on top of the block 30a to orphan the original chain (Block 31a-105a)\n+        for j in range(75): # To block 105\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j <= 70):\n+                assert_equal(warning, FORK_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 103a is found (72 blocks longer)\n+\n+        print(\"Test 5: Large-work fork warning (invalid block with header submitted only)\")\n+        # Build 90 invalid blocks on top of the block 95 to create an invalid fork (Invalid block 96-185)\n+        new_blocks = []\n+        forkbase.append(self.nodes[0].getblockhash(95))\n+        height = 95\n+        tip_invalid = int(forkbase[2], 16)\n+        for j in range(90):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.vtx[0].nLockTime = 96\n+            new_block.vtx[0].vin[0].nSequence = 0\n+            new_block.vtx[0].rehash()\n+            new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+            new_block.rehash()\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 7):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                # Warning starts when block 103 is found since it doesn't knwo the block is invalid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r95077250",
      "id" : 95077250,
      "original_commit_id" : "d4f94717cfdf1355ede4cd503f82e0474a4f59ad",
      "original_position" : 203,
      "path" : "qa/rpc-tests/forkwarning.py",
      "position" : null,
      "pull_request_review_id" : 15622753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443",
      "updated_at" : "2017-03-08T18:51:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95077250",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r95077264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95077264"
         }
      },
      "body" : "185a -> 185\r\nEdit: Or you are using the a character to distinguish between these two forks?",
      "commit_id" : "cded151650835585e9b7c61bbeff0ff447d94aa2",
      "created_at" : "2017-01-08T11:56:01Z",
      "diff_hunk" : "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+Test large work fork and large work invalid chain warning\n+'''\n+\n+BASIC_WARNING = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\"\n+INVALID_WARNING = \"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+FORK_WARNING = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+\n+class BaseNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.last_getdata = None\n+        self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n+        self.last_blockhash_announced = None\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        assert(wait_until(test_function, timeout=timeout))\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class ForkWarningTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n+        with open(self.alert_filename, 'w', encoding='utf8') as f:\n+            pass  # Just open then close to create zero-length file\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n+                                     [\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]))\n+        self.is_network_split = False\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count, node = 0):\n+        # Clear out last block announcement from each p2p listener\n+        self.nodes[node].generate(count)\n+        return int(self.nodes[node].getbestblockhash(), 16)\n+\n+    def run_test(self):\n+        self.test_node = TestNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=0))\n+        self.test_node.add_connection(connections[0])\n+        NetworkThread().start()\n+        self.test_node.wait_for_verack()\n+\n+        # Generate 10 blocks\n+        tip = self.mine_blocks(10)\n+        height = self.nodes[0].getblockcount()\n+        last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        forkbase = [];\n+        forkbase.append(self.nodes[0].getblock(self.nodes[0].getbestblockhash())['hash'])\n+        block_time = last_time + 1\n+        height += 1\n+\n+        print(\"Test 1: Invalid chain warning\")\n+        # Generate 1 block with valid header but invalid nLockTime coinbase tx\n+        new_block = create_block(tip, create_coinbase(height), block_time)\n+        new_block.vtx[0].nLockTime = 100\n+        new_block.vtx[0].vin[0].nSequence = 0\n+        new_block.vtx[0].rehash()\n+        new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+        new_block.rehash()\n+        new_block.solve()\n+        tip_invalid = new_block.sha256\n+        self.submit_header_and_block(new_block)\n+        assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+\n+        # Build 10 blocks on top of the invalid block (Invalid block 21)\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 5):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                assert_equal(warning, INVALID_WARNING)\n+\n+        print(\"Test 2: Stop invalid chain warning\")\n+        # Build 20 valid blocks on top of the best valid block (Block 11-30)\n+        height = self.nodes[0].getblockcount()\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 4):\n+                assert_equal(warning, INVALID_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 15 is found\n+\n+        print(\"Test 3: Large-work fork warning (header only)\")\n+        # Build 10 valid blocks on top of the block 20 to create a valid fork (Block 21a-30a)\n+        height = 20\n+        forkbase.append(self.nodes[0].getblockhash(height))\n+        tip = int(forkbase[1], 16)\n+        new_blocks = []\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header(new_block)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j >= 7):\n+                assert_equal(warning, FORK_WARNING) # Warning starts when block 28 is found\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        # Submit the blocks\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        print(\"Test 4: Large-work fork warning (orphaning the original chain)\")\n+        # Build 75 valid blocks on top of the block 30a to orphan the original chain (Block 31a-105a)\n+        for j in range(75): # To block 105\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j <= 70):\n+                assert_equal(warning, FORK_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 103a is found (72 blocks longer)\n+\n+        print(\"Test 5: Large-work fork warning (invalid block with header submitted only)\")\n+        # Build 90 invalid blocks on top of the block 95 to create an invalid fork (Invalid block 96-185)\n+        new_blocks = []\n+        forkbase.append(self.nodes[0].getblockhash(95))\n+        height = 95\n+        tip_invalid = int(forkbase[2], 16)\n+        for j in range(90):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.vtx[0].nLockTime = 96\n+            new_block.vtx[0].vin[0].nSequence = 0\n+            new_block.vtx[0].rehash()\n+            new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+            new_block.rehash()\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 7):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                # Warning starts when block 103 is found since it doesn't knwo the block is invalid\n+                assert_equal(warning, FORK_WARNING)\n+\n+        # Submit the blocks. Now it knows the first block is invalid, but it doesn't show invalid chain warning because\n+        # only the first block is marked BLOCK_FAILED_VALID\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        # Build to 185a to stop the warning",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r95077264",
      "id" : 95077264,
      "original_commit_id" : "d4f94717cfdf1355ede4cd503f82e0474a4f59ad",
      "original_position" : 213,
      "path" : "qa/rpc-tests/forkwarning.py",
      "position" : 213,
      "pull_request_review_id" : 15622760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443",
      "updated_at" : "2017-03-08T18:51:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95077264",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Concept ACK, but due to the non-localized changes required to core code my opinion is that it is too risky to include in 0.14, given that it just fixes the fork check. I'd prefer to merge this after the 0.14 split-off.",
      "created_at" : "2017-01-12T11:01:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#issuecomment-272135316",
      "id" : 272135316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9443",
      "updated_at" : "2017-01-12T11:01:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272135316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "To actually fix the warning system, we need to avoid banning peers that give us invalid blocks. Unfortunately, we currently also *rely* on that banning to ensure we have peers on the same network as us.",
      "created_at" : "2017-01-12T16:48:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#issuecomment-272216241",
      "id" : 272216241,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9443",
      "updated_at" : "2017-01-12T16:48:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272216241",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "@luke-jr we actually don't ban all types of invalid blocks. For example, violation of all softforks after P2SH are not banned. Also, with this PR it won't ban a node for sending header of a child of invalid block. As long as the PoW and timestamp are valid, the header chain will be followed.",
      "created_at" : "2017-01-12T18:59:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#issuecomment-272250212",
      "id" : 272250212,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9443",
      "updated_at" : "2017-01-12T18:59:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272250212",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r104992389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/104992389"
         }
      },
      "body" : "yes. Maybe I could make the comments clearer",
      "commit_id" : "cded151650835585e9b7c61bbeff0ff447d94aa2",
      "created_at" : "2017-03-08T18:50:34Z",
      "diff_hunk" : "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+Test large work fork and large work invalid chain warning\n+'''\n+\n+BASIC_WARNING = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\"\n+INVALID_WARNING = \"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+FORK_WARNING = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+\n+class BaseNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.last_getdata = None\n+        self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n+        self.last_blockhash_announced = None\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        assert(wait_until(test_function, timeout=timeout))\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class ForkWarningTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n+        with open(self.alert_filename, 'w', encoding='utf8') as f:\n+            pass  # Just open then close to create zero-length file\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n+                                     [\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]))\n+        self.is_network_split = False\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count, node = 0):\n+        # Clear out last block announcement from each p2p listener\n+        self.nodes[node].generate(count)\n+        return int(self.nodes[node].getbestblockhash(), 16)\n+\n+    def run_test(self):\n+        self.test_node = TestNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=0))\n+        self.test_node.add_connection(connections[0])\n+        NetworkThread().start()\n+        self.test_node.wait_for_verack()\n+\n+        # Generate 10 blocks\n+        tip = self.mine_blocks(10)\n+        height = self.nodes[0].getblockcount()\n+        last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        forkbase = [];\n+        forkbase.append(self.nodes[0].getblock(self.nodes[0].getbestblockhash())['hash'])\n+        block_time = last_time + 1\n+        height += 1\n+\n+        print(\"Test 1: Invalid chain warning\")\n+        # Generate 1 block with valid header but invalid nLockTime coinbase tx\n+        new_block = create_block(tip, create_coinbase(height), block_time)\n+        new_block.vtx[0].nLockTime = 100\n+        new_block.vtx[0].vin[0].nSequence = 0\n+        new_block.vtx[0].rehash()\n+        new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+        new_block.rehash()\n+        new_block.solve()\n+        tip_invalid = new_block.sha256\n+        self.submit_header_and_block(new_block)\n+        assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+\n+        # Build 10 blocks on top of the invalid block (Invalid block 21)\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 5):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                assert_equal(warning, INVALID_WARNING)\n+\n+        print(\"Test 2: Stop invalid chain warning\")\n+        # Build 20 valid blocks on top of the best valid block (Block 11-30)\n+        height = self.nodes[0].getblockcount()\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 4):\n+                assert_equal(warning, INVALID_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 15 is found\n+\n+        print(\"Test 3: Large-work fork warning (header only)\")\n+        # Build 10 valid blocks on top of the block 20 to create a valid fork (Block 21a-30a)\n+        height = 20\n+        forkbase.append(self.nodes[0].getblockhash(height))\n+        tip = int(forkbase[1], 16)\n+        new_blocks = []\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header(new_block)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j >= 7):\n+                assert_equal(warning, FORK_WARNING) # Warning starts when block 28 is found\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        # Submit the blocks\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        print(\"Test 4: Large-work fork warning (orphaning the original chain)\")\n+        # Build 75 valid blocks on top of the block 30a to orphan the original chain (Block 31a-105a)\n+        for j in range(75): # To block 105\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j <= 70):\n+                assert_equal(warning, FORK_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 103a is found (72 blocks longer)\n+\n+        print(\"Test 5: Large-work fork warning (invalid block with header submitted only)\")\n+        # Build 90 invalid blocks on top of the block 95 to create an invalid fork (Invalid block 96-185)\n+        new_blocks = []\n+        forkbase.append(self.nodes[0].getblockhash(95))\n+        height = 95\n+        tip_invalid = int(forkbase[2], 16)\n+        for j in range(90):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.vtx[0].nLockTime = 96\n+            new_block.vtx[0].vin[0].nSequence = 0\n+            new_block.vtx[0].rehash()\n+            new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+            new_block.rehash()\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 7):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                # Warning starts when block 103 is found since it doesn't knwo the block is invalid\n+                assert_equal(warning, FORK_WARNING)\n+\n+        # Submit the blocks. Now it knows the first block is invalid, but it doesn't show invalid chain warning because\n+        # only the first block is marked BLOCK_FAILED_VALID\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        # Build to 185a to stop the warning",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#discussion_r104992389",
      "id" : 104992389,
      "original_commit_id" : "d4f94717cfdf1355ede4cd503f82e0474a4f59ad",
      "original_position" : 213,
      "path" : "qa/rpc-tests/forkwarning.py",
      "position" : 213,
      "pull_request_review_id" : 25851607,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9443",
      "updated_at" : "2017-03-08T18:51:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/104992389",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "body" : "@luke-jr there's a middle ground perhaps. set a maximum number of peers on different chains. ",
      "created_at" : "2017-03-13T10:23:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9443#issuecomment-286068172",
      "id" : 286068172,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9443",
      "updated_at" : "2017-03-13T10:23:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/286068172",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   }
]
