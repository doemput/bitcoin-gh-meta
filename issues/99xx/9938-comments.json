[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105029718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105029718"
         }
      },
      "body" : "To make the test expose more parallellism, should probably use release/acquire here, no?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T21:39:33Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105029718",
      "id" : 105029718,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 41,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105029718",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030247"
         }
      },
      "body" : "nit: whitespace at end of line (and stray line, it looks like).",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T21:42:00Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030247",
      "id" : 105030247,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 99,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030963"
         }
      },
      "body" : "nit: something > 10 might test parallellism a bit more, no? (and in a few other places)",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T21:45:26Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030963",
      "id" : 105030963,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 227,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030963",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105031924"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105031924"
         }
      },
      "body" : "I think you meant to have an XOR here.",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T21:49:30Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105031924",
      "id" : 105031924,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 265,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105031924",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037465"
         }
      },
      "body" : "nit: maybe close the \"l\" scope after this line so that the try_lock()s happen without FrozenCleanupCheck::m?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:13:51Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE_EQUAL(UniqueCheck::results.size(), COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 0; i < 1000; ++i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037465",
      "id" : 105037465,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 363,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037465",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037514"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037514"
         }
      },
      "body" : "nit: whitespace at EOL here.",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:14:05Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE_EQUAL(UniqueCheck::results.size(), COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 0; i < 1000; ++i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037514",
      "id" : 105037514,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 340,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037514",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105041481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105041481"
         }
      },
      "body" : "I think you meant to remove/move this comment as well?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:32:02Z",
      "diff_hunk" : "@@ -41,7 +41,6 @@ class CCheckQueue\n \n     //! The queue of elements to be processed.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105041481",
      "id" : 105041481,
      "original_commit_id" : "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "original_position" : 2,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105041481",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105042472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105042472"
         }
      },
      "body" : "Nit: can these be private?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:36:28Z",
      "diff_hunk" : "@@ -145,18 +140,25 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n+    typename std::vector<T>::iterator check_mem;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105042472",
      "id" : 105042472,
      "original_commit_id" : "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "original_position" : 63,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105042472",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043019"
         }
      },
      "body" : "Can you add some documentation for Flush() (and how it interacts with the two versions of Add()) here?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:38:42Z",
      "diff_hunk" : "@@ -200,8 +205,27 @@ class CCheckQueueControl\n \n     void Add(std::vector<T>& vChecks)\n     {\n-        if (pqueue != NULL)\n-            pqueue->Add(vChecks);\n+        if (pqueue != NULL) {\n+            auto s = vChecks.size();\n+            for (T& x : vChecks) {\n+                check_mem.emplace_back();\n+                check_mem.back().swap(x);\n+            }\n+            pqueue->Add(s);\n+        }\n+    }\n+    template<typename ... Args>\n+    void Add(Args && ... args)\n+    {\n+        if (pqueue != NULL) {\n+            check_mem.emplace_back(std::forward<Args>(args)...);\n+        }\n+    }\n+    void Flush(size_t s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043019",
      "id" : 105043019,
      "original_commit_id" : "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "original_position" : 139,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043019",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043095"
         }
      },
      "body" : "nit: whitespace at EOL here.",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:39:00Z",
      "diff_hunk" : "@@ -145,18 +140,25 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n+    typename std::vector<T>::iterator check_mem;\n+    typename std::vector<T>::iterator check_mem_top;\n+    typename std::vector<T>::iterator check_mem_bottom;\n+    void Setup(typename std::vector<T>::iterator check_mem_in) ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043095",
      "id" : 105043095,
      "original_commit_id" : "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "original_position" : 66,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043095",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105044600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105044600"
         }
      },
      "body" : "Maybe ifdef hardware_destructive_interference_size use it?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:46:17Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105044600",
      "id" : 105044600,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 62,
      "path" : "src/checkqueue.h",
      "position" : 63,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105044600",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105046758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105046758"
         }
      },
      "body" : "Huh? Sure we can, we just cant decrement nAwake until we've swap()ed. I assume you had a previous version with an early termination for !fAllOk?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T22:57:40Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105046758",
      "id" : 105046758,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 169,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105046758",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105048119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105048119"
         }
      },
      "body" : "Looks like, in the current version, you can remove nBatchSize as well (though I'm surprised its not a performance gain to batch operations?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-08T23:05:01Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105048119",
      "id" : 105048119,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 53,
      "path" : "src/checkqueue.h",
      "position" : 54,
      "pull_request_review_id" : 25891086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105048119",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105072948"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105072948"
         }
      },
      "body" : "Yes, absolutely. I didn't change it to minimize changeset, but it no longer has a use.",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-09T02:08:18Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105072948",
      "id" : 105072948,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 53,
      "path" : "src/checkqueue.h",
      "position" : 54,
      "pull_request_review_id" : 25934746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105072948",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105073250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105073250"
         }
      },
      "body" : "Yes; you're correct. Earlier version was like this.\r\n\r\nAlso termination does still occur \"early\", all the actual checks are skipped (they are just stilled dequeued). I suppose I could make it abort (may actually be nice to check if it aborted before calling checkinputs... but maybe that's best for another PR).\r\n\r\nI'll refactor to something which converges more quickly on abort (e.g., setting !fMasterPresent && !fAllOk)",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-09T02:11:18Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105073250",
      "id" : 105073250,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 169,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 25935054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105073250",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105221818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105221818"
         }
      },
      "body" : "Its probably better to not have quick abort and have less between-thread contention, no?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-09T17:26:29Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105221818",
      "id" : 105221818,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 169,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 26090970,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105221818",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105235482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105235482"
         }
      },
      "body" : "I think the solution i came up with is pretty trivial (I'll push it later today).\r\n\r\n```c++\r\nfOk = fAllOk.load(std::memory_order_relaxed);\r\nif (fOk) {\r\n    T t();\r\n    pT->swap(t);\r\n} else {\r\n    fAllOk.store(false, std::memory_order_relaxed);\r\n    fMasterPresent = false;\r\n    // try to consume all values as quickly as possible\r\n    while (top_cache > bottom_cache &&\r\n                    !check_mem_bot.compare_exchange_weak( bottom_cache, top_cache)) {\r\n            top_cache = check_mem_top.load();\r\n    }\r\n}\r\n```\r\n\r\nEspecially since now, fAllOk is never written really now.\r\n\r\n",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-09T18:27:07Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105235482",
      "id" : 105235482,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 169,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 26105509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105235482",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105258806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105258806"
         }
      },
      "body" : "Looks like too just complexity? Just dont bother exiting early, we can take a performance hit of very little on an invalid block, I think. Just dont bother writing to fAllOk if fOk?",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-09T20:07:32Z",
      "diff_hunk" : "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105258806",
      "id" : 105258806,
      "original_commit_id" : "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "original_position" : 169,
      "path" : "src/checkqueue.h",
      "position" : null,
      "pull_request_review_id" : 26130203,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T17:41:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105258806",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r108241184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108241184"
         }
      },
      "body" : "Yes.",
      "commit_id" : "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "created_at" : "2017-03-27T18:15:36Z",
      "diff_hunk" : "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r108241184",
      "id" : 108241184,
      "original_commit_id" : "08e4e1ea89427a2594415d0b37011692a5109c39",
      "original_position" : 265,
      "path" : "src/test/checkqueue_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 29260495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
      "updated_at" : "2017-03-27T18:15:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108241184",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   }
]
