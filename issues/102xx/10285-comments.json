[
   {
      "body" : "Vague Concept ACK.",
      "created_at" : "2017-04-27T00:31:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#issuecomment-297578336",
      "id" : 297578336,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10285",
      "updated_at" : "2017-04-27T00:31:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/297578336",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "utACK, going to test this",
      "created_at" : "2017-05-02T12:32:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#issuecomment-298621881",
      "id" : 298621881,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10285",
      "updated_at" : "2017-05-02T12:32:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/298621881",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114333281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114333281"
         }
      },
      "body" : "Shouldnt this only be if !pszDest?",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T14:36:07Z",
      "diff_hunk" : "@@ -340,19 +340,29 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(const CAddress& addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114333281",
      "id" : 114333281,
      "original_commit_id" : "4044e8220dc44f2258cee3d6f00b61663dd95c54",
      "original_position" : 28,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114333281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114387767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114387767"
         }
      },
      "body" : "nit: Move this into the previous block, and maybe move the addrDest.IsValid() check into it as well. Then you can always require addrDest.IsValid() for non-named addresses as well, which seems reasonable.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T18:17:28Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114387767",
      "id" : 114387767,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114387767",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114390273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114390273"
         }
      },
      "body" : "Generally the point here is to have top-level ifs like if (strDest.empty()) and then put the logic inside of that, instead of repeated ifs for similar branches which are just confusing.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T18:28:10Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114390273",
      "id" : 114390273,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114390273",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114401222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114401222"
         }
      },
      "body" : "nit: needs a string change here for \\_\\_func__.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T19:15:54Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114401222",
      "id" : 114401222,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 33,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114401222",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114403174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114403174"
         }
      },
      "body" : "Not strictly your fault, but I think you're exposing a bug in Socks5 here - Socks5 fails to CloseSocket() prior to returning false in one place (Proxy username or password too long), so I think it'd be better to just CloseSocket here instead of further down to make it harder to miss such things.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T19:25:03Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n+\n+    // Create socket\n+    SOCKET hSocket = INVALID_SOCKET;\n+    if (proxy.IsValid()) {\n+        if (!CreateSocket(proxy.proxy, hSocket)) {\n+            return false;\n+        }\n+    } else {\n+        if (!CreateSocket(addrDest, hSocket)) {\n+            return false;\n+        }\n+    }\n+    if (!IsSelectableSocket(hSocket)) {\n+        LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n+        CloseSocket(hSocket);\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Connect\n+    bool connected = false;\n+    if (proxy.IsValid()) {\n+        if (!ConnectSocketDirectly(proxy.proxy, hSocket, nConnectTimeout)) {\n+            // This does not count as an addrman attempt, since the address was never actually tried.\n+            return false;\n+        }\n+        ProxyCredentials random_auth;\n+        const ProxyCredentials* proxy_auth = nullptr;\n+        if (proxy.randomize_credentials) {\n+            static std::atomic_int counter;\n+            random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n+            proxy_auth = &random_auth;\n+        }\n+        if (addrDest.IsValid()) {\n+            strDest = addrDest.ToStringIP();\n+            port = addrDest.GetPort();\n+        }\n+        connected = Socks5(strDest, (unsigned short)port, proxy_auth, hSocket);\n+    } else {\n+        connected = ConnectSocketDirectly(addrDest, hSocket, nConnectTimeout);\n     }\n \n-    return NULL;\n+    addrman.Attempt(addrDest, fCountFailure);\n+\n+    if (!connected) {\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114403174",
      "id" : 114403174,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 181,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114403174",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114408458"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114408458"
         }
      },
      "body" : "Oh, also think we need a CloseSocket here.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T19:49:33Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114408458",
      "id" : 114408458,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 33,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114408458",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114408569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114408569"
         }
      },
      "body" : "Need a CloseSocket here (but, really, lets just move all the CloseSockets up to OpenNetworkConnection post-CreateSocket instead of them being sprinkled all over everywhere?).",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T19:50:06Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n+    hSocketRet = hSocket;\n+    return true;\n+}\n+\n+bool ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocket, int nTimeout)\n+{\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114408569",
      "id" : 114408569,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 44,
      "path" : "src/netbase.cpp",
      "position" : 47,
      "pull_request_review_id" : 35790305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114408569",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114411229"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114411229"
         }
      },
      "body" : "I avoided coalescing on purpose. The current code does a bunch of steps at once, depending on what the input is. That's what I'm trying to undo here.\r\n\r\nThe previous block handles resolving, and will be moved out to a new function as a next step. By keeping the connection flow separated like this, it's trivial to factor out that way.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:02:40Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114411229",
      "id" : 114411229,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 35875038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114411229",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114411793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114411793"
         }
      },
      "body" : "yes, thanks. Will fix.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:05:34Z",
      "diff_hunk" : "@@ -340,19 +340,29 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(const CAddress& addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114411793",
      "id" : 114411793,
      "original_commit_id" : "4044e8220dc44f2258cee3d6f00b61663dd95c54",
      "original_position" : 28,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 35875713,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114411793",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412081"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412081"
         }
      },
      "body" : "Agreed.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:06:44Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n+\n+    // Create socket\n+    SOCKET hSocket = INVALID_SOCKET;\n+    if (proxy.IsValid()) {\n+        if (!CreateSocket(proxy.proxy, hSocket)) {\n+            return false;\n+        }\n+    } else {\n+        if (!CreateSocket(addrDest, hSocket)) {\n+            return false;\n+        }\n+    }\n+    if (!IsSelectableSocket(hSocket)) {\n+        LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n+        CloseSocket(hSocket);\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Connect\n+    bool connected = false;\n+    if (proxy.IsValid()) {\n+        if (!ConnectSocketDirectly(proxy.proxy, hSocket, nConnectTimeout)) {\n+            // This does not count as an addrman attempt, since the address was never actually tried.\n+            return false;\n+        }\n+        ProxyCredentials random_auth;\n+        const ProxyCredentials* proxy_auth = nullptr;\n+        if (proxy.randomize_credentials) {\n+            static std::atomic_int counter;\n+            random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n+            proxy_auth = &random_auth;\n+        }\n+        if (addrDest.IsValid()) {\n+            strDest = addrDest.ToStringIP();\n+            port = addrDest.GetPort();\n+        }\n+        connected = Socks5(strDest, (unsigned short)port, proxy_auth, hSocket);\n+    } else {\n+        connected = ConnectSocketDirectly(addrDest, hSocket, nConnectTimeout);\n     }\n \n-    return NULL;\n+    addrman.Attempt(addrDest, fCountFailure);\n+\n+    if (!connected) {\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412081",
      "id" : 114412081,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 181,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 35876035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412081",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412487"
         }
      },
      "body" : "Will fix __func__.\r\n\r\nSetSocketNonBlocking should take care of closing the socket, but an explicit one here wouldn't hurt either.\r\n\r\nCloseSocket is really annoying. I'll RAII it directly after this PR.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:08:38Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412487",
      "id" : 114412487,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 33,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 35876466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412487",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412799"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412799"
         }
      },
      "body" : "Ugh. I'll see how much work it would be to RAII it as part of this pull.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:10:12Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n+    hSocketRet = hSocket;\n+    return true;\n+}\n+\n+bool ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocket, int nTimeout)\n+{\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114412799",
      "id" : 114412799,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 44,
      "path" : "src/netbase.cpp",
      "position" : 47,
      "pull_request_review_id" : 35876847,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114412799",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114413522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114413522"
         }
      },
      "body" : "Ahh, OK, didnt realize that the next step would be to pull it out.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:13:39Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114413522",
      "id" : 114413522,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 35877610,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114413522",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114413576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114413576"
         }
      },
      "body" : "Good, CloseSocket were half the issues here :(",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-02T20:13:58Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114413576",
      "id" : 114413576,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 33,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 35877683,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T00:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114413576",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114534232"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114534232"
         }
      },
      "body" : "+1 for the SocketCloser",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-03T12:45:45Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n+\n+    // Create socket\n+    SOCKET hSocket = INVALID_SOCKET;\n+    if (proxy.IsValid()) {\n+        if (!CreateSocket(proxy.proxy, hSocket)) {\n+            return false;\n+        }\n+    } else {\n+        if (!CreateSocket(addrDest, hSocket)) {\n+            return false;\n+        }\n+    }\n+    if (!IsSelectableSocket(hSocket)) {\n+        LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n+        CloseSocket(hSocket);\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Connect\n+    bool connected = false;\n+    if (proxy.IsValid()) {\n+        if (!ConnectSocketDirectly(proxy.proxy, hSocket, nConnectTimeout)) {\n+            // This does not count as an addrman attempt, since the address was never actually tried.\n+            return false;\n+        }\n+        ProxyCredentials random_auth;\n+        const ProxyCredentials* proxy_auth = nullptr;\n+        if (proxy.randomize_credentials) {\n+            static std::atomic_int counter;\n+            random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n+            proxy_auth = &random_auth;\n+        }\n+        if (addrDest.IsValid()) {\n+            strDest = addrDest.ToStringIP();\n+            port = addrDest.GetPort();\n+        }\n+        connected = Socks5(strDest, (unsigned short)port, proxy_auth, hSocket);\n+    } else {\n+        connected = ConnectSocketDirectly(addrDest, hSocket, nConnectTimeout);\n     }\n \n-    return NULL;\n+    addrman.Attempt(addrDest, fCountFailure);\n+\n+    if (!connected) {\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r114534232",
      "id" : 114534232,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 181,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 36007394,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-03T12:45:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/114534232",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115071588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115071588"
         }
      },
      "body" : "It seems strange to create the CSocketCloser and then give it a reference to the socket - why not just have the CSocketCloser hold the SOCKET variable (publicly) and then set it to INVALID_SOCKET upon close/release (and return it from release) to make it feel more like a unique_ptr?",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-05T19:29:12Z",
      "diff_hunk" : "@@ -340,71 +340,160 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (!pszDest) {\n+        if (IsLocal(addrConnect) || FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Create socket and make sure that it is closed in the event of an error\n+    SOCKET hSocket = INVALID_SOCKET;\n+    CSocketCloser sockCloser(hSocket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115071588",
      "id" : 115071588,
      "original_commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "original_position" : 135,
      "path" : "src/net.cpp",
      "position" : 135,
      "pull_request_review_id" : 36590966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-05T19:29:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115071588",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115856249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115856249"
         }
      },
      "body" : "In commit \"net: pass a reference into ConnectNode and copy it there\" (82451074c2bb13dc35b41f1051ff6282ee0d3a6c)\r\n\r\nCorresponding change to net.h is missing so this commit doesn't compile.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T21:23:47Z",
      "diff_hunk" : "@@ -340,7 +340,7 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+CNode* CConnman::ConnectNode(const CAddress& addrConnect, const char *pszDest, bool fCountFailure)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115856249",
      "id" : 115856249,
      "original_commit_id" : "82451074c2bb13dc35b41f1051ff6282ee0d3a6c",
      "original_position" : 5,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115856249",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115858254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115858254"
         }
      },
      "body" : "Note: Fixed in 1d94e2ebe470cb8842223520a0c57513ca77e940.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T21:33:06Z",
      "diff_hunk" : "@@ -340,19 +340,29 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(const CAddress& addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115858254",
      "id" : 115858254,
      "original_commit_id" : "4044e8220dc44f2258cee3d6f00b61663dd95c54",
      "original_position" : 28,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115858254",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115859939"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115859939"
         }
      },
      "body" : "Isn't seems strange for `SetSocketNonBlocking` to try to destroy the socket if it doesn't succeed. Maybe consider removing `CloseSocket` calls from `SetSocketNonBlocking` after adding the RAII here.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T21:41:58Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115859939",
      "id" : 115859939,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 33,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115859939",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115860223"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115860223"
         }
      },
      "body" : "Note: fixed in 34133bd6659ed02002faad757da38562df0730ae.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T21:43:28Z",
      "diff_hunk" : "@@ -445,6 +439,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n+    hSocketRet = hSocket;\n+    return true;\n+}\n+\n+bool ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocket, int nTimeout)\n+{\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115860223",
      "id" : 115860223,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 44,
      "path" : "src/netbase.cpp",
      "position" : 47,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115860223",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115861480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115861480"
         }
      },
      "body" : "In commit \"net: split socket creation out of connection\"\r\n\r\nThis commit drops `static`, but the function isn't exposed publicly in a header until the next commit.\r\n\r\n",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T21:49:36Z",
      "diff_hunk" : "@@ -445,6 +445,22 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (!SetSocketNonBlocking(hSocket, true))\n         return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n+    hSocketRet = hSocket;\n+    return true;\n+}\n+\n+bool ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocket, int nTimeout)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115861480",
      "id" : 115861480,
      "original_commit_id" : "c0577133cb18c10cfe341d82a66e0f0c507ebb8d",
      "original_position" : 17,
      "path" : "src/netbase.cpp",
      "position" : 42,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115861480",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115868857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115868857"
         }
      },
      "body" : "> It seems strange to create the CSocketCloser and then give it a reference to the socket\r\n\r\nIt is strange, just like CloseSocket taking a reference is strange. But I'd think as long as one of these is taking a reference, the other probably should as well for consistency.\r\n\r\n",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T22:34:38Z",
      "diff_hunk" : "@@ -340,71 +340,160 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (!pszDest) {\n+        if (IsLocal(addrConnect) || FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Create socket and make sure that it is closed in the event of an error\n+    SOCKET hSocket = INVALID_SOCKET;\n+    CSocketCloser sockCloser(hSocket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115868857",
      "id" : 115868857,
      "original_commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "original_position" : 135,
      "path" : "src/net.cpp",
      "position" : 135,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115868857",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115870542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115870542"
         }
      },
      "body" : "> By keeping the connection flow separated like this, it's trivial to factor out that way.\r\n\r\nProbably there is something going over my head, but I don't understand the reasoning.\r\n\r\nCurrently this does:\r\n\r\n```\r\nif (condition) {\r\n  // bunch of code\r\n} else {\r\n  // other code\r\n}\r\nif (equivalent condition) {\r\n  // code that you want to factor out\r\n}\r\nif (equivalent condition) {\r\n  // more code that you want to factor out\r\n}\r\n```\r\n\r\nI don't see why it would be any harder to refactor later with:\r\n\r\n```\r\nif (condition) {\r\n  // bunch of code\r\n  // code that you want to factor out\r\n  // more code that you want to factor out\r\n} else {\r\n  // other code\r\n}\r\n```",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T22:46:03Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115870542",
      "id" : 115870542,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 37432810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T22:53:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115870542",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115878962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115878962"
         }
      },
      "body" : "I gave it a reference because several calls further down the chain set the value to -1. For example, if ConnectSocketDirectly() fails. If storing a value, CSocketCloser would attempt to close it again at destruction if we weren't careful about resetting it, which would defeat the point of using RAII.\r\n\r\nThe alternative would be to audit for CloseSocket()s (or make a full-blown RAII CSocket with Close() as a member), which would make for a much larger diff.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-10T23:51:47Z",
      "diff_hunk" : "@@ -340,71 +340,160 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (!pszDest) {\n+        if (IsLocal(addrConnect) || FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {\n+        // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+        // In that case, drop the connection that was just created, and return the existing CNode instead.\n+        // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+        // name catch this early.\n+        LOCK(cs_vNodes);\n+        CNode* pnode = FindNode((CService)addrDest);\n+        if (pnode)\n+        {\n+            pnode->MaybeSetAddrName(std::string(pszDest));\n+            LogPrintf(\"Failed to open new connection, already connected\\n\");\n+            return false;\n+        }\n+    }\n \n-        // Add node\n-        NodeId id = GetNewNodeId();\n-        uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->AddRef();\n+    // Configure proxy, if any. At this point, addrDest is resolved and valid unless we're connecting through\n+    // a proxy which will be handling the resolve.\n+    proxyType proxy;\n+    if (addrDest.IsValid()) {\n+        GetProxy(addrDest.GetNetwork(), proxy);\n+    } else if (!GetNameProxy(proxy)) {\n+        return false;\n+    }\n \n-        return pnode;\n-    } else if (!proxyConnectionFailed) {\n-        // If connecting to the node failed, and failure is not caused by a problem connecting to\n-        // the proxy, mark this as an attempt.\n-        addrman.Attempt(addrConnect, fCountFailure);\n+    // Create socket and make sure that it is closed in the event of an error\n+    SOCKET hSocket = INVALID_SOCKET;\n+    CSocketCloser sockCloser(hSocket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115878962",
      "id" : 115878962,
      "original_commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "original_position" : 135,
      "path" : "src/net.cpp",
      "position" : 135,
      "pull_request_review_id" : 37456993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-10T23:51:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115878962",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115904892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115904892"
         }
      },
      "body" : "While it may make sense to lump a few actions together if they meet the same conditions now because a connection is just one long synchronous operation, my intention is to clarify which conditions really need to be met at which stage, so that we can break that operation up into smaller asynchronous ones.\r\n\r\nSome of these tests (like whether or not we resolved successfully) will just move in an obvious way to callbacks, so I guess it makes sense to combine them here. Others though, will need to be re-checked on separate threads.\r\n\r\nI'll clarify this in the code by setting some variables rather than repeating conditions, so that it's more clear what the intent is.\r\n\r\nI'll rebase while I'm at it.",
      "commit_id" : "1d94e2ebe470cb8842223520a0c57513ca77e940",
      "created_at" : "2017-05-11T04:53:20Z",
      "diff_hunk" : "@@ -340,71 +340,161 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+// if successful, this moves the passed grant to the constructed node\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n {\n-    if (pszDest == NULL) {\n-        if (IsLocal(addrConnect))\n-            return NULL;\n+    //\n+    // Initiate outbound network connection\n+    //\n \n-        // Look for an existing connection\n-        CNode* pnode = FindNode((CService)addrConnect);\n-        if (pnode)\n-        {\n-            LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n-        }\n+    if (interruptNet) {\n+        return false;\n+    }\n+    if (!fNetworkActive) {\n+        return false;\n+    }\n+    if (IsLocal(addrConnect)) {\n+        return false;\n+    }\n+\n+    if (!pszDest) {\n+        if (FindNode((CNetAddr)addrConnect) || IsBanned(addrConnect) ||\n+            FindNode(addrConnect.ToStringIPPort()))\n+            return false;\n+    } else if (FindNode(std::string(pszDest))) {\n+        return false;\n     }\n \n     /// debug print\n     LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n-    // Connect\n-    SOCKET hSocket;\n-    bool proxyConnectionFailed = false;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort(), nConnectTimeout, &proxyConnectionFailed) :\n-                  ConnectSocket(addrConnect, hSocket, nConnectTimeout, &proxyConnectionFailed))\n-    {\n-        if (!IsSelectableSocket(hSocket)) {\n-            LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-            CloseSocket(hSocket);\n-            return NULL;\n+    std::string strDest;\n+    int port = Params().GetDefaultPort();\n+    CAddress addrDest;\n+\n+    // Check input.\n+    // If pszDest is set:\n+    // - It must contain parseable host, and optionally a port.\n+    // - If no port is supplied, the default is used.\n+    // Otherwise, addrDest must be valid.\n+    if (pszDest) {\n+        SplitHostPort(std::string(pszDest), port, strDest);\n+        if (strDest.empty()) {\n+            return false;\n+        }\n+    } else {\n+        addrDest = addrConnect;\n+        if (!addrDest.IsValid()) {\n+            return false;\n         }\n+    }\n \n-        if (pszDest && addrConnect.IsValid()) {\n-            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n-            LOCK(cs_vNodes);\n-            CNode* pnode = FindNode((CService)addrConnect);\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n-                CloseSocket(hSocket);\n-                LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+    if (!strDest.empty()) {\n+        // Resolve strDest, if set. Only actually perform a dns lookup if they're enabled\n+        // by the current settings. Note that if strDest is already an ip address, this will\n+        // succeed regardless of the lookup setting.\n+        std::vector<CService> addrResolved;\n+        if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+            if (addrResolved.size() > 0) {\n+                addrDest = CAddress(addrResolved[GetRand(addrResolved.size())], NODE_NONE);\n             }\n         }\n+    }\n \n-        addrman.Attempt(addrConnect, fCountFailure);\n+    if (!strDest.empty() && addrDest.IsValid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#discussion_r115904892",
      "id" : 115904892,
      "original_commit_id" : "235dc01fc0458abd4490d0602adc8c42fe81e8ff",
      "original_position" : 102,
      "path" : "src/net.cpp",
      "position" : 98,
      "pull_request_review_id" : 37483162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10285",
      "updated_at" : "2017-05-11T04:53:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/115904892",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Closing this for now. I'm working on getting this fully refactored with libevent instead.\r\n\r\nBreaking this out and serializing the logic was very helpful as an intermediary step, but I now agree that it doesn't make much sense to review/merge those changes alone.",
      "created_at" : "2017-05-18T01:30:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10285#issuecomment-302275523",
      "id" : 302275523,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10285",
      "updated_at" : "2017-05-18T01:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/302275523",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   }
]
