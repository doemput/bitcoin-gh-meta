[
   {
      "author_association" : "MEMBER",
      "body" : "Well there is already a recommend way to do this: use a block proposal.\r\n\r\nThe general limitation with a 'verifyrawtransaction' approach is that it doesn't let you test a graph of unconfirmed transactions, but a block proposal does.\r\n\r\nLooks like internally your rpc is doing more or less what a block proposal does, but handling more of the things around it. So perhaps it would be useful to do.\r\n\r\nIt could obviously be extended to accept an array of transactions to do the right thing with respect to multiple... but another open question is what about parents in the mempool. Right now your code will fail a transaction that spends the output of a mempool transaction.  Sometimes that would be desirable but I think often not. \r\n\r\n",
      "created_at" : "2017-08-31T04:25:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326186087",
      "id" : 326186087,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T04:25:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326186087",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Seems awfully inefficient to call CNB just to throw away the chosen transaction-set. Also, the block fees will be wrong. If you don't want to build a block from scratch, maybe abstract that out of CNB first (separate commit, same PR)?\r\n\r\n(To revise your PR, just use `git push --force` over the same branch.)",
      "created_at" : "2017-08-31T04:34:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326187120",
      "id" : 326187120,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T04:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326187120",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Got it, thanks for the feedback. I'll address these issues now",
      "created_at" : "2017-08-31T04:38:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326187563",
      "id" : 326187563,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T04:38:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326187563",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I agree with the general usefulness of a `verifyrawtransaction` RPC (especially one that takes a list of unconfirmed transactions, and ideally one that allows for checking based on inputs that may be in the mempool), but one issue with this block proposal approach is that you won't be testing against local policy, just the consensus rules.  So be aware that a True result here won't necessarily mean that the node would accept the transactions and relay them.",
      "created_at" : "2017-08-31T14:25:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326311867",
      "id" : 326311867,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T14:25:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326311867",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, but as others have said, there are other things to consider when verifying a transaction that are not done here. Those need to be documented.",
      "created_at" : "2017-08-31T14:51:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326320240",
      "id" : 326320240,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T14:51:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326320240",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Seems related to https://github.com/bitcoin/bitcoin/pull/7552",
      "created_at" : "2017-08-31T21:17:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326423037",
      "id" : 326423037,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-08-31T21:17:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326423037",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks much for that link @jtimon, somehow I missed that.\r\n\r\nIt seems like everyone agrees that there is the potential for some useful functionality here, there's just some uncertainty in what exactly the API for this should look like. After reading https://github.com/bitcoin/bitcoin/pull/7552, it seems like this uncertainty is largely what has kept `verifyrawtransaction` functionality from being included in the past.\r\n\r\nWhat if `verifyrawtransaction` became `verifyrawtransactions` as in https://github.com/bitcoin/bitcoin/pull/7552, and took an argument as follows:\r\n\r\n```\r\n{\r\n    \"transactions\": [ \"hex_tx0\", \"hex_tx1\", ... ],\r\n    \"use_local_policy\": true // default true\r\n}\r\n```\r\n\r\nI think this achieves all of the behavior we want; users can set \"use_local_policy\" to false if they only want to check consensus rules. I will also make it handle ancestors in the mempool correctly as brought up by @gmaxwell, unless that should be another flag?\r\n\r\nI think I can do a lot of this with a minor refactor of `AcceptToMemoryPoolWorker`.\r\n\r\nDoes this sound good?",
      "created_at" : "2017-09-01T00:44:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-326457030",
      "id" : 326457030,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-09-01T03:57:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326457030",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "~~Use `signrawtransaction` to verify a transaction?\r\nIf you have unknown/chained utxos...  you can provide them.\r\nIf you wanted to check against local policy,  maybe this PR could instead add that as an optional flag\r\nIt doesn't require wallet support,  but if you have wallet support enabled, you should otherwise compare the `hex` returned to enforce it wasn't modified.~~\r\n\r\nAs discussed on IRC,  `signrawtransaction` only verifies transaction scripts,  not the validity of the transaction otherwise.\r\nE.g input value >= output value,  output value > MAX_MONEY, etc.\r\n\r\nconcept ACK.\r\nIMHO the API could mimic `signrawtransaction` (minus the private keys) with some configuration options as to policy/mempool and other checks.\r\n\r\n```\r\nverifyrawtransactions [txhex, ...] [txos] {\r\n  allow_missing_inputs: false,\r\n  allow_spent_inputs: false, // allow_mempool_conflicts?\r\n  local_policy: true,\r\n  ... etc\r\n}\r\n```",
      "created_at" : "2017-09-06T05:36:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-327379774",
      "id" : 327379774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-09-06T06:23:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327379774",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/413395?v=4",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137249067"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137249067"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If ATMP fails for a transaction due to missing inputs, then almost none of the policy checks will be evaluated for the transaction, because that's one of the first things we (must) do -- for instance you can't check the feerate of the transaction without having the inputs available.",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-06T12:14:47Z",
      "diff_hunk" : "@@ -887,6 +889,231 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue verifyrawtransactions(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"verifyrawtransactions [\\\"hex_tx\\\", ...] ( use_local_rules )\\n\"\n+            \"\\nTests the validity of a series of raw transactions (serialized, hex-encoded), without submitting them.\\n\"\n+            \"The transactions can be dependent on one another, or have ancestors residing in the mempool. The\\n\"\n+            \"use_local_rules flag determines if the transactions should be validated against the node's local\\n\"\n+            \"policies. Setting it to false effectively checks if this node would reject the block containing\\n\"\n+            \"these transactions and their mempool resident ancestors, should they be mined.\\n\"\n+            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"transactions\\\"    (array) A json array of hex encoded transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hex_tx\\\"       (string) A hex encoded transaction\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"2. \\\"use_local_rules\\\" (boolean, optional, default=true) If enabled, checks transactions against local policies\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"valid\\\"  : true|false,    (string) The transaction id\\n\"\n+            \"  \\\"reason\\\" : \\\"reason\\\",      (string) Description of why verification failed or succeeded\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"Create a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nVerify the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\")\n+        );\n+\n+    LOCK(cs_main);\n+    LOCK(mempool.cs);\n+\n+    // Type check arguments\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+    UniValue hex_transactions = request.params[0].get_array();\n+\n+    // { valid true/false , reason str }\n+    UniValue result(UniValue::VOBJ);\n+\n+    bool use_local_policy = request.params[1].isNull() || request.params[1].get_bool();\n+\n+    // Parse all of the transactions (map is txhash -> tx).\n+    std::map<uint256, CTransactionRef> transactions;\n+    std::map<uint256, CTransactionRef>::iterator txit;\n+    for (unsigned int idx = 0; idx < hex_transactions.size(); idx++) {\n+        const UniValue& hex_tx = hex_transactions[idx];\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, hex_tx.get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+        }\n+        CTransactionRef ref = MakeTransactionRef(std::move(mtx));\n+        transactions.insert(std::pair<uint256, CTransactionRef>(ref->GetHash(), ref));\n+    }\n+\n+    // Find the ancestors of all of the transactions, including ones in mempool\n+    std::map<uint256, CTransactionRef> ancestors;\n+    for (auto const& hash_tx : transactions) {\n+        CTransactionRef tx = hash_tx.second;\n+        for (const CTxIn& txin : tx->vin) {\n+            // Check the mempool\n+            const uint256& hash = txin.prevout.hash;\n+            CTxMemPool::txiter it = mempool.mapTx.find(hash);\n+\n+            // Ancestor not in mempool\n+            if (it == mempool.mapTx.end()) {\n+                continue;\n+            }\n+\n+            // Add the ancestor to the map\n+            ancestors.insert(std::pair<uint256, CTransactionRef>(hash, MakeTransactionRef(it->GetTx())));\n+\n+            // CalculateMemPoolAncestors only works on mempool entries, which is why we are iterating over vin\n+            CTxMemPool::setEntries tx_ancestors;\n+            uint64_t no_limit = std::numeric_limits<uint64_t>::max();\n+            std::string dummy;\n+            mempool.CalculateMemPoolAncestors(*it, tx_ancestors, no_limit, no_limit, no_limit, no_limit, dummy, false);\n+\n+            // Insert ancestors' ancestors into the map\n+            for (CTxMemPool::txiter ancestor_it : tx_ancestors) {\n+                CTransactionRef atf = MakeTransactionRef(ancestor_it->GetTx());\n+                ancestors.insert(std::pair<uint256, CTransactionRef>(atf->GetHash(), atf));\n+            }\n+        }\n+    }\n+\n+    // Merge the ancestors into the transactions\n+    transactions.insert(ancestors.begin(), ancestors.end());\n+\n+    // Now, come up with a valid topological sort over the transactions\n+    std::vector<CTransactionRef> ordered_tx;\n+    std::vector<CTransactionRef> block_tx;\n+\n+    // Iterate over the transactions, removing all of those with no\n+    // dependencies in the list each time. Technically, this is worst\n+    // case n^2 since the transactions could be dependent in reverse\n+    // order. In practice, I think this is better than e.g. implementing\n+    // an asymptotically efficient topological sort since input sizes will\n+    // likely be small and this is way easier to implement.\n+    while (transactions.size() > 0) {\n+        auto hash_tx = transactions.begin();\n+        bool found_independent = false;\n+        while (hash_tx != transactions.end()) {\n+            CTransactionRef tx = hash_tx->second;\n+            bool is_independent = true;\n+            for (const CTxIn& txin : tx->vin) {\n+                txit = transactions.find(txin.prevout.hash);\n+                if (txit != transactions.end()) {\n+                    is_independent = false;\n+                    break;\n+                }\n+            }\n+            if (is_independent) {\n+                found_independent = true;\n+                // Don't insert mempool ancestors\n+                if (ancestors.find(hash_tx->first) == ancestors.end()) {\n+                    ordered_tx.push_back(tx);\n+                }\n+                block_tx.push_back(tx);\n+                hash_tx = transactions.erase(hash_tx);\n+            } else {\n+                hash_tx++;\n+            }\n+        }\n+        if (found_independent) {\n+            continue;\n+        }\n+        // We got all the way through without finding an independent tx\n+        result.push_back(Pair(\"valid\",  false));\n+        result.push_back(Pair(\"reason\", \"circular transaction dependency\"));\n+        return result;\n+    }\n+\n+    // Should we check against our local policy, or just consensus rules?\n+    if (use_local_policy) {\n+        // For each input transaction\n+        for (auto const& tx : ordered_tx) {\n+            const uint256& hash = tx->GetHash();\n+            CCoinsViewCache& view = *pcoinsTip;\n+\n+            // Fail fast if we have an unspent output from this transaction\n+            // already in our wallet, which indicates right away that this is a\n+            // duplicate tx (copied from sendrawtransaction)\n+            bool have_chain = false;\n+            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n+                const Coin& existing_coin = view.AccessCoin(COutPoint(hash, o));\n+                have_chain = !existing_coin.IsSpent();\n+            }\n+\n+            // Check if transaction already exists in mempool\n+            bool have_mempool = mempool.exists(hash);\n+\n+            if (have_chain) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n+                return result;\n+            }\n+\n+            if (have_mempool) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n+                return result;\n+            }\n+\n+            // If we are reasonably confident that this transaction is not a\n+            // duplicate, do an AcceptToMemoryPool dry run\n+            CValidationState state;\n+            bool missing_inputs;\n+\n+            // Call AcceptToMemoryPool with the dryrun flag set\n+            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n+                if (state.IsInvalid()) {\n+                    result.push_back(Pair(\"valid\",  false));\n+                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+                    return result;\n+                } else if (missing_inputs) {\n+                    // We want to ignore the \"missing inputs\" case here, since the input\n+                    // may actually be in the mempool. If the input is truly missing, we\n+                    // will find out later after the ancestor and consensus check.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137249067",
      "id" : 137249067,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 196,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 196,
      "pull_request_review_id" : 60889639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-06T12:14:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137249067",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137253836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137253836"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually on further review, it looks like you've added these \"dry run\" transactions to the mempool, so now I think if ATMP returns \"missing inputs\", that should reflect an actual failure?  Is there a case where that doesn't hold?",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-06T12:37:16Z",
      "diff_hunk" : "@@ -887,6 +889,231 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue verifyrawtransactions(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"verifyrawtransactions [\\\"hex_tx\\\", ...] ( use_local_rules )\\n\"\n+            \"\\nTests the validity of a series of raw transactions (serialized, hex-encoded), without submitting them.\\n\"\n+            \"The transactions can be dependent on one another, or have ancestors residing in the mempool. The\\n\"\n+            \"use_local_rules flag determines if the transactions should be validated against the node's local\\n\"\n+            \"policies. Setting it to false effectively checks if this node would reject the block containing\\n\"\n+            \"these transactions and their mempool resident ancestors, should they be mined.\\n\"\n+            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"transactions\\\"    (array) A json array of hex encoded transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hex_tx\\\"       (string) A hex encoded transaction\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"2. \\\"use_local_rules\\\" (boolean, optional, default=true) If enabled, checks transactions against local policies\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"valid\\\"  : true|false,    (string) The transaction id\\n\"\n+            \"  \\\"reason\\\" : \\\"reason\\\",      (string) Description of why verification failed or succeeded\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"Create a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nVerify the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\")\n+        );\n+\n+    LOCK(cs_main);\n+    LOCK(mempool.cs);\n+\n+    // Type check arguments\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+    UniValue hex_transactions = request.params[0].get_array();\n+\n+    // { valid true/false , reason str }\n+    UniValue result(UniValue::VOBJ);\n+\n+    bool use_local_policy = request.params[1].isNull() || request.params[1].get_bool();\n+\n+    // Parse all of the transactions (map is txhash -> tx).\n+    std::map<uint256, CTransactionRef> transactions;\n+    std::map<uint256, CTransactionRef>::iterator txit;\n+    for (unsigned int idx = 0; idx < hex_transactions.size(); idx++) {\n+        const UniValue& hex_tx = hex_transactions[idx];\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, hex_tx.get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+        }\n+        CTransactionRef ref = MakeTransactionRef(std::move(mtx));\n+        transactions.insert(std::pair<uint256, CTransactionRef>(ref->GetHash(), ref));\n+    }\n+\n+    // Find the ancestors of all of the transactions, including ones in mempool\n+    std::map<uint256, CTransactionRef> ancestors;\n+    for (auto const& hash_tx : transactions) {\n+        CTransactionRef tx = hash_tx.second;\n+        for (const CTxIn& txin : tx->vin) {\n+            // Check the mempool\n+            const uint256& hash = txin.prevout.hash;\n+            CTxMemPool::txiter it = mempool.mapTx.find(hash);\n+\n+            // Ancestor not in mempool\n+            if (it == mempool.mapTx.end()) {\n+                continue;\n+            }\n+\n+            // Add the ancestor to the map\n+            ancestors.insert(std::pair<uint256, CTransactionRef>(hash, MakeTransactionRef(it->GetTx())));\n+\n+            // CalculateMemPoolAncestors only works on mempool entries, which is why we are iterating over vin\n+            CTxMemPool::setEntries tx_ancestors;\n+            uint64_t no_limit = std::numeric_limits<uint64_t>::max();\n+            std::string dummy;\n+            mempool.CalculateMemPoolAncestors(*it, tx_ancestors, no_limit, no_limit, no_limit, no_limit, dummy, false);\n+\n+            // Insert ancestors' ancestors into the map\n+            for (CTxMemPool::txiter ancestor_it : tx_ancestors) {\n+                CTransactionRef atf = MakeTransactionRef(ancestor_it->GetTx());\n+                ancestors.insert(std::pair<uint256, CTransactionRef>(atf->GetHash(), atf));\n+            }\n+        }\n+    }\n+\n+    // Merge the ancestors into the transactions\n+    transactions.insert(ancestors.begin(), ancestors.end());\n+\n+    // Now, come up with a valid topological sort over the transactions\n+    std::vector<CTransactionRef> ordered_tx;\n+    std::vector<CTransactionRef> block_tx;\n+\n+    // Iterate over the transactions, removing all of those with no\n+    // dependencies in the list each time. Technically, this is worst\n+    // case n^2 since the transactions could be dependent in reverse\n+    // order. In practice, I think this is better than e.g. implementing\n+    // an asymptotically efficient topological sort since input sizes will\n+    // likely be small and this is way easier to implement.\n+    while (transactions.size() > 0) {\n+        auto hash_tx = transactions.begin();\n+        bool found_independent = false;\n+        while (hash_tx != transactions.end()) {\n+            CTransactionRef tx = hash_tx->second;\n+            bool is_independent = true;\n+            for (const CTxIn& txin : tx->vin) {\n+                txit = transactions.find(txin.prevout.hash);\n+                if (txit != transactions.end()) {\n+                    is_independent = false;\n+                    break;\n+                }\n+            }\n+            if (is_independent) {\n+                found_independent = true;\n+                // Don't insert mempool ancestors\n+                if (ancestors.find(hash_tx->first) == ancestors.end()) {\n+                    ordered_tx.push_back(tx);\n+                }\n+                block_tx.push_back(tx);\n+                hash_tx = transactions.erase(hash_tx);\n+            } else {\n+                hash_tx++;\n+            }\n+        }\n+        if (found_independent) {\n+            continue;\n+        }\n+        // We got all the way through without finding an independent tx\n+        result.push_back(Pair(\"valid\",  false));\n+        result.push_back(Pair(\"reason\", \"circular transaction dependency\"));\n+        return result;\n+    }\n+\n+    // Should we check against our local policy, or just consensus rules?\n+    if (use_local_policy) {\n+        // For each input transaction\n+        for (auto const& tx : ordered_tx) {\n+            const uint256& hash = tx->GetHash();\n+            CCoinsViewCache& view = *pcoinsTip;\n+\n+            // Fail fast if we have an unspent output from this transaction\n+            // already in our wallet, which indicates right away that this is a\n+            // duplicate tx (copied from sendrawtransaction)\n+            bool have_chain = false;\n+            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n+                const Coin& existing_coin = view.AccessCoin(COutPoint(hash, o));\n+                have_chain = !existing_coin.IsSpent();\n+            }\n+\n+            // Check if transaction already exists in mempool\n+            bool have_mempool = mempool.exists(hash);\n+\n+            if (have_chain) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n+                return result;\n+            }\n+\n+            if (have_mempool) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n+                return result;\n+            }\n+\n+            // If we are reasonably confident that this transaction is not a\n+            // duplicate, do an AcceptToMemoryPool dry run\n+            CValidationState state;\n+            bool missing_inputs;\n+\n+            // Call AcceptToMemoryPool with the dryrun flag set\n+            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n+                if (state.IsInvalid()) {\n+                    result.push_back(Pair(\"valid\",  false));\n+                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+                    return result;\n+                } else if (missing_inputs) {\n+                    // We want to ignore the \"missing inputs\" case here, since the input\n+                    // may actually be in the mempool. If the input is truly missing, we\n+                    // will find out later after the ancestor and consensus check.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137253836",
      "id" : 137253836,
      "in_reply_to_id" : 137249067,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 196,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 196,
      "pull_request_review_id" : 60894895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-06T12:37:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137253836",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@justicz Thanks for working on this.  I think there's still work to be done here, but this seems like a promising direction.\r\n\r\nRather than add the `dryRunMap` to the mempool, though, I think it'd be cleaner if we instead just added a caching layer in front of the mempool, which holds these dry run transactions.  ATMPWorker already takes a mempool as an argument, so I think it'd be straightforward to abstract the mempool interface away (and I guess clean up the mempool interface so that callers aren't grabbing at internals), and then pass in a cache that holds dry run transactions in it, as well as transactions that get evicted from the mempool (eg due to RBF).  Then I think we could ensure that the mempool itself is a const object in this context that is clearly unaffected, with all changes happening only in the cache.\r\n\r\nIf we can achieve that, that would make the review and maintenance burden of this feature pretty minimal, which I think would be awesome.",
      "created_at" : "2017-09-06T12:45:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-327471905",
      "id" : 327471905,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-09-06T12:45:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327471905",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137255837"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137255837"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The `NotifyEntryAdded` callback a few lines up shouldn't trigger for dry run transactions.",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-06T12:46:16Z",
      "diff_hunk" : "@@ -357,13 +357,19 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate, bool dryRun)\n {\n     NotifyEntryAdded(entry.GetSharedTx());\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137255837",
      "id" : 137255837,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 12,
      "path" : "src/txmempool.cpp",
      "position" : 12,
      "pull_request_review_id" : 60897178,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-06T12:46:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137255837",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137268497"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137268497"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Since you only are removing conflicts in non-dryrun situations, doesn't that mean that someone calling verifyrawtransactions with a pair of tx's, one of which would replace existing transactions, and one of which depends on an existing transaction, would potentially succeed?  Yet when actually trying to send, the second would necessarily fail.",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-06T13:36:03Z",
      "diff_hunk" : "@@ -839,48 +839,59 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n         }\n \n-        // Remove conflicting transactions from the mempool\n-        for (const CTxMemPool::txiter it : allConflicting)\n-        {\n-            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    it->GetTx().GetHash().ToString(),\n-                    hash.ToString(),\n-                    FormatMoney(nModifiedFees - nConflictingFees),\n-                    (int)nSize - (int)nConflictingSize);\n-            if (plTxnReplaced)\n-                plTxnReplaced->push_back(it->GetSharedTx());\n+        if (!fDryRun) {\n+            // Remove conflicting transactions from the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137268497",
      "id" : 137268497,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 33,
      "path" : "src/validation.cpp",
      "position" : 33,
      "pull_request_review_id" : 60911683,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-06T13:36:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137268497",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks for the comments @sdaftuar! I think I agree with all of the points you made and will work on separating things out of the mempool more cleanly.",
      "created_at" : "2017-09-07T00:46:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-327650579",
      "id" : 327650579,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-09-07T00:46:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327650579",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424701"
         }
      },
      "author_association" : "NONE",
      "body" : "Yeah -- this code is leftover from before I figured out the issue you mentioned in your first comment. I was working on getting rid of this when you left your review Ã°ÂÂÂ ",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-07T00:48:11Z",
      "diff_hunk" : "@@ -887,6 +889,231 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue verifyrawtransactions(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"verifyrawtransactions [\\\"hex_tx\\\", ...] ( use_local_rules )\\n\"\n+            \"\\nTests the validity of a series of raw transactions (serialized, hex-encoded), without submitting them.\\n\"\n+            \"The transactions can be dependent on one another, or have ancestors residing in the mempool. The\\n\"\n+            \"use_local_rules flag determines if the transactions should be validated against the node's local\\n\"\n+            \"policies. Setting it to false effectively checks if this node would reject the block containing\\n\"\n+            \"these transactions and their mempool resident ancestors, should they be mined.\\n\"\n+            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"transactions\\\"    (array) A json array of hex encoded transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hex_tx\\\"       (string) A hex encoded transaction\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"2. \\\"use_local_rules\\\" (boolean, optional, default=true) If enabled, checks transactions against local policies\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"valid\\\"  : true|false,    (string) The transaction id\\n\"\n+            \"  \\\"reason\\\" : \\\"reason\\\",      (string) Description of why verification failed or succeeded\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"Create a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nVerify the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\")\n+        );\n+\n+    LOCK(cs_main);\n+    LOCK(mempool.cs);\n+\n+    // Type check arguments\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+    UniValue hex_transactions = request.params[0].get_array();\n+\n+    // { valid true/false , reason str }\n+    UniValue result(UniValue::VOBJ);\n+\n+    bool use_local_policy = request.params[1].isNull() || request.params[1].get_bool();\n+\n+    // Parse all of the transactions (map is txhash -> tx).\n+    std::map<uint256, CTransactionRef> transactions;\n+    std::map<uint256, CTransactionRef>::iterator txit;\n+    for (unsigned int idx = 0; idx < hex_transactions.size(); idx++) {\n+        const UniValue& hex_tx = hex_transactions[idx];\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, hex_tx.get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+        }\n+        CTransactionRef ref = MakeTransactionRef(std::move(mtx));\n+        transactions.insert(std::pair<uint256, CTransactionRef>(ref->GetHash(), ref));\n+    }\n+\n+    // Find the ancestors of all of the transactions, including ones in mempool\n+    std::map<uint256, CTransactionRef> ancestors;\n+    for (auto const& hash_tx : transactions) {\n+        CTransactionRef tx = hash_tx.second;\n+        for (const CTxIn& txin : tx->vin) {\n+            // Check the mempool\n+            const uint256& hash = txin.prevout.hash;\n+            CTxMemPool::txiter it = mempool.mapTx.find(hash);\n+\n+            // Ancestor not in mempool\n+            if (it == mempool.mapTx.end()) {\n+                continue;\n+            }\n+\n+            // Add the ancestor to the map\n+            ancestors.insert(std::pair<uint256, CTransactionRef>(hash, MakeTransactionRef(it->GetTx())));\n+\n+            // CalculateMemPoolAncestors only works on mempool entries, which is why we are iterating over vin\n+            CTxMemPool::setEntries tx_ancestors;\n+            uint64_t no_limit = std::numeric_limits<uint64_t>::max();\n+            std::string dummy;\n+            mempool.CalculateMemPoolAncestors(*it, tx_ancestors, no_limit, no_limit, no_limit, no_limit, dummy, false);\n+\n+            // Insert ancestors' ancestors into the map\n+            for (CTxMemPool::txiter ancestor_it : tx_ancestors) {\n+                CTransactionRef atf = MakeTransactionRef(ancestor_it->GetTx());\n+                ancestors.insert(std::pair<uint256, CTransactionRef>(atf->GetHash(), atf));\n+            }\n+        }\n+    }\n+\n+    // Merge the ancestors into the transactions\n+    transactions.insert(ancestors.begin(), ancestors.end());\n+\n+    // Now, come up with a valid topological sort over the transactions\n+    std::vector<CTransactionRef> ordered_tx;\n+    std::vector<CTransactionRef> block_tx;\n+\n+    // Iterate over the transactions, removing all of those with no\n+    // dependencies in the list each time. Technically, this is worst\n+    // case n^2 since the transactions could be dependent in reverse\n+    // order. In practice, I think this is better than e.g. implementing\n+    // an asymptotically efficient topological sort since input sizes will\n+    // likely be small and this is way easier to implement.\n+    while (transactions.size() > 0) {\n+        auto hash_tx = transactions.begin();\n+        bool found_independent = false;\n+        while (hash_tx != transactions.end()) {\n+            CTransactionRef tx = hash_tx->second;\n+            bool is_independent = true;\n+            for (const CTxIn& txin : tx->vin) {\n+                txit = transactions.find(txin.prevout.hash);\n+                if (txit != transactions.end()) {\n+                    is_independent = false;\n+                    break;\n+                }\n+            }\n+            if (is_independent) {\n+                found_independent = true;\n+                // Don't insert mempool ancestors\n+                if (ancestors.find(hash_tx->first) == ancestors.end()) {\n+                    ordered_tx.push_back(tx);\n+                }\n+                block_tx.push_back(tx);\n+                hash_tx = transactions.erase(hash_tx);\n+            } else {\n+                hash_tx++;\n+            }\n+        }\n+        if (found_independent) {\n+            continue;\n+        }\n+        // We got all the way through without finding an independent tx\n+        result.push_back(Pair(\"valid\",  false));\n+        result.push_back(Pair(\"reason\", \"circular transaction dependency\"));\n+        return result;\n+    }\n+\n+    // Should we check against our local policy, or just consensus rules?\n+    if (use_local_policy) {\n+        // For each input transaction\n+        for (auto const& tx : ordered_tx) {\n+            const uint256& hash = tx->GetHash();\n+            CCoinsViewCache& view = *pcoinsTip;\n+\n+            // Fail fast if we have an unspent output from this transaction\n+            // already in our wallet, which indicates right away that this is a\n+            // duplicate tx (copied from sendrawtransaction)\n+            bool have_chain = false;\n+            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n+                const Coin& existing_coin = view.AccessCoin(COutPoint(hash, o));\n+                have_chain = !existing_coin.IsSpent();\n+            }\n+\n+            // Check if transaction already exists in mempool\n+            bool have_mempool = mempool.exists(hash);\n+\n+            if (have_chain) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n+                return result;\n+            }\n+\n+            if (have_mempool) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n+                return result;\n+            }\n+\n+            // If we are reasonably confident that this transaction is not a\n+            // duplicate, do an AcceptToMemoryPool dry run\n+            CValidationState state;\n+            bool missing_inputs;\n+\n+            // Call AcceptToMemoryPool with the dryrun flag set\n+            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n+                if (state.IsInvalid()) {\n+                    result.push_back(Pair(\"valid\",  false));\n+                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+                    return result;\n+                } else if (missing_inputs) {\n+                    // We want to ignore the \"missing inputs\" case here, since the input\n+                    // may actually be in the mempool. If the input is truly missing, we\n+                    // will find out later after the ancestor and consensus check.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424701",
      "id" : 137424701,
      "in_reply_to_id" : 137249067,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 196,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 196,
      "pull_request_review_id" : 61089420,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-07T00:48:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424701",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424892"
         }
      },
      "author_association" : "NONE",
      "body" : "I think you're right. I'll fix this",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-07T00:49:51Z",
      "diff_hunk" : "@@ -839,48 +839,59 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n         }\n \n-        // Remove conflicting transactions from the mempool\n-        for (const CTxMemPool::txiter it : allConflicting)\n-        {\n-            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    it->GetTx().GetHash().ToString(),\n-                    hash.ToString(),\n-                    FormatMoney(nModifiedFees - nConflictingFees),\n-                    (int)nSize - (int)nConflictingSize);\n-            if (plTxnReplaced)\n-                plTxnReplaced->push_back(it->GetSharedTx());\n+        if (!fDryRun) {\n+            // Remove conflicting transactions from the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424892",
      "id" : 137424892,
      "in_reply_to_id" : 137268497,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 33,
      "path" : "src/validation.cpp",
      "position" : 33,
      "pull_request_review_id" : 61089634,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-07T00:49:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424892",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424904"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424904"
         }
      },
      "author_association" : "NONE",
      "body" : "Ã°ÂÂÂ ",
      "commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "created_at" : "2017-09-07T00:50:00Z",
      "diff_hunk" : "@@ -357,13 +357,19 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate, bool dryRun)\n {\n     NotifyEntryAdded(entry.GetSharedTx());\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#discussion_r137424904",
      "id" : 137424904,
      "in_reply_to_id" : 137255837,
      "original_commit_id" : "95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "original_position" : 12,
      "path" : "src/txmempool.cpp",
      "position" : 12,
      "pull_request_review_id" : 61089648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11201",
      "updated_at" : "2017-09-07T00:50:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137424904",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Hey @sdaftuar, it's not done yet (still need to implement eviction/properly count descendants) but I've been working on implementing the feature in the way you described over here: https://github.com/justicz/bitcoin/pull/3 . I broke the relevant parts of the CTxMemPool interface out into a CTxMemPoolBase class and then implemented a CTxMockMemPool that I pass into ATMP.\r\n\r\nIs this more what you had in mind? I'm modifying some of the const CTxMemPool methods to accept a cache so that I can avoid duplicating a lot of the logic.",
      "created_at" : "2017-09-13T02:05:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-329035597",
      "id" : 329035597,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-09-13T02:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/329035597",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Closing this PR, will make a new one in the future if I can come up with an implementation I am happy with",
      "created_at" : "2017-10-12T07:01:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-336039170",
      "id" : 336039170,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-10-12T07:01:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/336039170",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/17011613?v=4",
         "events_url" : "https://api.github.com/users/justicz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/justicz/followers",
         "following_url" : "https://api.github.com/users/justicz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/justicz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/justicz",
         "id" : 17011613,
         "login" : "justicz",
         "organizations_url" : "https://api.github.com/users/justicz/orgs",
         "received_events_url" : "https://api.github.com/users/justicz/received_events",
         "repos_url" : "https://api.github.com/users/justicz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/justicz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/justicz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/justicz"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Please ping when you do come up with a better implementation. I have strong interest in this!",
      "created_at" : "2017-10-23T15:49:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11201#issuecomment-338704227",
      "id" : 338704227,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11201",
      "updated_at" : "2017-10-23T15:49:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/338704227",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/93665?v=4",
         "events_url" : "https://api.github.com/users/wtogami/events{/privacy}",
         "followers_url" : "https://api.github.com/users/wtogami/followers",
         "following_url" : "https://api.github.com/users/wtogami/following{/other_user}",
         "gists_url" : "https://api.github.com/users/wtogami/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/wtogami",
         "id" : 93665,
         "login" : "wtogami",
         "organizations_url" : "https://api.github.com/users/wtogami/orgs",
         "received_events_url" : "https://api.github.com/users/wtogami/received_events",
         "repos_url" : "https://api.github.com/users/wtogami/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/wtogami/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/wtogami/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/wtogami"
      }
   }
]
