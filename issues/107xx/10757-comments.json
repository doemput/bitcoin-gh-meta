[
   {
      "body" : "Some ideas for additions:\r\n- Non-fee total output amount\r\n- Coinbase reward\r\n- Money supply including this block\r\n- Transaction weight `txweight` (it can be derived from existing fields, however)\r\n\r\nI would prefer to see both `time` and `mediantime` returned, since they are available.\r\n\r\nShould we return non-independent fields, such as `avgfee` when also including `totalfee` and `txs`?\r\n\r\nI find that for bitcoin-related data, the median is often more useful than the average of a distribution. Including `medianweight`, `medianfee`, `medianfeerate`, `medianoutput` etc would expose these useful quantities to the user.",
      "created_at" : "2017-07-07T15:03:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313707397",
      "id" : 313707397,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:03:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313707397",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> but once written, why not keep it?\r\n\r\nBecause more code => more bugs and more maintenance effort. I prefer:\r\n\r\nIf it's not really needed, why add it?\r\n\r\nThis is perhaps a nice-to-have, but since #8704, `getblock` can return all transactions in a block (without requiring `txindex`). Those can then be parsed and analysed offline.\r\n\r\nIs there a compelling use-case I'm missing here? This seems like a feature only a small subset of users would be interested in, in which case an offline tools seems more appropriate.\r\n\r\nSorry - not meaning to be negative, but my default reaction to new RPCs/arguments tends towards NACK unless I can see a compelling and widespread use-case.",
      "created_at" : "2017-07-07T15:28:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313714215",
      "id" : 313714215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:28:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313714215",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> This is perhaps a nice-to-have, but since #8704, getblock can return all transactions in a block (without requiring txindex). Those can then be parsed and analysed offline.\r\n\r\nThis code pulls each transaction input's previous outpoint in order to compute transaction fees. Replicating that in RPC would require thousands of calls for most blocks.",
      "created_at" : "2017-07-07T15:50:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720092",
      "id" : 313720092,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:50:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720092",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> This code pulls each transaction input's previous outpoint\r\n\r\nAh yes, of course. Concept ACK in that case. Doing this with `getblock` / `getrawtransaction` is infeasible.",
      "created_at" : "2017-07-07T15:53:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720976",
      "id" : 313720976,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:53:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720976",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> Because more code => more bugs and more maintenance effort. I prefer:\r\n\r\nSure, but I mean, removing for example the avgfee or avgfeerate won't  safe much code or testing code, just a few lines. Forget I said this, if there's specific functions to remove because nobody will want them, let's remove those and focus on the ones people want. Adding specific things only a few people want can also happen in their own branches, so it's no big deal.\r\n\r\nThe only use case is gather statistics, presumably to plot things, create charts. That is, at least, compelling to me, but I don't think that will have widespread usage. I also don't think all rpc calls have it. Is getchaintxstats, for example, a widespread use case?\r\n\r\nIf that's enough reason not to merge this, it's fine, I can maintain it as a separate branch that I periodically rebase, it is simple enough, so that won't be a big deal. On the other hand, if I can get it reviewed and merged it'll be less work for me in the long run and I also get the review.\r\n\r\n> Non-fee total output amount\r\n> Coinbase reward\r\n\r\nSounds good.\r\n\r\n> Money supply including this block\r\n\r\nMhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\n> Transaction weight txweight (it can be derived from existing fields, however)\r\n\r\nIn fact I'm using weight for everything. I should s/size/weight/ and probably also show size separately. \r\nMaybe separate feerates in by weight and serialize size? I don't know...\r\n\r\n> I would prefer to see both time and mediantime returned, since they are available.\r\n\r\nYeah, the mediantime takes a little bit longer to be calculated but not much and one can always disable anything. In fact, the height and time shouldn't be treated in any special way for being \"the x axis\" and should be allowed to be disabled like the rest.\r\n\r\n> Should we return non-independent fields, such as avgfee when also including totalfee and txs?\r\n\r\nThis is a good question. This is mostly what I meant by \"why not if it's this easy?\".\r\nBut yeah, I guess non-independent are good candidates to be removed.\r\n\r\nre median: yeah, that sounds interesting too, good idea!\r\n",
      "created_at" : "2017-07-07T16:29:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313729916",
      "id" : 313729916,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313729916",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "> Mhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\nI was thinking of the more trivial version, rather than the `supply - provably_unspendable` version, so keeping that as external code makes more sense. Maintaining the sum of spendable outputs against block height is a much more ambitious idea, and it may make sense in the future. However, it is probably out of scope of this PR.",
      "created_at" : "2017-07-07T16:37:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313731922",
      "id" : 313731922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313731922",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:37:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127",
      "id" : 126259127,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```cpp\r\nstd::set<std::string> allowed_plot_values = {\"minfee\", \"maxfee\", \"...\"};\r\n```",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:52:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721",
      "id" : 126260721,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 150,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:53:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851",
      "id" : 126260851,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 151,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```cpp\r\n\"...\" + boost::join(allowed_plot_values, \",\")\r\n```",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:54:32Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000",
      "id" : 126261000,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 160,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing result example.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:55:17Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085",
      "id" : 126261085,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 163,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Duplicate.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T22:55:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101",
      "id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```cpp\r\nstd::set<std::string> plot_values;\r\nif (request.params.size() > 2) {\r\n  boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\r\n\r\n  // only validate in this case\r\n  // ... \r\n} else {\r\n  plot_values = allowed_plot_values;\r\n}\r\n```",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T23:00:26Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710",
      "id" : 126261710,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 190,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T23:03:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049",
      "id" : 126262049,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 137,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```cpp\r\nif (allowed_plot_values.count(plot_value) == 0) {\r\n```",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-07T23:07:37Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450",
      "id" : 126262450,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "One is HelpExampleCli and the other is HelpExampleRpc",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-08T00:08:10Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402",
      "id" : 126267402,
      "in_reply_to_id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48741927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ops sorry, overlooked it.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-08T00:16:40Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869",
      "id" : 126267869,
      "in_reply_to_id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48742472,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "duh, I was so much over-complicating things so much for no good reason...thank you!",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-08T00:57:06Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648",
      "id" : 126269648,
      "in_reply_to_id" : 126262450,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48744410,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Thanks again for the great feedback!\r\n\r\n@promag I think I solved all your nits except for https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101\r\n\r\n@clarkmoody I think I added most of your suggestions, explicitly excluding anything that involved accumulations neither from height=1 nor from height=start.\r\nThe former potentially implies a world of complexity and the latter can be trivially calculated on the visual side: I would completely discard any accumulator redundancy in this rpc beforehand.\r\n\r\nAnd for the rest of the redundancies, @jnewbery and @clarkmoody - thanks again for pointing it out -, it's never too late to remove them before merging like a trivial squash and it's never too soon to start saying which ones you would bikesay* out first. Also bikesay the names for the curves and even the order in the list (duplicated for c++ and python).\r\n\r\nIn the meantime, I embraced redundancy since, as said, it will be trivial for me to remove later. And also the pertinent optimizations to skip calculations when plot_values.count(\"minfee\") == 0 or actually only when the extra calculation is more expensive than the searching in plot_values which is a set of strings.\r\n\r\nFor example, we have blockfees, reward, subsidy, complying with consensus rule ```reward == blockfees + subsidy```. Only 2 of the 3 are necessary, at least one is redundant. My personal preference is removing either subsidy or reward or subsidy, but not blockfees. But at said once written there's no problem with me in just making sure their tests don't surprise me until we decide which ones didn't deserve it. \r\n\r\nWhich one seems bikesaying in principle. But not in this case. \r\nblockfees/total_fees serves for other calculations like avgfeerate. Let's not remove that one, just rename it.\r\n\r\nBut it is more interesting to propose new ones than to rename or vote for removal IMO. I believe the most interesting addition to this point was utxo_size_inc, which would welcomed some review from people who measures sizes more carefully like @sipa , since this doesn't use GetSerializeSize for Coin intentionally, independently of the optimization to read Coin if available in the utxo before calling RpcGetTx. I'm still not sure what to do with pre/post segwit feerates, does anybody care about the pre ones? which one needs the scale factor? none?\r\n\r\nREM CalculateTruncatedMedian doesn't need to be a template at this point, but there's no harm being static IMO\r\n\r\nEDIT: still some TODOs, mostly documentation and pending decisions\r\n",
      "created_at" : "2017-07-08T07:27:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840344",
      "id" : 313840344,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:32:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840344",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "@jtimon no problem. There are some nits to fix but I'll review more in depth later.",
      "created_at" : "2017-07-08T07:36:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840707",
      "id" : 313840707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:36:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840707",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Drop `_`? Same below.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-09T00:11:49Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902",
      "id" : 126292902,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Keep argument order as `ReadBlockFromDisk`? Is there a convention for where the *output arguments* should be?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-09T00:13:04Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910",
      "id" : 126292910,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit, could sort only after `size == 1` case.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-09T00:19:36Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958",
      "id" : 126292958,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 68,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`static constexpr ...`",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:34:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455",
      "id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove empty line.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:34:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503",
      "id" : 126457503,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 107,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:51:49Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550",
      "id" : 126462550,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 296,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```cpp\r\nUpdateBlockStats(chainActive[i], ...);\r\n```",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:52:22Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704",
      "id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Replace `plotvalues` with `stats`? Also, 3rd argument could be object `options`?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:54:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400",
      "id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit, negative block could mean `end = height - end` to avoid early blocks (not new concept here I believe)?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T15:56:31Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865",
      "id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not that I know of, but your proposed change sounds good to me.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T17:56:12Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736",
      "id" : 126492736,
      "in_reply_to_id" : 126292910,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48982074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "what's the gain? https://stackoverflow.com/a/41132221/935325 says it's the same...",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T17:58:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273",
      "id" : 126493273,
      "in_reply_to_id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48982680,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will be slightly less efficient, no?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T18:00:48Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852",
      "id" : 126493852,
      "in_reply_to_id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48983341,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mhmm, interesting. To be clear you mean start=-10 end=200 would be equivalent to start=190 end=200, right?\r\n",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T18:03:16Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452",
      "id" : 126494452,
      "in_reply_to_id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48984019,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Isn't the string simpler?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-10T18:03:56Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613",
      "id" : 126494613,
      "in_reply_to_id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48984210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well, yes, conserving the old name only saves 1 line of extra disruption. But I guess if we're touching the variable name we should use the new style. just bytes?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-11T00:28:26Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538",
      "id" : 126569538,
      "in_reply_to_id" : 126292902,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : null,
      "pull_request_review_id" : 49066057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, I meant negative values are relative to the tip. To get the stats for the last 10 blocks you would pass start = -10 without querying the current block height.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-11T10:45:53Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629",
      "id" : 126654629,
      "in_reply_to_id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49157689,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ignore `options` suggestion.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-11T10:46:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771",
      "id" : 126654771,
      "in_reply_to_id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49157867,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess it takes few more cycles but non critical code should be cleaner?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-07-11T10:48:01Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004",
      "id" : 126655004,
      "in_reply_to_id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49158135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "Here are some images generated using this branch in combination with (WIP): https://github.com/jtimon/rpc-explorer\r\n\r\nGUI detail:\r\n\r\n![screenshot_plotter](https://user-images.githubusercontent.com/1008458/28092233-ed1cb2ca-6692-11e7-9374-38a98cd6c258.png)\r\n\r\nGUI detail zoom:\r\n\r\n![screenshot_plotter_zoom](https://user-images.githubusercontent.com/1008458/28092271-048e594a-6693-11e7-9572-81f80980a087.png)\r\n\r\nHide some:\r\n\r\n![plotter1](https://user-images.githubusercontent.com/1008458/28092276-083a4518-6693-11e7-815d-c45d0acbfc4d.png)\r\n\r\nHide more:\r\n\r\n![plotter2](https://user-images.githubusercontent.com/1008458/28092279-0ac02fd2-6693-11e7-87c5-84d230985d6c.png)\r\n\r\nFees:\r\n\r\n![plotterfees](https://user-images.githubusercontent.com/1008458/28092284-0d22c2a8-6693-11e7-937d-451bfe0c5da5.png)\r\n\r\nUtxo size increase:\r\n\r\n![plotter_utxo](https://user-images.githubusercontent.com/1008458/28092288-0f6bc3d4-6693-11e7-910e-b18e3bfa44a2.png)\r\n",
      "created_at" : "2017-07-11T21:47:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314581913",
      "id" : 314581913,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-11T21:49:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314581913",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779"
         }
      },
      "body" : "Maybe. I'll wait for someone else to weight in since it doesn't seem a big deal either way. ",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T22:42:03Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779",
      "id" : 126826779,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 49349707,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T22:42:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Without the documentation for the result it was impossible to distinguish a weird choice to spring discussion from an implementation mistake. Removed the other TODO comments.\r\nCoded more pending suggestions by @promag (hopefully all pending ones? if not, please insist) with some extra bikeshedding derived from s/plotvalues/stats/ and adapt tests to start and end being allowed to be negative.\r\n\r\nMore cleanups can be done, specially in the tests if we go further with https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704 and not calculate in inverse order (there's no point if we don't get the slight optimization).\r\n\r\n",
      "created_at" : "2017-07-12T05:54:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314659201",
      "id" : 314659201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-12T05:54:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314659201",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Needed rebase.\r\nIf somebody made a web for it, it may be interesting to show number of segwit txs too http://segwit.5gbfree.com/countsegwit\r\n\r\n",
      "created_at" : "2017-08-24T20:27:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-324747757",
      "id" : 324747757,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-24T20:27:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/324747757",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Just wanted to say that this would be massively helpful to track statistics. I hope this finds it's way into a release soon.",
      "created_at" : "2017-08-29T08:35:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-325594164",
      "id" : 325594164,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-29T08:35:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325594164",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31221696?v=4",
         "events_url" : "https://api.github.com/users/forklol/events{/privacy}",
         "followers_url" : "https://api.github.com/users/forklol/followers",
         "following_url" : "https://api.github.com/users/forklol/following{/other_user}",
         "gists_url" : "https://api.github.com/users/forklol/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/forklol",
         "id" : 31221696,
         "login" : "forklol",
         "organizations_url" : "https://api.github.com/users/forklol/orgs",
         "received_events_url" : "https://api.github.com/users/forklol/received_events",
         "repos_url" : "https://api.github.com/users/forklol/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/forklol/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/forklol/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/forklol"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reversed the order of the values to the natural one, since as discussed the optimization of doing fetching the blocks in reverse order is not worth the loss in clarity of the code.\r\nAdded segwit tx counter stat, and also the total size and weight for those txs (txs that at least have one sw input, txs sending to sw outputs don't count).\r\n",
      "created_at" : "2017-08-31T06:57:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326207756",
      "id" : 326207756,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-31T06:57:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326207756",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Perhaps a better name for \\<stat\\>_old is \\<stat\\>_virtual, _virt or _v. Or perhaps prepend it with \"v\"  just like the tx size in the output of `getrawtransaction` (vsize).\r\n\r\nFor example:\r\n\r\n`avgfeerate_old` becomes `vavgfeerate`\r\n`maxfeerate_old` becomes `vmaxfeerate`\r\n`medianfeerate_old` becomes `vmedianfeerate`\r\n\r\netc.",
      "created_at" : "2017-09-01T15:29:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326610892",
      "id" : 326610892,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-01T15:29:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326610892",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I just finished calling `getblockstats` on every block in the chain and saving it into a database. I didn't encounter any issues and the performance is quite good (100-1000ms per \"full\" block on an i7 6900k /w 32gb ram + nvme ssd).\r\n\r\nBtw, if anyone is interested in the dataset I can share it. Just convo me at freenode irc (nick: \"trippysalmon\"). It includes some other stats as well, like rolling average hashrates.",
      "created_at" : "2017-09-03T17:34:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326819183",
      "id" : 326819183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-03T17:37:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326819183",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r136726580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136726580"
         }
      },
      "author_association" : "OWNER",
      "body" : "For feerate you should use the virtual size, not total size.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-09-03T21:19:17Z",
      "diff_hunk" : "@@ -1531,6 +1538,313 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r136726580",
      "id" : 136726580,
      "original_commit_id" : "b2d93e4dfa647a4223ee37bd233d373f2cde25b1",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 60305113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136726580",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Just noticed this PR; I'll definitely be incorporating it into Statoshi once it's merged! :+1: ",
      "created_at" : "2017-09-03T22:09:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326834401",
      "id" : 326834401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-03T22:09:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326834401",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/288011?v=4",
         "events_url" : "https://api.github.com/users/jlopp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jlopp/followers",
         "following_url" : "https://api.github.com/users/jlopp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jlopp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jlopp",
         "id" : 288011,
         "login" : "jlopp",
         "organizations_url" : "https://api.github.com/users/jlopp/orgs",
         "received_events_url" : "https://api.github.com/users/jlopp/received_events",
         "repos_url" : "https://api.github.com/users/jlopp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jlopp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jlopp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jlopp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r137426640"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137426640"
         }
      },
      "author_association" : "MEMBER",
      "body" : "feerate is using vsize, feerate_old is using old size. Perhaps we just want to remove the whole *_old family.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-09-07T01:06:08Z",
      "diff_hunk" : "@@ -1531,6 +1538,313 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r137426640",
      "id" : 137426640,
      "in_reply_to_id" : 136726580,
      "original_commit_id" : "b2d93e4dfa647a4223ee37bd233d373f2cde25b1",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 61091554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-17T12:10:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137426640",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@trippysalmon I think you mean replacing s/<stat>feerate/v<stat>feerate/ and s/<stat>feerate_old/<stat>feerate/.\r\nAs discussed with @sipa the *feerate_old are using old size and the *feerate ones are using vsize.\r\n\r\nHow much interest there is in maintaining the old ones?\r\nPre-segwit both are identical and post segwit the old ones mean the how high the feerate would have been for mempool and mining purposes if you weren't using segwit.\r\nFor example, the same tx can have feerate 4 sat/vbyte (new) and 2 sat/byte (old), meaning for the same fee, your tx gets propagated/mined as if you had paid twice as much thanks to segwit's discount.\r\n\r\nIf there's not much interest, perhaps it's just better to just remove all the old ones.\r\nBy the way, I said before that we hold on removing redundant or uninteresting stats.\r\nI would start with reward, which the caller can calculate by simply adding subsidy and totalfees.\r\n\r\nNeeds rebase.",
      "created_at" : "2017-09-07T01:19:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327655184",
      "id" : 327655184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T01:19:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327655184",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2017-09-07T06:22:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327699176",
      "id" : 327699176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T06:22:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327699176",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@jtimon ah yes, I got it now. I misinterpreted the meaning of the `_old` statistics.\r\n\r\nIn that case the `_old` statistics are indeed not that interesting. I would however like to see a pre segwit `total_size` statistic. That one is currently missing and it's kind of a hassle to calculate it through RPC calls.\r\n\r\nI will update my pre segwit total_vsize [PR](https://github.com/jtimon/bitcoin/pull/9) soon.",
      "created_at" : "2017-09-07T15:10:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327829878",
      "id" : 327829878,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T15:51:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327829878",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@trippysalmon not sure what you mean by \"pre segwit total size\". Total size is included, but size it's size post and pre segwit. You mean you want a stat for total vsize ? Not sure that's very interesting...",
      "created_at" : "2017-09-08T13:53:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328109201",
      "id" : 328109201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T13:53:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328109201",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@jtimon yes I'm talking about total_vsize. Perhaps it depends on my particular use-case (comparing and graphing total_size vs total_vsize). My reasoning is that it is easy to add and compute inside core but not so much through RPC calls.\r\n\r\nIf you think total_vsize is not useful/interesting to others I don't mind maintaining it in a custom patch. I'm actually already using it in a project atm.\r\n\r\nedit: never mind, total_vsize can be calculated by `total_weight / 4`",
      "created_at" : "2017-09-08T15:54:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328142732",
      "id" : 328142732,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T21:28:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328142732",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Removed reward and *feerate_old as discussed, but didn't squashed just in case.\r\nDiscussing with @trippysalmon we thought could show vsize instead of weight, but the former is just the latter / 4 (ie WITNESS_SCALE_FACTOR) and presenting the weight we can completely forget about rounding concerns (plus that's what getblock presents too, perhaps that's a reason to exclude it here).\r\n",
      "created_at" : "2017-09-08T23:52:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328238904",
      "id" : 328238904,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T23:52:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328238904",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Using this branch more, at first a range of heights was convenient but I was ready to wait even if I had to call this rpc block by block.\r\nRight now, that's what I'm doing since once you start caching, calling this function is never a success but a cache failure. It is completely understandable that one doesn't want to manage failure ranges when failures can be discovered individually and thus processed in parallel.\r\nThat's probably opinionated, but perhaps others trying to use this got many errors forgetting \"[0]\" in some places.\r\n\r\nSupporting ranges may be an optimization for users, but since I have been lucky enough to attract some potential users of this rpc call, I can ask: will anybody miss the height ranges?\r\n\r\nSince I'm indexing my cache by block height and that's inherently \"reorg unfriendly\" I mostly see 2 options going forward:\r\n\r\n1) Subscribe to the zmq interface, detect reorgs and remove block stats above the reorg height (while at it, one can put new blocks in the cache preemtively even if nobody asked for them yet)\r\n\r\n2) Stop indexing the block stat cache by  height, do it by block hash. This is compatible with reorgs (more space but less disk writing and it's also required for advanced features like plotting abandoned/orphan chains).\r\n\r\nI am inclined to trying both as a user since I want to subscribe to blocks but I also don't want to erase blocks I have seen and don't want to lose the option to chart reorged chains.\r\n\r\nA second question is simply, assuming the height ranges are removed, would anyone else apart from me use the option to search by single block hash instead of single height?\r\n\r\nAnyway, that would be my preference: replace height ranges with single height or single block hash (both options).\r\nPlease let me know what you think.",
      "created_at" : "2017-10-05T15:23:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-334499898",
      "id" : 334499898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-15T15:13:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/334499898",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I use this RPC call extensively (and persist the results in a DB) and never used the block height range, only single blocks.\r\n\r\n> Anyway, that would be my preference: replace height ranges with single height or single block height (both options).\r\n\r\nI think you meant block hash as the second option? For my use-case it doesn't really matter if I have to use the block height or block hash. Either option works for me.\r\n\r\n--\r\n\r\nAlso, something that I needed today was the median transaction size. I don't think it can be calculated using the existing statistics or am I wrong?\r\n\r\nIt's only a [minor change](https://github.com/trippysalmon/bitcoin/commit/4a1d4d06e4c20356fe0e4359a3af2acfda06b1fc) and could be interesting to track over time to see it change when more complex scripts are made available.",
      "created_at" : "2017-10-13T20:00:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-336553230",
      "id" : 336553230,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-13T20:00:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/336553230",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, squashed, added \"mintxsize\", \"maxtxsize\", \"mediantxsize\" and \"avgtxsize\" stats.\r\n\r\nRegarding the ranges, thanks for the feedback, I'll wait to hear from other people.\r\n\r\nEDIT: btw, some of the tests are commented because tx sizes don't seem to be deterministic, I suspect due to coin selection. Not sure what to do about that.\r\n",
      "created_at" : "2017-10-17T12:15:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-337212106",
      "id" : 337212106,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-17T12:18:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/337212106",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145622618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145622618"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Shouldn't this be GetTransaction(..., false) ?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-19T07:51:39Z",
      "diff_hunk" : "@@ -1564,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145622618",
      "id" : 145622618,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 67,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 67,
      "pull_request_review_id" : 70447630,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-19T07:51:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145622618",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659377"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659377"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the values, fees and fee rates should be wrapped with ValueFromAmount, so outputs are decimal bitcoins rather than integer satoshis, for consistency with other RPC calls.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-19T10:21:34Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659377",
      "id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 178,
      "pull_request_review_id" : 70489270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-19T10:30:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659377",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659877"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "None of the transactions have witness data, so this isn't actually checking whether swtxs, swtotal_size, swtotal_weight ever output anything other than 0, or whether weight is ever anything other than size*4.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-19T10:24:02Z",
      "diff_hunk" : "@@ -0,0 +1,187 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = node.getblockstats(start=start_height, end=start_height + max_stat_pos)\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats, all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats.keys())\n+\n+        assert_equal(stats['height'][0], start_height)\n+        assert_equal(stats['height'][max_stat_pos], start_height + max_stat_pos)\n+\n+        assert_equal(stats['txs'][0], 1)\n+        assert_equal(stats['swtxs'][0], 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659877",
      "id" : 145659877,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 84,
      "path" : "test/functional/getblockstats.py",
      "position" : 84,
      "pull_request_review_id" : 70489270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-19T10:30:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659877",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106768"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106768"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, we want to allow the slow fetch too. If the data is calculable we want to provide it no matter if more slowly. This rpc call shouldn't be expected to be fast anyway.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-21T14:33:58Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106768",
      "id" : 146106768,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 178,
      "pull_request_review_id" : 71008762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-21T14:33:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106768",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106887"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is true. When I wrote this segwit wasn't activated, but now it would be nice to add segwit txs to the test because otherwise this functionality isn't really being tested. Good call.",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-21T14:37:23Z",
      "diff_hunk" : "@@ -0,0 +1,187 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = node.getblockstats(start=start_height, end=start_height + max_stat_pos)\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats, all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats.keys())\n+\n+        assert_equal(stats['height'][0], start_height)\n+        assert_equal(stats['height'][max_stat_pos], start_height + max_stat_pos)\n+\n+        assert_equal(stats['txs'][0], 1)\n+        assert_equal(stats['swtxs'][0], 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106887",
      "id" : 146106887,
      "in_reply_to_id" : 145659877,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 84,
      "path" : "test/functional/getblockstats.py",
      "position" : 84,
      "pull_request_review_id" : 71008834,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-21T14:37:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106887",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146541947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146541947"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm presuming this reply should be to the \"GetTransaction(..., false)\" comment. Getting fee info without txindex seems like a weird thing to do to me, but if it's supported then presumably the getblockstats RPC help text doesn't need to still say \"It won't work .. without -txindex.\" ?",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-24T12:24:24Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146541947",
      "id" : 146541947,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 178,
      "pull_request_review_id" : 71497165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-24T12:24:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146541947",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146551957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, sorry. Was meant for the other comment. Actually looking at the code again the slow search will only find txs in the utxo, so using false should be fine. I'll test it with false.\r\n\r\nRegarding using BTC instead of satoshis, I think we want to move everything to satoshis but we don't do it because it would be too disruptive, so we only do it with new calls.\r\nThe caller can trivially divide by 100000000 to get BTC if they want t show that. ",
      "commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "created_at" : "2017-10-24T13:04:35Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146551957",
      "id" : 146551957,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 178,
      "pull_request_review_id" : 71509206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-10-24T13:04:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551957",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   }
]
