[
   {
      "body" : "Rebase now that #7575 has been merged.",
      "created_at" : "2016-03-18T08:49:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-198260300",
      "id" : 198260300,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-18T08:49:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/198260300",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "body" : "To aid review, here are the pull requests for each BIP:\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/7184 - Sequence locks\r\nhttps://github.com/bitcoin/bitcoin/pull/7524 - CSV\r\nhttps://github.com/bitcoin/bitcoin/pull/6566 - Median time past",
      "created_at" : "2016-03-18T18:38:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-198489078",
      "id" : 198489078,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-18T18:38:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/198489078",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5617245?v=3",
         "events_url" : "https://api.github.com/users/afk11/events{/privacy}",
         "followers_url" : "https://api.github.com/users/afk11/followers",
         "following_url" : "https://api.github.com/users/afk11/following{/other_user}",
         "gists_url" : "https://api.github.com/users/afk11/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/afk11",
         "id" : 5617245,
         "login" : "afk11",
         "organizations_url" : "https://api.github.com/users/afk11/orgs",
         "received_events_url" : "https://api.github.com/users/afk11/received_events",
         "repos_url" : "https://api.github.com/users/afk11/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/afk11/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/afk11/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/afk11"
      }
   },
   {
      "body" : "ACK 19d73d5",
      "created_at" : "2016-03-18T19:01:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-198496598",
      "id" : 198496598,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-18T19:01:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/198496598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "Can you add my commit, https://github.com/btcdrak/bitcoin/pull/8 the current test does not cover exactly the activation part, I'm not comfortable with it.\r\n\r\nMy test can be used for testing segwit activation later also in few lines.",
      "created_at" : "2016-03-19T15:59:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-198737326",
      "id" : 198737326,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-19T16:01:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/198737326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "tACK 71527a0",
      "created_at" : "2016-03-21T10:17:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-199211855",
      "id" : 199211855,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-21T10:17:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/199211855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "utACK https://github.com/bitcoin/bitcoin/pull/7648/commits/71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-22T14:57:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-199853131",
      "id" : 199853131,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-22T14:57:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/199853131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "tACK 71527a0",
      "created_at" : "2016-03-23T14:23:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200365762",
      "id" : 200365762,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T14:23:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200365762",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "body" : "Concept ACK, utACK code changes; I only glanced over the test code",
      "created_at" : "2016-03-23T14:36:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200371477",
      "id" : 200371477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T14:36:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200371477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "nit: The new RPC test is very noisy. Printing lines for passing tests is not necessary, at least by default, could be behind some verbose flag:\r\n```\r\nTest 1: PASS [143]\r\nTest 2: PASS [287]\r\n...\r\nTest 124: PASS [582]\r\nTest 125: PASS [582]\r\n```",
      "created_at" : "2016-03-23T16:52:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200438105",
      "id" : 200438105,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T16:52:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200438105",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj yeah, I noticed that too.  Unfortunately, that's the underlying behavior of the ComparisonTestFramework that the RPC test is built off of.  I agree it would be nice to make optional.\r\n\r\nEDIT: I suppose it would be easy to just always surpress the `PASS` output, and still output on failures.\r\n",
      "created_at" : "2016-03-23T17:19:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200449046",
      "id" : 200449046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T17:21:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200449046",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "@laanwj I also agree, but it's orthogonal to this PR imo. If you don't mind, I'd like to push back on quieting tests for this PR. Ideally it would be much better to print a dot per test on the same line and only emit error messages if necessary. But that would require a change to the ComparisonTestFramework.",
      "created_at" : "2016-03-23T17:27:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200453204",
      "id" : 200453204,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T17:27:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200453204",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "body" : "@btcdrak @morcos Sure, I'm fine with keeping it this way in this pull.",
      "created_at" : "2016-03-23T17:34:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200457345",
      "id" : 200457345,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T17:34:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200457345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "ACK",
      "created_at" : "2016-03-23T20:38:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-200535475",
      "id" : 200535475,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-23T20:38:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/200535475",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5617245?v=3",
         "events_url" : "https://api.github.com/users/afk11/events{/privacy}",
         "followers_url" : "https://api.github.com/users/afk11/followers",
         "following_url" : "https://api.github.com/users/afk11/following{/other_user}",
         "gists_url" : "https://api.github.com/users/afk11/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/afk11",
         "id" : 5617245,
         "login" : "afk11",
         "organizations_url" : "https://api.github.com/users/afk11/orgs",
         "received_events_url" : "https://api.github.com/users/afk11/received_events",
         "repos_url" : "https://api.github.com/users/afk11/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/afk11/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/afk11/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/afk11"
      }
   },
   {
      "body" : "ACK code changes, ran tests but did not review test code.",
      "created_at" : "2016-03-25T05:52:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-201153513",
      "id" : 201153513,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-25T05:52:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/201153513",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/894059?v=3",
         "events_url" : "https://api.github.com/users/CodeShark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/CodeShark/followers",
         "following_url" : "https://api.github.com/users/CodeShark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/CodeShark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/CodeShark",
         "id" : 894059,
         "login" : "CodeShark",
         "organizations_url" : "https://api.github.com/users/CodeShark/orgs",
         "received_events_url" : "https://api.github.com/users/CodeShark/received_events",
         "repos_url" : "https://api.github.com/users/CodeShark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/CodeShark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/CodeShark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/CodeShark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57683589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57683589"
         }
      },
      "body" : "Shouldn't this be an \"extended test\"?",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T07:50:02Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@\n \n #Tests\n testScripts = [\n+    'bip68-112-113-p2p.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57683589",
      "id" : 57683589,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 4,
      "path" : "qa/pull-tester/rpc-tests.py",
      "position" : 4,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T07:50:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57683589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57684127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57684127"
         }
      },
      "body" : "IMO: bip9 itself is not a softfork and could therefore be in the \"normal\" `testScripts` array.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T07:54:43Z",
      "diff_hunk" : "@@ -118,6 +119,7 @@\n     'p2p-versionbits-warning.py',\n ]\n testScriptsExt = [\n+    'bip9-softforks.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57684127",
      "id" : 57684127,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 12,
      "path" : "qa/pull-tester/rpc-tests.py",
      "position" : 12,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T07:54:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57684127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "ACK https://github.com/bitcoin/bitcoin/pull/7648/commits/71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:10:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-202772543",
      "id" : 202772543,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T08:10:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202772543",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686483"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686483"
         }
      },
      "body" : "nit: probably to late now and kinda-unrelated to this PR, but instead of `TESTDUMMY` we could have used something like `DEFAULT` or `DEFAULTVOID`.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:18:55Z",
      "diff_hunk" : "@@ -15,6 +15,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686483",
      "id" : 57686483,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 3,
      "path" : "src/consensus/params.h",
      "position" : 3,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T08:18:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686483",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686663"
         }
      },
      "body" : "no, this is a softfork and certainly until there is activation, I want to test for regressions as a standard part of the CI process.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:20:54Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@\n \n #Tests\n testScripts = [\n+    'bip68-112-113-p2p.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686663",
      "id" : 57686663,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 4,
      "path" : "qa/pull-tester/rpc-tests.py",
      "position" : 4,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T08:20:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686663",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686733"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686733"
         }
      },
      "body" : "It's testing the activation logic of bip9 softforks.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:21:25Z",
      "diff_hunk" : "@@ -118,6 +119,7 @@\n     'p2p-versionbits-warning.py',\n ]\n testScriptsExt = [\n+    'bip9-softforks.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686733",
      "id" : 57686733,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 12,
      "path" : "qa/pull-tester/rpc-tests.py",
      "position" : 12,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T08:21:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686733",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686806"
         }
      },
      "body" : "Not added in PR though. That was #7575. I think the name is sufficient though, to indicate it's not a real softfork, but for testing purposes.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:22:06Z",
      "diff_hunk" : "@@ -15,6 +15,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57686806",
      "id" : 57686806,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 3,
      "path" : "src/consensus/params.h",
      "position" : 3,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T08:23:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57686806",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57687103"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57687103"
         }
      },
      "body" : "Fair enough.",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:24:40Z",
      "diff_hunk" : "@@ -15,6 +15,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57687103",
      "id" : 57687103,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 3,
      "path" : "src/consensus/params.h",
      "position" : 3,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T08:24:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57687103",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Tested ACK 71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T08:51:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-202783153",
      "id" : 202783153,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T08:51:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202783153",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "utACK (although I didn't look at the rpc tests in depth ).",
      "created_at" : "2016-03-29T12:30:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-202871360",
      "id" : 202871360,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T12:30:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202871360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "I saw there was some discussion of this already (https://github.com/btcdrak/bitcoin/pull/8), but I don't really see the point of the `bip9-softforks.py` test -- it seems like a subset of the testing done in `bip68-112-113-p2p.py`.  I don't feel strongly if you want to include it here, in case it helps anyone's review, but I thought I'd mention that this seems like a candidate for removal from the repo in the future.\r\n\r\nAlso perhaps we should remove the code in `bip68-sequence.py` which tests that BIP68 is not consensus (https://github.com/bitcoin/bitcoin/blob/5131005e5b26d12b5b3f79c1c3f8ee08172fc386/qa/rpc-tests/bip68-sequence.py#L337)?  That test will continue to pass for the time being, because not enough blocks are generated to trigger the soft fork, but it's somewhat confusing to keep that test in the repo, and at any rate the RPC test `bip68-112-113-p2p.py` is comprehensively testing that BIP68 activates in the right way.\r\n\r\n\r\n\r\n\r\n",
      "created_at" : "2016-03-29T16:48:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-202993136",
      "id" : 202993136,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T16:48:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202993136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57757987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57757987"
         }
      },
      "body" : "nit: `locktime_delta` appears to be unused in this function",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:51:36Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57757987",
      "id" : 57757987,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 159,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:51:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57757987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758297"
         }
      },
      "body" : "nit: The comments at lines 386 and 388 appear to be incorrect.  Perhaps `# < MTP of prior block`?",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:53:52Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip68inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        tx.nVersion = txversion\n+                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        signtx = self.sign_transaction(self.nodes[0], tx)\n+        signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        return signtx\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip112inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n+                        else: # vary nSequence instead, OP_CSV is fixed\n+                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        tx.nVersion = txversion\n+                        signtx = self.sign_transaction(self.nodes[0], tx)\n+                        if (varyOP_CSV):\n+                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        else:\n+                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        b18txs.append(signtx)\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def get_tests(self):\n+        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82 # height of the next block to build\n+        self.last_block_time = long_past_time\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+\n+        assert_equal(self.get_bip9_status('csv')['status'], 'defined')\n+        test_blocks = self.generate_blocks(61, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        # Advanced from DEFINED to STARTED, height = 143\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        # Failed to advance past STARTED, height = 287\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # 108 out of 144 signal bit 0 to achieve lock-in\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        # Advanced from STARTED to LOCKED_IN, height = 431\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # 140 more version 4 blocks\n+        test_blocks = self.generate_blocks(140, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+\n+        ### Inputs at height = 572\n+        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Note we reuse inputs for v1 and v2 txs so must test these separately\n+        # 16 normal inputs\n+        bip68inputs = []\n+        for i in xrange(16):\n+            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+        # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112basicinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112basicinputs.append(inputs)\n+        # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112diverseinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112diverseinputs.append(inputs)\n+        # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        # 1 normal input\n+        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n+        self.nodes[0].setmocktime(self.last_block_time + 600)\n+        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        self.nodes[0].setmocktime(0)\n+        self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n+        self.tipheight += 1\n+        self.last_block_time += 600\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+\n+        # 2 more version 4 blocks\n+        test_blocks = self.generate_blocks(2, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # Test both version 1 and version 2 transactions for all tests\n+        # BIP113 test transaction will be modified before each use to put in appropriate block time\n+        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2.nVersion = 2\n+\n+        # For BIP68 test all 16 relative sequence locktimes\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+\n+        # For BIP112 test:\n+        # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        # -1 OP_CSV OP_DROP input\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+\n+\n+        ### TESTING ###\n+        ##################################\n+        ### Before Soft Forks Activate ###\n+        ##################################\n+        # All txs should pass\n+        ### Version 1 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        success_txs.append(bip113signed1)\n+        success_txs.append(bip112tx_special_v1)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        success_txs.append(bip113signed2)\n+        success_txs.append(bip112tx_special_v2)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v2))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n+        test_blocks = self.generate_blocks(1, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        assert_equal(self.get_bip9_status('csv')['status'], 'active')\n+\n+\n+        #################################\n+        ### After Soft Forks Activate ###\n+        #################################\n+        ### BIP 113 ###\n+        # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+        # BIP 113 tests should now pass if the locktime is < MTP\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758297",
      "id" : 57758297,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 388,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:53:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758297",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758768"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758768"
         }
      },
      "body" : "nit: I think this comment should be `... nSequence 9 ...`, rather than `nSequence 11`?",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:56:35Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip68inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        tx.nVersion = txversion\n+                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        signtx = self.sign_transaction(self.nodes[0], tx)\n+        signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        return signtx\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip112inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n+                        else: # vary nSequence instead, OP_CSV is fixed\n+                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        tx.nVersion = txversion\n+                        signtx = self.sign_transaction(self.nodes[0], tx)\n+                        if (varyOP_CSV):\n+                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        else:\n+                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        b18txs.append(signtx)\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def get_tests(self):\n+        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82 # height of the next block to build\n+        self.last_block_time = long_past_time\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+\n+        assert_equal(self.get_bip9_status('csv')['status'], 'defined')\n+        test_blocks = self.generate_blocks(61, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        # Advanced from DEFINED to STARTED, height = 143\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        # Failed to advance past STARTED, height = 287\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # 108 out of 144 signal bit 0 to achieve lock-in\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        # Advanced from STARTED to LOCKED_IN, height = 431\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # 140 more version 4 blocks\n+        test_blocks = self.generate_blocks(140, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+\n+        ### Inputs at height = 572\n+        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Note we reuse inputs for v1 and v2 txs so must test these separately\n+        # 16 normal inputs\n+        bip68inputs = []\n+        for i in xrange(16):\n+            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+        # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112basicinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112basicinputs.append(inputs)\n+        # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112diverseinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112diverseinputs.append(inputs)\n+        # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        # 1 normal input\n+        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n+        self.nodes[0].setmocktime(self.last_block_time + 600)\n+        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        self.nodes[0].setmocktime(0)\n+        self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n+        self.tipheight += 1\n+        self.last_block_time += 600\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+\n+        # 2 more version 4 blocks\n+        test_blocks = self.generate_blocks(2, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # Test both version 1 and version 2 transactions for all tests\n+        # BIP113 test transaction will be modified before each use to put in appropriate block time\n+        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2.nVersion = 2\n+\n+        # For BIP68 test all 16 relative sequence locktimes\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+\n+        # For BIP112 test:\n+        # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        # -1 OP_CSV OP_DROP input\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+\n+\n+        ### TESTING ###\n+        ##################################\n+        ### Before Soft Forks Activate ###\n+        ##################################\n+        # All txs should pass\n+        ### Version 1 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        success_txs.append(bip113signed1)\n+        success_txs.append(bip112tx_special_v1)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        success_txs.append(bip113signed2)\n+        success_txs.append(bip112tx_special_v2)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v2))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n+        test_blocks = self.generate_blocks(1, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        assert_equal(self.get_bip9_status('csv')['status'], 'active')\n+\n+\n+        #################################\n+        ### After Soft Forks Activate ###\n+        #################################\n+        ### BIP 113 ###\n+        # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+        # BIP 113 tests should now pass if the locktime is < MTP\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # Next block height = 580 after 4 blocks of random version\n+        test_blocks = self.generate_blocks(4, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 13\n+\n+        ### BIP 68 ###\n+        ### Version 1 txs ###\n+        # All still pass\n+        success_txs = []\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        bip68success_txs = []\n+        # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n+        bip68timetxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n+        for tx in bip68timetxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+        bip68heighttxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+\n+        # Advance one block to 581\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+\n+        # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n+        bip68success_txs.extend(bip68timetxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+\n+        # Advance one block to 582\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+\n+        # All BIP 68 txs should pass\n+        bip68success_txs.extend(bip68heighttxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        ### BIP 112 ###\n+        ### Version 1 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_v1[0][b25][b22][b18])\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+\n+        ### Version 2 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # All txs with nSequence 11 should fail either due to earlier mismatch or failing the CSV check",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758768",
      "id" : 57758768,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 493,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 493,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:56:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758768",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758786"
         }
      },
      "body" : "nit: I think this comment is off, should be `# 8/16 of vary_OP_CSV_9`?",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:56:42Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip68inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        tx.nVersion = txversion\n+                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        signtx = self.sign_transaction(self.nodes[0], tx)\n+        signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        return signtx\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip112inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n+                        else: # vary nSequence instead, OP_CSV is fixed\n+                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        tx.nVersion = txversion\n+                        signtx = self.sign_transaction(self.nodes[0], tx)\n+                        if (varyOP_CSV):\n+                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        else:\n+                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        b18txs.append(signtx)\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def get_tests(self):\n+        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82 # height of the next block to build\n+        self.last_block_time = long_past_time\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+\n+        assert_equal(self.get_bip9_status('csv')['status'], 'defined')\n+        test_blocks = self.generate_blocks(61, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        # Advanced from DEFINED to STARTED, height = 143\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        # Failed to advance past STARTED, height = 287\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # 108 out of 144 signal bit 0 to achieve lock-in\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        # Advanced from STARTED to LOCKED_IN, height = 431\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # 140 more version 4 blocks\n+        test_blocks = self.generate_blocks(140, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+\n+        ### Inputs at height = 572\n+        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Note we reuse inputs for v1 and v2 txs so must test these separately\n+        # 16 normal inputs\n+        bip68inputs = []\n+        for i in xrange(16):\n+            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+        # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112basicinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112basicinputs.append(inputs)\n+        # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112diverseinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112diverseinputs.append(inputs)\n+        # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        # 1 normal input\n+        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n+        self.nodes[0].setmocktime(self.last_block_time + 600)\n+        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        self.nodes[0].setmocktime(0)\n+        self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n+        self.tipheight += 1\n+        self.last_block_time += 600\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+\n+        # 2 more version 4 blocks\n+        test_blocks = self.generate_blocks(2, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # Test both version 1 and version 2 transactions for all tests\n+        # BIP113 test transaction will be modified before each use to put in appropriate block time\n+        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2.nVersion = 2\n+\n+        # For BIP68 test all 16 relative sequence locktimes\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+\n+        # For BIP112 test:\n+        # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        # -1 OP_CSV OP_DROP input\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+\n+\n+        ### TESTING ###\n+        ##################################\n+        ### Before Soft Forks Activate ###\n+        ##################################\n+        # All txs should pass\n+        ### Version 1 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        success_txs.append(bip113signed1)\n+        success_txs.append(bip112tx_special_v1)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        success_txs.append(bip113signed2)\n+        success_txs.append(bip112tx_special_v2)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v2))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n+        test_blocks = self.generate_blocks(1, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        assert_equal(self.get_bip9_status('csv')['status'], 'active')\n+\n+\n+        #################################\n+        ### After Soft Forks Activate ###\n+        #################################\n+        ### BIP 113 ###\n+        # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+        # BIP 113 tests should now pass if the locktime is < MTP\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # Next block height = 580 after 4 blocks of random version\n+        test_blocks = self.generate_blocks(4, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 13\n+\n+        ### BIP 68 ###\n+        ### Version 1 txs ###\n+        # All still pass\n+        success_txs = []\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        bip68success_txs = []\n+        # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n+        bip68timetxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n+        for tx in bip68timetxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+        bip68heighttxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+\n+        # Advance one block to 581\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+\n+        # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n+        bip68success_txs.extend(bip68timetxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+\n+        # Advance one block to 582\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+\n+        # All BIP 68 txs should pass\n+        bip68success_txs.extend(bip68heighttxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        ### BIP 112 ###\n+        ### Version 1 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_v1[0][b25][b22][b18])\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+\n+        ### Version 2 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # All txs with nSequence 11 should fail either due to earlier mismatch or failing the CSV check\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2)) # 16/16 of vary_nSequence_9\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18]) # 16/16 of vary_OP_CSV_9",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57758786",
      "id" : 57758786,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 499,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 499,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:56:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57758786",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57759151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57759151"
         }
      },
      "body" : "nit: I think these two comments should say `# 4/16 ...`",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:58:58Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip68inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        tx.nVersion = txversion\n+                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        signtx = self.sign_transaction(self.nodes[0], tx)\n+        signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        return signtx\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip112inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n+                        else: # vary nSequence instead, OP_CSV is fixed\n+                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        tx.nVersion = txversion\n+                        signtx = self.sign_transaction(self.nodes[0], tx)\n+                        if (varyOP_CSV):\n+                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        else:\n+                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        b18txs.append(signtx)\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def get_tests(self):\n+        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82 # height of the next block to build\n+        self.last_block_time = long_past_time\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+\n+        assert_equal(self.get_bip9_status('csv')['status'], 'defined')\n+        test_blocks = self.generate_blocks(61, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        # Advanced from DEFINED to STARTED, height = 143\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        # Failed to advance past STARTED, height = 287\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # 108 out of 144 signal bit 0 to achieve lock-in\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        # Advanced from STARTED to LOCKED_IN, height = 431\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # 140 more version 4 blocks\n+        test_blocks = self.generate_blocks(140, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+\n+        ### Inputs at height = 572\n+        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Note we reuse inputs for v1 and v2 txs so must test these separately\n+        # 16 normal inputs\n+        bip68inputs = []\n+        for i in xrange(16):\n+            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+        # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112basicinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112basicinputs.append(inputs)\n+        # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112diverseinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112diverseinputs.append(inputs)\n+        # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        # 1 normal input\n+        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n+        self.nodes[0].setmocktime(self.last_block_time + 600)\n+        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        self.nodes[0].setmocktime(0)\n+        self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n+        self.tipheight += 1\n+        self.last_block_time += 600\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+\n+        # 2 more version 4 blocks\n+        test_blocks = self.generate_blocks(2, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # Test both version 1 and version 2 transactions for all tests\n+        # BIP113 test transaction will be modified before each use to put in appropriate block time\n+        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2.nVersion = 2\n+\n+        # For BIP68 test all 16 relative sequence locktimes\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+\n+        # For BIP112 test:\n+        # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        # -1 OP_CSV OP_DROP input\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+\n+\n+        ### TESTING ###\n+        ##################################\n+        ### Before Soft Forks Activate ###\n+        ##################################\n+        # All txs should pass\n+        ### Version 1 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        success_txs.append(bip113signed1)\n+        success_txs.append(bip112tx_special_v1)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        success_txs.append(bip113signed2)\n+        success_txs.append(bip112tx_special_v2)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v2))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n+        test_blocks = self.generate_blocks(1, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        assert_equal(self.get_bip9_status('csv')['status'], 'active')\n+\n+\n+        #################################\n+        ### After Soft Forks Activate ###\n+        #################################\n+        ### BIP 113 ###\n+        # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+        # BIP 113 tests should now pass if the locktime is < MTP\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # Next block height = 580 after 4 blocks of random version\n+        test_blocks = self.generate_blocks(4, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 13\n+\n+        ### BIP 68 ###\n+        ### Version 1 txs ###\n+        # All still pass\n+        success_txs = []\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        bip68success_txs = []\n+        # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n+        bip68timetxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n+        for tx in bip68timetxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+        bip68heighttxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+\n+        # Advance one block to 581\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+\n+        # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n+        bip68success_txs.extend(bip68timetxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+\n+        # Advance one block to 582\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+\n+        # All BIP 68 txs should pass\n+        bip68success_txs.extend(bip68heighttxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        ### BIP 112 ###\n+        ### Version 1 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_v1[0][b25][b22][b18])\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+\n+        ### Version 2 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # All txs with nSequence 11 should fail either due to earlier mismatch or failing the CSV check\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2)) # 16/16 of vary_nSequence_9\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18]) # 16/16 of vary_OP_CSV_9\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 84 - 107\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n+        fail_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18]) # 8/16 of vary_nSequence\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 108-115\n+\n+        # If sequencelock types mismatch, tx should fail\n+        fail_txs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18]) # 12/16 of vary_nSequence\n+                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18]) # 12/16 of vary_OP_CSV",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57759151",
      "id" : 57759151,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 518,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:58:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57759151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57759261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57759261"
         }
      },
      "body" : "nit: I think these two should also say `# 4/16 ...`",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T16:59:36Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import *\n+from binascii import unhexlify\n+import cStringIO\n+import time\n+\n+'''\n+This test is meant to exercise activation of the first version bits soft fork\n+This soft fork will activate the following BIPS:\n+BIP 68  - nSequence relative lock times\n+BIP 112 - CHECKSEQUENCEVERIFY\n+BIP 113 - MedianTimePast semantics for nLockTime\n+\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+\n+mine 82 blocks whose coinbases will be used to generate inputs for our tests\n+mine 61 blocks to transition from DEFINED to STARTED\n+mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n+mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n+mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n+mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n+mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+Test BIP 113 is enforced\n+Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n+Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n+Mine 1 block so next height is 582 and test BIP 68 now passes time and height\n+Test that BIP 112 is enforced\n+\n+Various transactions will be used to test that the BIPs rules are not enforced before the soft fork activates\n+And that after the soft fork activates transactions pass and fail as they should according to the rules.\n+For each BIP, transactions of versions 1 and 2 will be tested.\n+----------------\n+BIP 113:\n+bip113tx - modify the nLocktime variable\n+\n+BIP 68:\n+bip68txs - 16 txs with nSequence relative locktime of 10 with various bits set as per the relative_locktimes below\n+\n+BIP 112:\n+bip112txs_vary_nSequence - 16 txs with nSequence relative_locktimes of 10 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_nSequence_9 - 16 txs with nSequence relative_locktimes of 9 evaluated against 10 OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV - 16 txs with nSequence = 10 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n+bip112tx_special - test negative argument to OP_CSV\n+'''\n+\n+base_relative_locktime = 10\n+seq_disable_flag = 1<<31\n+seq_random_high_bit = 1<<25\n+seq_type_flag = 1<<22\n+seq_random_low_bit = 1<<18\n+\n+# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n+# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n+relative_locktimes = []\n+for b31 in xrange(2):\n+    b25times = []\n+    for b25 in xrange(2):\n+        b22times = []\n+        for b22 in xrange(2):\n+            b18times = []\n+            for b18 in xrange(2):\n+                rlt = base_relative_locktime\n+                if (b31):\n+                    rlt = rlt | seq_disable_flag\n+                if (b25):\n+                    rlt = rlt | seq_random_high_bit\n+                if (b22):\n+                    rlt = rlt | seq_type_flag\n+                if (b18):\n+                    rlt = rlt | seq_random_low_bit\n+                b18times.append(rlt)\n+            b22times.append(b18times)\n+        b25times.append(b22times)\n+    relative_locktimes.append(b25times)\n+\n+def all_rlt_txs(txarray):\n+    txs = []\n+    for b31 in xrange(2):\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    txs.append(txarray[b31][b25][b22][b18])\n+    return txs\n+\n+class BIP68_112_113Test(ComparisonTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def send_generic_input_tx(self, node, coinbases):\n+        amount = Decimal(\"49.99\")\n+        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n+\n+    def create_transaction(self, node, txid, to_address, amount):\n+        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def sign_transaction(self, node, unsignedtx):\n+        rawtx = ToHex(unsignedtx)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = self.create_test_block([], version)\n+            test_blocks.append([block, True])\n+            self.last_block_time += 600\n+            self.tip = block.sha256\n+            self.tipheight += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs, version = 536870912):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n+        block.nVersion = version\n+        block.vtx.extend(txs)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        return block\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip68inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        tx.nVersion = txversion\n+                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def create_bip112special(self, input, txversion):\n+        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        signtx = self.sign_transaction(self.nodes[0], tx)\n+        signtx.vin[0].scriptSig = CScript([-1, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        return signtx\n+\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+        txs = []\n+        assert(len(bip112inputs) >= 16)\n+        i = 0\n+        for b31 in xrange(2):\n+            b25txs = []\n+            for b25 in xrange(2):\n+                b22txs = []\n+                for b22 in xrange(2):\n+                    b18txs = []\n+                    for b18 in xrange(2):\n+                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        i += 1\n+                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n+                        else: # vary nSequence instead, OP_CSV is fixed\n+                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n+                        tx.nVersion = txversion\n+                        signtx = self.sign_transaction(self.nodes[0], tx)\n+                        if (varyOP_CSV):\n+                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        else:\n+                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_NOP3, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+                        b18txs.append(signtx)\n+                    b22txs.append(b18txs)\n+                b25txs.append(b22txs)\n+            txs.append(b25txs)\n+        return txs\n+\n+    def get_tests(self):\n+        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82 # height of the next block to build\n+        self.last_block_time = long_past_time\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+\n+        assert_equal(self.get_bip9_status('csv')['status'], 'defined')\n+        test_blocks = self.generate_blocks(61, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        # Advanced from DEFINED to STARTED, height = 143\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        # Failed to advance past STARTED, height = 287\n+        assert_equal(self.get_bip9_status('csv')['status'], 'started')\n+\n+        # 108 out of 144 signal bit 0 to achieve lock-in\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        # Advanced from STARTED to LOCKED_IN, height = 431\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # 140 more version 4 blocks\n+        test_blocks = self.generate_blocks(140, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+\n+        ### Inputs at height = 572\n+        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Note we reuse inputs for v1 and v2 txs so must test these separately\n+        # 16 normal inputs\n+        bip68inputs = []\n+        for i in xrange(16):\n+            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+        # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112basicinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112basicinputs.append(inputs)\n+        # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112diverseinputs = []\n+        for j in xrange(2):\n+            inputs = []\n+            for i in xrange(16):\n+                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip112diverseinputs.append(inputs)\n+        # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n+        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        # 1 normal input\n+        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n+        self.nodes[0].setmocktime(self.last_block_time + 600)\n+        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        self.nodes[0].setmocktime(0)\n+        self.tip = int(\"0x\" + inputblockhash + \"L\", 0)\n+        self.tipheight += 1\n+        self.last_block_time += 600\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+\n+        # 2 more version 4 blocks\n+        test_blocks = self.generate_blocks(2, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+        assert_equal(self.get_bip9_status('csv')['status'], 'locked_in')\n+\n+        # Test both version 1 and version 2 transactions for all tests\n+        # BIP113 test transaction will be modified before each use to put in appropriate block time\n+        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n+        bip113tx_v2.nVersion = 2\n+\n+        # For BIP68 test all 16 relative sequence locktimes\n+        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n+        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+\n+        # For BIP112 test:\n+        # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n+        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n+        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n+        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n+        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        # -1 OP_CSV OP_DROP input\n+        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n+        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+\n+\n+        ### TESTING ###\n+        ##################################\n+        ### Before Soft Forks Activate ###\n+        ##################################\n+        # All txs should pass\n+        ### Version 1 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        success_txs.append(bip113signed1)\n+        success_txs.append(bip112tx_special_v1)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        success_txs = []\n+        # add BIP113 tx and -1 CSV tx\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        success_txs.append(bip113signed2)\n+        success_txs.append(bip112tx_special_v2)\n+        # add BIP 68 txs\n+        success_txs.extend(all_rlt_txs(bip68txs_v2))\n+        # add BIP 112 with seq=10 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n+        # try BIP 112 with seq=9 txs\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n+        success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n+        test_blocks = self.generate_blocks(1, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        assert_equal(self.get_bip9_status('csv')['status'], 'active')\n+\n+\n+        #################################\n+        ### After Soft Forks Activate ###\n+        #################################\n+        ### BIP 113 ###\n+        # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+        # BIP 113 tests should now pass if the locktime is < MTP\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # = MTP of prior block (not <) but < time put on current block\n+        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        for bip113tx in [bip113signed1, bip113signed2]:\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # Next block height = 580 after 4 blocks of random version\n+        test_blocks = self.generate_blocks(4, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 13\n+\n+        ### BIP 68 ###\n+        ### Version 1 txs ###\n+        # All still pass\n+        success_txs = []\n+        success_txs.extend(all_rlt_txs(bip68txs_v1))\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ### Version 2 txs ###\n+        bip68success_txs = []\n+        # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n+        bip68timetxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n+        for tx in bip68timetxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+        bip68heighttxs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+\n+        # Advance one block to 581\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+\n+        # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n+        bip68success_txs.extend(bip68timetxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        for tx in bip68heighttxs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+\n+        # Advance one block to 582\n+        test_blocks = self.generate_blocks(1, 1234)\n+        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+\n+        # All BIP 68 txs should pass\n+        bip68success_txs.extend(bip68heighttxs)\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+\n+        ### BIP 112 ###\n+        ### Version 1 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_v1[0][b25][b22][b18])\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+\n+        ### Version 2 txs ###\n+        # -1 OP_CSV tx should fail\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+\n+        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n+        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # All txs with nSequence 11 should fail either due to earlier mismatch or failing the CSV check\n+        fail_txs = []\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2)) # 16/16 of vary_nSequence_9\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18]) # 16/16 of vary_OP_CSV_9\n+\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 84 - 107\n+\n+        # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n+        fail_txs = []\n+        for b25 in xrange(2):\n+            for b22 in xrange(2):\n+                for b18 in xrange(2):\n+                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18]) # 8/16 of vary_nSequence\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 108-115\n+\n+        # If sequencelock types mismatch, tx should fail\n+        fail_txs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18]) # 12/16 of vary_nSequence\n+                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18]) # 12/16 of vary_OP_CSV\n+        for tx in fail_txs:\n+            yield TestInstance([[self.create_test_block([tx]), False]]) # 116-123\n+\n+        # Remaining txs should pass, just test masking works properly\n+        success_txs = []\n+        for b25 in xrange(2):\n+            for b18 in xrange(2):\n+                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18]) # 16/16 of vary_nSequence\n+                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18]) # 16/16 of vary_OP_CSV",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57759261",
      "id" : 57759261,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 527,
      "path" : "qa/rpc-tests/bip68-112-113-p2p.py",
      "position" : 527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T16:59:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57759261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "@sdaftuar as explained in  btcdrak#8 the test has a different purpose than bip68-112-113-p2p.py.\r\n\r\nAll bip are generally tested in their own PR, bip68-112-113-p2p.py is doing test that are already done but also testing the sf activation logic. This expand way more than the subject of this PR.\r\n\r\nsoftforks.py has a different purpose, it is here to test ONLY the sf activation logic. This basically mean that in future softfork, you can test the activation correctly by adding a single line at https://github.com/bitcoin/bitcoin/pull/7648/files#diff-98a8abf7f80dbe5eda93bbbbb4348e80R190 .\r\n\r\nFor example, testing any new segwit sf activation will only be a matter of adding a function which change the scriptPubKey to be <version> <segwit program> push. \r\n\r\nThe test is meant to make testing sf soft fork logic activation of future sf a breeze.",
      "created_at" : "2016-03-29T17:12:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203004603",
      "id" : 203004603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T17:14:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203004603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "Guys, no more bikeshedding of `bip9-softforks.py` - it's staying. `bip68-sequence.py` is also a valid part of the mempool-only test suite and should remain in the same way we have bip65 mempool tests. In any case, it's out of scope for this PR.",
      "created_at" : "2016-03-29T17:20:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203008434",
      "id" : 203008434,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T17:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203008434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57762755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57762755"
         }
      },
      "body" : "nit: I think this comment should say `# Check that the new rule is not enforced` ?",
      "commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T17:20:53Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import CScript, OP_1NEGATE, OP_NOP3, OP_DROP\n+from binascii import hexlify, unhexlify\n+import cStringIO\n+import time\n+import itertools\n+\n+'''\n+This test is meant to exercise BIP forks\n+Connect to a single node.\n+regtest lock-in with 108/144 block signalling\n+activation after a further 144 blocks\n+mine 2 block and save coinbases for later use\n+mine 141 blocks to transition from DEFINED to STARTED\n+mine 100 blocks signalling readiness and 44 not in order to fail to change state this period\n+mine 108 blocks signalling readiness and 36 blocks not signalling readiness (STARTED->LOCKED_IN)\n+mine a further 143 blocks (LOCKED_IN)\n+test that enforcement has not triggered (which triggers ACTIVE)\n+test that enforcement has triggered\n+'''\n+\n+\n+\n+class BIP9SoftForksTest(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        self.test = TestManager(self, self.options.tmpdir)\n+        self.test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        self.test.run()\n+\n+    def create_transaction(self, node, coinbase, to_address, amount):\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(rawtx))\n+        tx.deserialize(f)\n+        tx.nVersion = 2\n+        return tx\n+\n+    def sign_transaction(self, node, tx):\n+        signresult = node.signrawtransaction(hexlify(tx.serialize()))\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in xrange(number):\n+            block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n+            block.nVersion = version\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+            self.height += 1\n+        return test_blocks\n+\n+    def get_bip9_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        for row in info['bip9_softforks']:\n+            if row['id'] == key:\n+                return row\n+        raise IndexError ('key:\"%s\" not found' % key)\n+\n+\n+    def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignature):\n+        # generate some coins for later\n+        self.coinbase_blocks = self.nodes[0].generate(2)\n+        self.height = 3  # height of the next block to build\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+        self.last_block_time = time.time()\n+\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'defined')\n+\n+        # Test 1\n+        # Advance from DEFINED to STARTED\n+        test_blocks = self.generate_blocks(141, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n+\n+        # Test 2\n+        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 1\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(50, activated_version) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 4, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n+\n+        # Test 3\n+        # 108 out of 144 signal bit 1 to achieve LOCKED_IN\n+        # using a variety of bits to simulate multiple parallel softforks\n+        test_blocks = self.generate_blocks(58, activated_version) # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 4, test_blocks) # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n+\n+        # Test 4\n+        # 143 more version 536870913 blocks (waiting period-1)\n+        test_blocks = self.generate_blocks(143, 4)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n+\n+        # Test 5\n+        # Check that the new rule is enforced",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#discussion_r57762755",
      "id" : 57762755,
      "original_commit_id" : "71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "original_position" : 135,
      "path" : "qa/rpc-tests/bip9-softforks.py",
      "position" : 135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7648",
      "updated_at" : "2016-03-29T17:20:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57762755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I left some comment nits in the RPC test, `bip68-112-113-p2p.py`, which I reviewed in depth in addition to the rest of the code.  That test is pretty comprehensive, and I think that test coverage had been missing before, so thanks for including that in this pull.\r\n\r\nI also manually tested the case that is mentioned as being missing from `bip68-112-113-p2p.py`, for an OP_CSV with an empty stack.\r\n\r\nACK 71527a0f31ae67edad0a7fcda59c75a6ce5666ca\r\n\r\n@btcdrak To be clear, I'm not talking about removing the entire `bip68-sequence.py` test, just comment out the specific test within that one which is checking that BIP68 is not enforced as a consensus rule.  That test made sense when we were deploying BIP68 as mempool-only, but doesn't make sense when we're proposing it as a soft fork.  See the line of code I linked to above.",
      "created_at" : "2016-03-29T17:28:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203011720",
      "id" : 203011720,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T17:28:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203011720",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "tACK https://github.com/bitcoin/bitcoin/commit/71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-29T18:53:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203048774",
      "id" : 203048774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-29T18:53:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203048774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/998190?v=3",
         "events_url" : "https://api.github.com/users/Roasbeef/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Roasbeef/followers",
         "following_url" : "https://api.github.com/users/Roasbeef/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Roasbeef/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Roasbeef",
         "id" : 998190,
         "login" : "Roasbeef",
         "organizations_url" : "https://api.github.com/users/Roasbeef/orgs",
         "received_events_url" : "https://api.github.com/users/Roasbeef/received_events",
         "repos_url" : "https://api.github.com/users/Roasbeef/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Roasbeef/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Roasbeef/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Roasbeef"
      }
   },
   {
      "body" : "> it's out of scope for this PR.\r\n\r\nIssues with the tests, unless they pinpoint issues in the code, or break Travis, should not hold up this pull. They can be fixed later.",
      "created_at" : "2016-03-30T08:47:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203326436",
      "id" : 203326436,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-30T08:47:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203326436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@petertodd You said in https://github.com/bitcoin/bitcoin/pull/7184#issuecomment-177446433 that you wanted some nits addressed before this (the BIP68 part) would be acceptable as a softfork to you. Could you take a look whether this is the case now?",
      "created_at" : "2016-03-30T11:36:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203389971",
      "id" : 203389971,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-30T11:36:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203389971",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj Those nits got fixed.\r\n\r\nutACK https://github.com/bitcoin/bitcoin/pull/7648/commits/71527a0f31ae67edad0a7fcda59c75a6ce5666ca",
      "created_at" : "2016-03-30T12:08:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203399348",
      "id" : 203399348,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-30T12:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203399348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "utACK 71527a0",
      "created_at" : "2016-03-30T17:00:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7648#issuecomment-203527181",
      "id" : 203527181,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7648",
      "updated_at" : "2016-03-30T17:00:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/203527181",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
