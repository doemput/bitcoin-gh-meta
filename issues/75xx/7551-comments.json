[
   {
      "body" : "Concept ACK",
      "created_at" : "2016-02-17T18:22:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-185334798",
      "id" : 185334798,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-17T18:22:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/185334798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53225824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53225824"
         }
      },
      "body" : "@laanwj should we catch specific exceptions to return the error?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-17T20:24:48Z",
      "diff_hunk" : "@@ -510,3 +534,105 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"\n+            \"Import several types of addresses (private and public keys, transaction addresses/scripts) with only one rescan\\n\"\n+\n+            \"Arguments:\\n\"\n+            \"1. json request array     (json, required) Data to be imported\\n\"\n+            \"  [     (json array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"type\\\": \\\"privkey | pubkey | address\\\", (string, required) Type of address\\n\"\n+            \"      \\\"value\\\": \\\"...\\\",                       (string, required) Value of the address\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                (integer, optional) Timestamp\\n\"\n+            \"      \\\"label\\\": \\\"...\\\"                        (string, optional) Label\\n\"\n+            \"      \\\"p2sh\\\": true | false                    (bool, optional, default=false) Value is a P2SH\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. rescan                 (boolean, optional, default=true)\\n\"\n+\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\", \\\"timestamp\\\":1455191478 },\"\n+                                          \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ]' true\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]' false\") + HelpExampleRpc(\"importmulti\", \"[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\" },\"\n+                                                                                                                                                                                                  \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ], true\") +\n+            HelpExampleRpc(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]', false\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [ { \\\"result\\\": true | false } , ... ]\\n\");\n+\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (params.size() == 1)\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR));\n+    else\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VBOOL));\n+\n+    const UniValue& request = params[0];\n+    bool fRescan = params.size() > 1 ? params[1].get_bool() : true;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        try {\n+            if (nLowestTimestamp > 0) {\n+                int64_t timestamp = data.exists(\"timestamp\") ? data[\"timestamp\"].get_int64() : 0;\n+\n+                if (timestamp < nLowestTimestamp)\n+                    nLowestTimestamp = timestamp;\n+            }\n+\n+            const string& strType = data[\"type\"].get_str();\n+            const string& strValue = data[\"value\"].get_str();\n+            string strLabel = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+            if (strType == \"privkey\")\n+                ImportPrivateKey(strValue, strLabel);\n+            else if (strType == \"pubkey\")\n+                ImportPublicKey(strValue, strLabel);\n+            else if (strType == \"address\") {\n+                bool fP2SH = data.exists(\"p2sh\") ? data[\"p2sh\"].get_bool() : false;\n+                ImportAddressKey(strValue, strLabel, fP2SH);\n+            } else\n+                throw;\n+\n+            result.pushKV(\"result\", UniValue(true));\n+            fRunScan = true;\n+        } catch (...) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53225824",
      "id" : 53225824,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 272,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53225824",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53226022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53226022"
         }
      },
      "body" : "Only this line is necessary because RPCTypeCheck doesn't enforce the length. See implementation.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-17T20:26:18Z",
      "diff_hunk" : "@@ -510,3 +534,105 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"\n+            \"Import several types of addresses (private and public keys, transaction addresses/scripts) with only one rescan\\n\"\n+\n+            \"Arguments:\\n\"\n+            \"1. json request array     (json, required) Data to be imported\\n\"\n+            \"  [     (json array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"type\\\": \\\"privkey | pubkey | address\\\", (string, required) Type of address\\n\"\n+            \"      \\\"value\\\": \\\"...\\\",                       (string, required) Value of the address\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                (integer, optional) Timestamp\\n\"\n+            \"      \\\"label\\\": \\\"...\\\"                        (string, optional) Label\\n\"\n+            \"      \\\"p2sh\\\": true | false                    (bool, optional, default=false) Value is a P2SH\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. rescan                 (boolean, optional, default=true)\\n\"\n+\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\", \\\"timestamp\\\":1455191478 },\"\n+                                          \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ]' true\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]' false\") + HelpExampleRpc(\"importmulti\", \"[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\" },\"\n+                                                                                                                                                                                                  \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ], true\") +\n+            HelpExampleRpc(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]', false\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [ { \\\"result\\\": true | false } , ... ]\\n\");\n+\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (params.size() == 1)\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR));\n+    else\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VBOOL));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53226022",
      "id" : 53226022,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 227,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53226022",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53239448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53239448"
         }
      },
      "body" : "Will fix.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-17T22:09:45Z",
      "diff_hunk" : "@@ -510,3 +534,105 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"\n+            \"Import several types of addresses (private and public keys, transaction addresses/scripts) with only one rescan\\n\"\n+\n+            \"Arguments:\\n\"\n+            \"1. json request array     (json, required) Data to be imported\\n\"\n+            \"  [     (json array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"type\\\": \\\"privkey | pubkey | address\\\", (string, required) Type of address\\n\"\n+            \"      \\\"value\\\": \\\"...\\\",                       (string, required) Value of the address\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                (integer, optional) Timestamp\\n\"\n+            \"      \\\"label\\\": \\\"...\\\"                        (string, optional) Label\\n\"\n+            \"      \\\"p2sh\\\": true | false                    (bool, optional, default=false) Value is a P2SH\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. rescan                 (boolean, optional, default=true)\\n\"\n+\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\", \\\"timestamp\\\":1455191478 },\"\n+                                          \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ]' true\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]' false\") + HelpExampleRpc(\"importmulti\", \"[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\" },\"\n+                                                                                                                                                                                                  \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ], true\") +\n+            HelpExampleRpc(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]', false\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [ { \\\"result\\\": true | false } , ... ]\\n\");\n+\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (params.size() == 1)\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR));\n+    else\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VBOOL));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53239448",
      "id" : 53239448,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 227,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53239448",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53243961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53243961"
         }
      },
      "body" : "What about the second argument be a JSON object? Here it would be `{ \"rescan\": true }`. But it could have more options, for instance, one that would rejects addresses with timestamps belonging to pruned blocks.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-17T22:42:31Z",
      "diff_hunk" : "@@ -510,3 +534,105 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53243961",
      "id" : 53243961,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 194,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53243961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53244140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53244140"
         }
      },
      "body" : "I would move up all auxiliary functions (the ones in title case), then the RPC handlers. WDYT?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-17T22:43:52Z",
      "diff_hunk" : "@@ -72,6 +73,40 @@ std::string DecodeDumpString(const std::string &str) {\n     return ret.str();\n }\n \n+bool ImportPrivateKey(const string& strPrivkey, const string& strLabel)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53244140",
      "id" : 53244140,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 12,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53244140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "concept ACK\r\n\r\nI have implemented a method to also simply just import an spv proof + transaction rather than rescan. Would be nice to include that in this as well. (need to add tests and PR...)",
      "created_at" : "2016-02-18T02:39:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-185516219",
      "id" : 185516219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-18T02:42:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/185516219",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "Concept ACK.\r\nIIRC, this would be the first RPC command that accept a associative array parameter list (`json options (json, optional) Options`). IMO this is good but I would prefer a general way of providing key/value parameters for RPC commands (probably out-of-scope for this PR).",
      "created_at" : "2016-02-18T14:33:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-185747197",
      "id" : 185747197,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-18T14:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/185747197",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53373673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53373673"
         }
      },
      "body" : "This is never used?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-18T20:00:30Z",
      "diff_hunk" : "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+\n+    def check_fee_amount(self, curr_balance, balance_with_fee, fee_per_byte, tx_size):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53373673",
      "id" : 53373673,
      "original_commit_id" : "3f2e87ef7d9e3e6c277511610dd3d99855d83e2b",
      "original_position" : 11,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53373673",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53374368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53374368"
         }
      },
      "body" : "True,  i will remove.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-18T20:05:36Z",
      "diff_hunk" : "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+\n+    def check_fee_amount(self, curr_balance, balance_with_fee, fee_per_byte, tx_size):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53374368",
      "id" : 53374368,
      "original_commit_id" : "3f2e87ef7d9e3e6c277511610dd3d99855d83e2b",
      "original_position" : 11,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53374368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "> IIRC, this would be the first RPC command that accept a associative array parameter list\r\n\r\nI agree. Though I've done a similar thing in #7552. Use positional arguments only for the 'invariant' arguments, and an associative array for everything optional or future-extensible.\r\n\r\nMuch less hassle and confusing than APIs with tons of positional arguments, especially optional ones.\r\n",
      "created_at" : "2016-02-19T09:51:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-186143004",
      "id" : 186143004,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-19T09:52:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/186143004",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@jonasschnelli there is also https://github.com/bitcoin/bitcoin/pull/7518 that accepts options as a JSON object.",
      "created_at" : "2016-02-19T10:29:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-186160708",
      "id" : 186160708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-19T10:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/186160708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53466842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53466842"
         }
      },
      "body" : "IMO should catch the `JSONRPCError` and be included on the response, something like:\r\n```bash\r\noutput: [\r\n  {\r\n    \"result\": true\r\n  },\r\n  {\r\n    \"result\": false,\r\n    \"error\": {\r\n      \"code\": -5,\r\n      \"message\": \"Invalid Bitcoin address\"\r\n    }\r\n  }\r\n]\r\n```\r\nand catch other exceptions as \"missing required fields\" (runtime_error). Also maybe changing from \"result\" to \"success\".",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-02-19T14:33:12Z",
      "diff_hunk" : "@@ -510,3 +534,105 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"\n+            \"Import several types of addresses (private and public keys, transaction addresses/scripts) with only one rescan\\n\"\n+\n+            \"Arguments:\\n\"\n+            \"1. json request array     (json, required) Data to be imported\\n\"\n+            \"  [     (json array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"type\\\": \\\"privkey | pubkey | address\\\", (string, required) Type of address\\n\"\n+            \"      \\\"value\\\": \\\"...\\\",                       (string, required) Value of the address\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                (integer, optional) Timestamp\\n\"\n+            \"      \\\"label\\\": \\\"...\\\"                        (string, optional) Label\\n\"\n+            \"      \\\"p2sh\\\": true | false                    (bool, optional, default=false) Value is a P2SH\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. rescan                 (boolean, optional, default=true)\\n\"\n+\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\", \\\"timestamp\\\":1455191478 },\"\n+                                          \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ]' true\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]' false\") + HelpExampleRpc(\"importmulti\", \"[ { \\\"type\\\":\\\"privkey\\\", \\\"value\\\":\\\"<my private key>\\\" },\"\n+                                                                                                                                                                                                  \"{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191480 } ], true\") +\n+            HelpExampleRpc(\"importmulti\", \"'[{ \\\"type\\\":\\\"pubkey\\\", \\\"value\\\":\\\"<my public key>\\\", \\\"label\\\":\\\"example 1\\\", \\\"timestamp\\\":1455191464 } ]', false\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [ { \\\"result\\\": true | false } , ... ]\\n\");\n+\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (params.size() == 1)\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR));\n+    else\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VBOOL));\n+\n+    const UniValue& request = params[0];\n+    bool fRescan = params.size() > 1 ? params[1].get_bool() : true;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        try {\n+            if (nLowestTimestamp > 0) {\n+                int64_t timestamp = data.exists(\"timestamp\") ? data[\"timestamp\"].get_int64() : 0;\n+\n+                if (timestamp < nLowestTimestamp)\n+                    nLowestTimestamp = timestamp;\n+            }\n+\n+            const string& strType = data[\"type\"].get_str();\n+            const string& strValue = data[\"value\"].get_str();\n+            string strLabel = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+            if (strType == \"privkey\")\n+                ImportPrivateKey(strValue, strLabel);\n+            else if (strType == \"pubkey\")\n+                ImportPublicKey(strValue, strLabel);\n+            else if (strType == \"address\") {\n+                bool fP2SH = data.exists(\"p2sh\") ? data[\"p2sh\"].get_bool() : false;\n+                ImportAddressKey(strValue, strLabel, fP2SH);\n+            } else\n+                throw;\n+\n+            result.pushKV(\"result\", UniValue(true));\n+            fRunScan = true;\n+        } catch (...) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r53466842",
      "id" : 53466842,
      "original_commit_id" : "b974523012c0497862f312d63607d79ebffc471a",
      "original_position" : 272,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/53466842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "GBT also uses an options Object",
      "created_at" : "2016-02-25T11:45:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-188748840",
      "id" : 188748840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-25T11:45:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/188748840",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2016-02-25T23:10:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-189026033",
      "id" : 189026033,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-02-25T23:10:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/189026033",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Replaced the output result from   [ { \"**result**\": true } , ... ] to [ { \"**success**\": true } , ... ].\r\n\r\nIn case of giving a exception should we show any information of the reason in the result? Something like:\r\n[ { \"success\": false , **error** : { \"code\": -5, \"message\": \"Invalid private key encoding\" } } , ... ]\r\n",
      "created_at" : "2016-03-10T14:44:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-194880245",
      "id" : 194880245,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-10T14:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/194880245",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Passing along error messages would be hugely helpful, yes.",
      "created_at" : "2016-03-10T14:51:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-194884014",
      "id" : 194884014,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-10T14:51:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/194884014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "I'll have to defer to others on the value of that. I don't see much value-add personally but unsure.",
      "created_at" : "2016-03-14T15:12:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-196361386",
      "id" : 196361386,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-14T15:12:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/196361386",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559090"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559090"
         }
      },
      "body" : "Nit: only need to initialize 2 nodes",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-17T18:55:28Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559090",
      "id" : 56559090,
      "original_commit_id" : "960f08667bd44e7be7fc074073d3fd73db9ee7a9",
      "original_position" : 13,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559180"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559180"
         }
      },
      "body" : "I don't believe it's necessary to connect the nodes for this test",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-17T18:56:04Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559180",
      "id" : 56559180,
      "original_commit_id" : "960f08667bd44e7be7fc074073d3fd73db9ee7a9",
      "original_position" : 16,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559180",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559211"
         }
      },
      "body" : "See above, no need to connect/sync",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-17T18:56:18Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)\n+        self.is_network_split=False\n+        self.sync_all()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559211",
      "id" : 56559211,
      "original_commit_id" : "960f08667bd44e7be7fc074073d3fd73db9ee7a9",
      "original_position" : 18,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559279"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559279"
         }
      },
      "body" : "Same comment",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-17T18:56:49Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test (self):\n+        import time\n+        begintime = int(time.time())\n+\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(1)\n+\n+        # sync\n+        self.sync_all()\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+        # address\n+        address1 = self.nodes[0].getnewaddress()\n+        # pubkey\n+        address2 = self.nodes[0].getnewaddress()\n+        address2_pubkey = self.nodes[0].validateaddress(address2)['pubkey']                 # Using pubkey\n+        # privkey\n+        address3 = self.nodes[0].getnewaddress()\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        # scriptPubKey\n+        address4 = self.nodes[0].getnewaddress()\n+        address4_scriptpubkey = self.nodes[0].validateaddress(address4)['scriptPubKey']     # Using scriptpubkey\n+\n+\n+        #Check only one address\n+        address_info = self.nodes[0].validateaddress(address1)\n+        assert_equal(address_info['ismine'], True)\n+\n+        self.sync_all()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r56559279",
      "id" : 56559279,
      "original_commit_id" : "960f08667bd44e7be7fc074073d3fd73db9ee7a9",
      "original_position" : 53,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/56559279",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Lightly tested ACK.\r\nI made a few nit comments on the python test. \r\nIf you wanted you could add a test that trying to import a private key and scriptpubKey for the same address fails.",
      "created_at" : "2016-03-17T18:59:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-198034632",
      "id" : 198034632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-17T18:59:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/198034632",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "@mrbandrews Test added.",
      "created_at" : "2016-03-28T13:10:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-202385808",
      "id" : 202385808,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-28T13:10:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202385808",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57571286"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57571286"
         }
      },
      "body" : "Nit: Would be nice to be more verbose here. ~~Maybe move the comment from above into an `AssertionError`?~~\r\n\r\n\r\n\r\nEdit: Also, I don't like the `pass`. Effectively the current try-except is a noop. Am I missing something?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-28T13:31:57Z",
      "diff_hunk" : "@@ -0,0 +1,157 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        import time\n+        begintime = int(time.time())\n+\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(1)\n+        self.nodes[1].generate(1)\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+        # address\n+        address1 = self.nodes[0].getnewaddress()\n+        # pubkey\n+        address2 = self.nodes[0].getnewaddress()\n+        address2_pubkey = self.nodes[0].validateaddress(address2)['pubkey']                 # Using pubkey\n+        # privkey\n+        address3 = self.nodes[0].getnewaddress()\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        # scriptPubKey\n+        address4 = self.nodes[0].getnewaddress()\n+        address4_scriptpubkey = self.nodes[0].validateaddress(address4)['scriptPubKey']     # Using scriptpubkey\n+\n+\n+        #Check only one address\n+        address_info = self.nodes[0].validateaddress(address1)\n+        assert_equal(address_info['ismine'], True)\n+\n+        #Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(),1)\n+\n+        #Address Test - before import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        # import multi\n+        result1 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": address1 , \"label\":\"new account 1\" , \"timestamp\": begintime } ,\n+            { \"type\": PUB_KEY , \"value\": address2_pubkey , \"label\":\"new account 1\", \"timestamp\": begintime},\n+            { \"type\": PRIV_KEY , \"value\": address3_privkey , \"timestamp\": begintime},\n+            { \"type\": SCRIPT_KEY , \"value\": address4_scriptpubkey , \"timestamp\": begintime},\n+            ])\n+\n+        #Addresses Test - after import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], True)\n+        address_info = self.nodes[1].validateaddress(address4)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+\n+        assert_equal(result1[0]['success'], True)\n+        assert_equal(result1[1]['success'], True)\n+        assert_equal(result1[2]['success'], True)\n+        assert_equal(result1[3]['success'], True)\n+\n+        #importmulti without rescan\n+        result2 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() , \"label\":\"random account\" } ,\n+            { \"type\": PUB_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['pubkey'] } ,\n+            { \"type\": SCRIPT_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['scriptPubKey'] },\n+            ], { \"rescan\":False } )\n+\n+        # all succeed\n+        assert_equal(result2[0]['success'], True)\n+        assert_equal(result2[1]['success'], True)\n+        assert_equal(result2[2]['success'], True)\n+        assert_equal(result2[3]['success'], True)\n+        assert_equal(result2[4]['success'], True)\n+\n+        # empty json case\n+        try:\n+            self.nodes[1].importmulti()\n+            raise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57571286",
      "id" : 57571286,
      "original_commit_id" : "7fd4248fa34344ef7d38464be79375b40ca67177",
      "original_position" : 111,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57571286",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57578347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57578347"
         }
      },
      "body" : "This is indeed a noop, please remove the code or replace it with something else. Maybe?\r\n\r\n```diff\r\ndiff --git a/qa/rpc-tests/importmulti.py b/qa/rpc-tests/importmulti.py\r\nindex 845bcfe..243e70e 100755\r\n--- a/qa/rpc-tests/importmulti.py\r\n+++ b/qa/rpc-tests/importmulti.py\r\n@@ -108,7 +108,3 @@ class ImportMultiTest (BitcoinTestFramework):\r\n         # empty json case\r\n-        try:\r\n-            self.nodes[1].importmulti()\r\n-            raise\r\n-        except:\r\n-            pass\r\n+        assert_raises(JSONRPCException, self.nodes[1].importmulti)\r\n \r\n",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-28T14:41:37Z",
      "diff_hunk" : "@@ -0,0 +1,157 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        import time\n+        begintime = int(time.time())\n+\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(1)\n+        self.nodes[1].generate(1)\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+        # address\n+        address1 = self.nodes[0].getnewaddress()\n+        # pubkey\n+        address2 = self.nodes[0].getnewaddress()\n+        address2_pubkey = self.nodes[0].validateaddress(address2)['pubkey']                 # Using pubkey\n+        # privkey\n+        address3 = self.nodes[0].getnewaddress()\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        # scriptPubKey\n+        address4 = self.nodes[0].getnewaddress()\n+        address4_scriptpubkey = self.nodes[0].validateaddress(address4)['scriptPubKey']     # Using scriptpubkey\n+\n+\n+        #Check only one address\n+        address_info = self.nodes[0].validateaddress(address1)\n+        assert_equal(address_info['ismine'], True)\n+\n+        #Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(),1)\n+\n+        #Address Test - before import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        # import multi\n+        result1 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": address1 , \"label\":\"new account 1\" , \"timestamp\": begintime } ,\n+            { \"type\": PUB_KEY , \"value\": address2_pubkey , \"label\":\"new account 1\", \"timestamp\": begintime},\n+            { \"type\": PRIV_KEY , \"value\": address3_privkey , \"timestamp\": begintime},\n+            { \"type\": SCRIPT_KEY , \"value\": address4_scriptpubkey , \"timestamp\": begintime},\n+            ])\n+\n+        #Addresses Test - after import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], True)\n+        address_info = self.nodes[1].validateaddress(address4)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+\n+        assert_equal(result1[0]['success'], True)\n+        assert_equal(result1[1]['success'], True)\n+        assert_equal(result1[2]['success'], True)\n+        assert_equal(result1[3]['success'], True)\n+\n+        #importmulti without rescan\n+        result2 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() , \"label\":\"random account\" } ,\n+            { \"type\": PUB_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['pubkey'] } ,\n+            { \"type\": SCRIPT_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['scriptPubKey'] },\n+            ], { \"rescan\":False } )\n+\n+        # all succeed\n+        assert_equal(result2[0]['success'], True)\n+        assert_equal(result2[1]['success'], True)\n+        assert_equal(result2[2]['success'], True)\n+        assert_equal(result2[3]['success'], True)\n+        assert_equal(result2[4]['success'], True)\n+\n+        # empty json case\n+        try:\n+            self.nodes[1].importmulti()\n+            raise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57578347",
      "id" : 57578347,
      "original_commit_id" : "7fd4248fa34344ef7d38464be79375b40ca67177",
      "original_position" : 111,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57578347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57579066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57579066"
         }
      },
      "body" : "Nit: Some more dead code",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-28T14:47:35Z",
      "diff_hunk" : "@@ -0,0 +1,157 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        import time\n+        begintime = int(time.time())\n+\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(1)\n+        self.nodes[1].generate(1)\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+        # address\n+        address1 = self.nodes[0].getnewaddress()\n+        # pubkey\n+        address2 = self.nodes[0].getnewaddress()\n+        address2_pubkey = self.nodes[0].validateaddress(address2)['pubkey']                 # Using pubkey\n+        # privkey\n+        address3 = self.nodes[0].getnewaddress()\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        # scriptPubKey\n+        address4 = self.nodes[0].getnewaddress()\n+        address4_scriptpubkey = self.nodes[0].validateaddress(address4)['scriptPubKey']     # Using scriptpubkey\n+\n+\n+        #Check only one address\n+        address_info = self.nodes[0].validateaddress(address1)\n+        assert_equal(address_info['ismine'], True)\n+\n+        #Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(),1)\n+\n+        #Address Test - before import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        # import multi\n+        result1 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": address1 , \"label\":\"new account 1\" , \"timestamp\": begintime } ,\n+            { \"type\": PUB_KEY , \"value\": address2_pubkey , \"label\":\"new account 1\", \"timestamp\": begintime},\n+            { \"type\": PRIV_KEY , \"value\": address3_privkey , \"timestamp\": begintime},\n+            { \"type\": SCRIPT_KEY , \"value\": address4_scriptpubkey , \"timestamp\": begintime},\n+            ])\n+\n+        #Addresses Test - after import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], True)\n+        address_info = self.nodes[1].validateaddress(address4)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+\n+        assert_equal(result1[0]['success'], True)\n+        assert_equal(result1[1]['success'], True)\n+        assert_equal(result1[2]['success'], True)\n+        assert_equal(result1[3]['success'], True)\n+\n+        #importmulti without rescan\n+        result2 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() , \"label\":\"random account\" } ,\n+            { \"type\": PUB_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['pubkey'] } ,\n+            { \"type\": SCRIPT_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['scriptPubKey'] },\n+            ], { \"rescan\":False } )\n+\n+        # all succeed\n+        assert_equal(result2[0]['success'], True)\n+        assert_equal(result2[1]['success'], True)\n+        assert_equal(result2[2]['success'], True)\n+        assert_equal(result2[3]['success'], True)\n+        assert_equal(result2[4]['success'], True)\n+\n+        # empty json case\n+        try:\n+            self.nodes[1].importmulti()\n+            raise\n+        except:\n+            pass\n+\n+        # parcial success case\n+        result3 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() },\n+            { \"type\": PUB_KEY },\n+            { \"type\": PUB_KEY , \"value\": \"123456789\"},\n+            ] )\n+\n+        assert_equal(result3[0]['success'], True)\n+        try:    #JSON field \"error\" doesn't exist in success:true\n+            result3[0]['error']\n+            raise\n+        except:\n+            pass",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57579066",
      "id" : 57579066,
      "original_commit_id" : "7fd4248fa34344ef7d38464be79375b40ca67177",
      "original_position" : 127,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57579066",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "Concept ACK",
      "created_at" : "2016-03-28T14:49:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-202423784",
      "id" : 202423784,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-28T14:49:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202423784",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "Needs rebase after #7558",
      "created_at" : "2016-03-29T09:16:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-202794361",
      "id" : 202794361,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-29T09:16:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202794361",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57741191"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57741191"
         }
      },
      "body" : "Yes.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-03-29T15:15:39Z",
      "diff_hunk" : "@@ -0,0 +1,157 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        import time\n+        begintime = int(time.time())\n+\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(1)\n+        self.nodes[1].generate(1)\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+        # address\n+        address1 = self.nodes[0].getnewaddress()\n+        # pubkey\n+        address2 = self.nodes[0].getnewaddress()\n+        address2_pubkey = self.nodes[0].validateaddress(address2)['pubkey']                 # Using pubkey\n+        # privkey\n+        address3 = self.nodes[0].getnewaddress()\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        # scriptPubKey\n+        address4 = self.nodes[0].getnewaddress()\n+        address4_scriptpubkey = self.nodes[0].validateaddress(address4)['scriptPubKey']     # Using scriptpubkey\n+\n+\n+        #Check only one address\n+        address_info = self.nodes[0].validateaddress(address1)\n+        assert_equal(address_info['ismine'], True)\n+\n+        #Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(),1)\n+\n+        #Address Test - before import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+        # import multi\n+        result1 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": address1 , \"label\":\"new account 1\" , \"timestamp\": begintime } ,\n+            { \"type\": PUB_KEY , \"value\": address2_pubkey , \"label\":\"new account 1\", \"timestamp\": begintime},\n+            { \"type\": PRIV_KEY , \"value\": address3_privkey , \"timestamp\": begintime},\n+            { \"type\": SCRIPT_KEY , \"value\": address4_scriptpubkey , \"timestamp\": begintime},\n+            ])\n+\n+        #Addresses Test - after import\n+        address_info = self.nodes[1].validateaddress(address1)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address2)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+        address_info = self.nodes[1].validateaddress(address3)\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], True)\n+        address_info = self.nodes[1].validateaddress(address4)\n+        assert_equal(address_info['iswatchonly'], True)\n+        assert_equal(address_info['ismine'], False)\n+\n+        assert_equal(result1[0]['success'], True)\n+        assert_equal(result1[1]['success'], True)\n+        assert_equal(result1[2]['success'], True)\n+        assert_equal(result1[3]['success'], True)\n+\n+        #importmulti without rescan\n+        result2 = self.nodes[1].importmulti( [\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() } ,\n+            { \"type\": ADDRESS_KEY, \"value\": self.nodes[0].getnewaddress() , \"label\":\"random account\" } ,\n+            { \"type\": PUB_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['pubkey'] } ,\n+            { \"type\": SCRIPT_KEY, \"value\": self.nodes[0].validateaddress(self.nodes[0].getnewaddress())['scriptPubKey'] },\n+            ], { \"rescan\":False } )\n+\n+        # all succeed\n+        assert_equal(result2[0]['success'], True)\n+        assert_equal(result2[1]['success'], True)\n+        assert_equal(result2[2]['success'], True)\n+        assert_equal(result2[3]['success'], True)\n+        assert_equal(result2[4]['success'], True)\n+\n+        # empty json case\n+        try:\n+            self.nodes[1].importmulti()\n+            raise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r57741191",
      "id" : 57741191,
      "original_commit_id" : "7fd4248fa34344ef7d38464be79375b40ca67177",
      "original_position" : 111,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/57741191",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "> Nit: Would be nice to be more verbose here.\r\n\r\n@MarcoFalke What do you suggest?\r\n\r\n@laanwj Rebased.",
      "created_at" : "2016-03-29T15:30:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-202955265",
      "id" : 202955265,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-03-29T15:30:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/202955265",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "@laanwj Are you considering merging this soon?",
      "created_at" : "2016-04-04T15:31:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-205351792",
      "id" : 205351792,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-04T15:31:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/205351792",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Sorry for the very late response here, but I think it's undesirable to have the \"p2sh\" flag in this call. The fact that it's present in importscript is historical, but quite confusing I think (see #7687).\r\n\r\nHere is what happens:\r\n\r\n> importaddress \"script\" p2sh=false\r\n\r\nwill mark scriptPubKeys that exactly match script as ismine, but without the ability to spend them, and there is no address added to the wallet (so it will likely be treated as change by the wallet, though show up in listunspent).\r\n\r\n> importaddress \"script\" p2sh=true\r\n\r\nWill do the same as the call above, AND also add script as a known script to the keystore, meaning that it will start treating scriptPubKeys that send to P2SH(script) as ismine too, AND in addition associate the passed label with that P2SH address (but not with the raw script).\r\n\r\n> importaddress \"address\"\r\n\r\nWill mark scriptPubKeys that match the exact script corresponding to address as ismine, AND associate the passed label with it.\r\n\r\n--\r\n\r\nThere is a much cleaner distinction here, where importing of scripts and importing of addresses is completely separate. That would mean that where you'd use import script p2sh=true, instead, you'd import both a script and an address.",
      "created_at" : "2016-04-14T09:40:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-209852807",
      "id" : 209852807,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-14T09:40:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/209852807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r59690445"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/59690445"
         }
      },
      "body" : "nit formating:\r\n```\r\n    {\r\n      \"type\": \"privkey | pubkey | address | script\", (string, required) Type of address\r\n      \"value\": \"...\",                                (string, required) Value of the address\r\n      \"timestamp\": 1454686740,                         (integer, optional) Timestamp\r\n      \"label\": \"...\"                                 (string, optional) Label\r\n      \"p2sh\": true | false                             (bool, optional, default=false) Value is a P2SH (type=script only)\r\n    }\r\n```",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-04-14T09:54:26Z",
      "diff_hunk" : "@@ -615,3 +651,119 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[{\\\"type\\\":\\\"privkey\\\",\\\"value\\\":\\\"mkjjX...\\\"},...]' (rescan) \\n\\n\"\n+            \"Import several types of addresses (private and public keys, transaction addresses/scripts) with only one rescan\\n\"\n+\n+            \"Arguments:\\n\"\n+            \"1. json request array     (json, required) Data to be imported\\n\"\n+            \"  [     (json array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"type\\\": \\\"privkey | pubkey | address | script\\\", (string, required) Type of address\\n\"\n+            \"      \\\"value\\\": \\\"...\\\",                                (string, required) Value of the address\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                         (integer, optional) Timestamp\\n\"\n+            \"      \\\"label\\\": \\\"...\\\"                                 (string, optional) Label\\n\"\n+            \"      \\\"p2sh\\\": true | false                             (bool, optional, default=false) Value is a P2SH (type=script only)\\n\"\n+            \"    }\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r59690445",
      "id" : 59690445,
      "original_commit_id" : "90b6183fa8e49dcaf89ac0be0bbff9b759e4f75c",
      "original_position" : 219,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/59690445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "To add some more background: ultimately, there are 3 internal calls that can be issued:\r\n\r\n* AddCScript(redeemscript) allows the wallet to construct scriptSigs for scriptPubKeys that send to P2SH(redeemscript). This only affects ismine when redeemscript itself can be signed for.\r\n* AddWatchOnly(scriptPubKey) marks a particular scriptPubKey as unconditionally ismine (whether we know how to construct a scriptSig for such an output or not).\r\n* SetAddressBook(destination) marks outputs set to a scriptPubKey that matches destination as 'incoming payment' with a label (rather than our own change). Unfortunately, that does not work for arbitrary scriptPubKeys, only P2SH or P2PKH ones.\r\n\r\nSo right now, importaddress \"script\" p2sh=true calls AddWatchOnly(script), AddCScript(script), SetAddressBook(P2SH(script)). This is a bit inconsistent, as it has effects on outputs. paying to script directly and through P2SH\r\n",
      "created_at" : "2016-04-14T09:57:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-209858703",
      "id" : 209858703,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-14T09:57:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/209858703",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2016-04-14T10:51:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-209877337",
      "id" : 209877337,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-14T10:51:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/209877337",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "body" : "@sipa Thanks for the explanation. I've added p2sh support only because `importaddress` rpc call already had it. Do you agree that we should remove _p2sh_ flag from `importmulti` call?",
      "created_at" : "2016-04-18T12:26:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-211357809",
      "id" : 211357809,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-18T12:26:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/211357809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Maybe I'm misunderstanding this, but I think the type should fully specify what kind of object is imported:\r\n```\r\n      \"type\": \"privkey | pubkey | address | script\", (string, required) Type of address\r\n```\r\nThis makes an extra P2SH flag redundant.\r\n",
      "created_at" : "2016-04-25T13:30:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214328723",
      "id" : 214328723,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-25T13:30:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214328723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "script is ambiguous: it can mean \"i'm importing this script, so that when it is used as a P2SH redeemscript, the client knows how to sign it\", or \"i want outputs spending to this exact script to be counting towards my balance and listunspent\".",
      "created_at" : "2016-04-25T13:33:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214330051",
      "id" : 214330051,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-25T13:33:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214330051",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Then add a different type for either case?\r\n",
      "created_at" : "2016-04-25T13:34:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214330364",
      "id" : 214330364,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-25T13:34:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214330364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "eh, the  \"i'm importing this script, so that when it is used as a P2SH redeemscript, the client knows how to sign it\" case probably doesn't belong here at all, as it relates to signing and doesn't affect the balance/rescan?",
      "created_at" : "2016-04-25T13:36:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214330859",
      "id" : 214330859,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-25T13:36:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214330859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj It does, because if that script itself uses keys that are known to the wallet, it will make such outputs be considered spendable.",
      "created_at" : "2016-04-25T13:38:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214331463",
      "id" : 214331463,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-04-25T13:38:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214331463",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "I'm sorry for just mentioning some background and complaints, and not offering a good solution. But I think we have a mess that is caused by having half a dozen different ways through which a script can be considered spendable/solvable/ismine, and having magic import commands with many edge cases (like importaddress now) that just try to do as much as possible, and we should not maintain that in newer APIs.\r\n\r\nOne solution is to break it down to the lowest-level CKeyStore changes, and providing a means to individually add:\r\n* privkey (which helps spendability, causing outputs always to be treated as ismine)\r\n* pubkeys/redeemscripts (which helps solvability, and if that indirectly leads to a spendable script, it causes outputs to be treated as ismine)\r\n* watched scripts (which always causes outputs to be treated as ismine, regardless of spendability)\r\n* labels (which makes the wallet treat such transactions as incoming funds, which is only possible for scripts that map to a CTxDestination)\r\n\r\nHowever, it would be highly inconvenient to use (you'd sometimes need 3 separate entries to get the behaviour of a single call now).\r\n\r\nHere is a proposal, but it's quite a bit different from the existing design: the input is a list of Objects, each of which has the following keys:\r\n* **output** _mandatory string_ an address or a hex-encoded script, describing exactly what outputs we're talking about, this is mandatory\r\n* **redeemscript** _optional string_ and only allowed if the address is a P2SH address or a P2SH scriptPubKey, and it must correspond to that output.\r\n* **pubkeys** _optional array of strings_ giving pubkeys that must occur in the output or redeemscript\r\n* **keys**: _optional array of strings_, giving private keys whose corresponding public keys must occur in the output or redeemscript\r\n* **internal** _optional bool_ (default false) stating whether matching outputs should be be treated as not incoming payments. Must be explicitly set to false for outputs that don't have a corresponding CTxDestination (so a warning/error can be given)\r\n* **watchonly** _optional bool_ (default false) stating whether matching outputs should be considered watched even when they're not spendable. If this is not given, importing this entry must result in the specified outputs becoming spendable.\r\n* **label** _optional string_ (default \"\" if internal=false, none if internal=true) to assign to the address (aka account name, for now), only allowed with internal=false\r\n* **timestamp** as now (though perhaps we should consider that the timestamp for an individual key should be stored in mapKeyMetaData, and not just in nTimeFirstKey.\r\n\r\nThis is a bit redundant and less convenient (it always requires specifying a script or address, and either keys), but I think it allows for very accurate error messages whenever the behaviour wouldn't match the user's expectations. It also makes it obvious where the current codebase's restrictions are (you can't make a non-standard scriptPubKey non-internal, only individual keys can be assigned a birth time, ...), which can be loosened in future iterations if those restrictions are solved.\r\n\r\nOpen for discussion of course!",
      "created_at" : "2016-04-25T15:32:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-214397377",
      "id" : 214397377,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-25T13:57:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214397377",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa thanks for these insights!\r\n\r\nTotally agree with @sipa regarding the object keys. Specially because there is no `type` key Ã°ÂÂÂ  With these keys we can be sure the caller knows his business.",
      "created_at" : "2016-05-02T13:41:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-216237814",
      "id" : 216237814,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-02T13:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216237814",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "@sipa replace `output` by `scriptPubKey` ?",
      "created_at" : "2016-05-02T13:47:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-216239765",
      "id" : 216239765,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-02T13:47:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216239765",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "@promag I considered that, but if it's an address, it's not really a scriptPubKey (especially if there is ever support for things like stealth addresses (which contain cryptographic information that never actually directly ends up in the scriptPubKey).\r\n\r\nPerhaps there should be two separate fields, address or scriptPubKey, and you're required to exactly provide one of them.",
      "created_at" : "2016-05-02T13:52:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-216241719",
      "id" : 216241719,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-02T13:52:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216241719",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa ACK and thanks for the proposal. \r\n\r\nAlso, when calling with the private keys and `watchonly=true`. Should we throw an error / warn the user that he should use pubkeys instead if he wants watch-only? Or should we allow importing private keys in watch-only (deriving the pubkey)?",
      "created_at" : "2016-05-02T14:59:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-216259403",
      "id" : 216259403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-02T14:59:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216259403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r62308037"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62308037"
         }
      },
      "body" : "Mind to change this to py3?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-05-06T09:37:36Z",
      "diff_hunk" : "@@ -0,0 +1,147 @@\n+#!/usr/bin/env python2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r62308037",
      "id" : 62308037,
      "original_commit_id" : "90b6183fa8e49dcaf89ac0be0bbff9b759e4f75c",
      "original_position" : 1,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62308037",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r62310701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62310701"
         }
      },
      "body" : "Sure.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-05-06T10:04:12Z",
      "diff_hunk" : "@@ -0,0 +1,147 @@\n+#!/usr/bin/env python2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r62310701",
      "id" : 62310701,
      "original_commit_id" : "90b6183fa8e49dcaf89ac0be0bbff9b759e4f75c",
      "original_position" : 1,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62310701",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Can one of the admins verify this patch?",
      "created_at" : "2016-05-25T08:44:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-221510707",
      "id" : 221510707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-25T08:44:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221510707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/541066?v=3",
         "events_url" : "https://api.github.com/users/arowser/events{/privacy}",
         "followers_url" : "https://api.github.com/users/arowser/followers",
         "following_url" : "https://api.github.com/users/arowser/following{/other_user}",
         "gists_url" : "https://api.github.com/users/arowser/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/arowser",
         "id" : 541066,
         "login" : "arowser",
         "organizations_url" : "https://api.github.com/users/arowser/orgs",
         "received_events_url" : "https://api.github.com/users/arowser/received_events",
         "repos_url" : "https://api.github.com/users/arowser/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/arowser/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/arowser/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/arowser"
      }
   },
   {
      "body" : "> @promag I considered that, but if it's an address, it's not really a scriptPubKey (especially if there is ever support for things like stealth addresses (which contain cryptographic information that never actually directly ends up in the scriptPubKey).\r\n\r\n@sipa maybe we could go with:\r\n - `{ \"scriptPubKey\": <script> }`\r\n - `{ \"scriptPubKey\": { \"address\": <address> } }`\r\n\r\nIt's scalable and unambiguous. WDYT?",
      "created_at" : "2016-05-25T09:27:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-221520641",
      "id" : 221520641,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-25T09:27:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221520641",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "@arowser this is still work in progress.",
      "created_at" : "2016-05-25T09:28:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-221520830",
      "id" : 221520830,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-25T09:28:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221520830",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "@promag Looks good to me.",
      "created_at" : "2016-05-25T13:57:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-221584090",
      "id" : 221584090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-05-25T13:57:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221584090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "As this is very often requested functionality I'd really like to get this in for 0.13.\r\n\r\nNote that the deadline for features for 0.13 is June 16, so that would mean we'll have to get it to a mergeable state in a week. Is that realistic?\r\n",
      "created_at" : "2016-06-08T12:04:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-224569219",
      "id" : 224569219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-08T12:04:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224569219",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj Yes, i think is realistic.",
      "created_at" : "2016-06-08T13:54:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-224595950",
      "id" : 224595950,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-08T13:54:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224595950",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Ping...",
      "created_at" : "2016-06-13T09:24:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-225530834",
      "id" : 225530834,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-13T09:24:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225530834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj I'm working on this with @promag and we'll try to push a solution as fastest as we can (probably by tomorrow). ",
      "created_at" : "2016-06-13T11:43:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-225558326",
      "id" : 225558326,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-13T11:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225558326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "@laanwj We have a partial solution but is not complete: \r\n- Does not checks the consistency between private/pub keys and scriptPubKey / redeemScript.\r\n- Does not support **internal** and **watchonly** modes.\r\n\r\nWe've made a major refactor and unfortunately we think we are late for the 0.13 milestone.",
      "created_at" : "2016-06-15T10:21:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-226147551",
      "id" : 226147551,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-15T10:21:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226147551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67231396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67231396"
         }
      },
      "body" : "Could you use `__init__` for that, instead of overwriting `setup_chain`?\r\n\r\nI.e. something like\r\n```py\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.num_nodes = 2\r\n        self.setup_clean_chain = True",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-06-15T19:41:53Z",
      "diff_hunk" : "@@ -0,0 +1,214 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67231396",
      "id" : 67231396,
      "original_commit_id" : "8255b35f6cce36d4ce97e5cc7332ce2e07bbc42e",
      "original_position" : 12,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67231396",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314202"
         }
      },
      "body" : "Sure, and looks way better.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-06-16T09:28:44Z",
      "diff_hunk" : "@@ -0,0 +1,214 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314202",
      "id" : 67314202,
      "original_commit_id" : "8255b35f6cce36d4ce97e5cc7332ce2e07bbc42e",
      "original_position" : 12,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314202",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314744"
         }
      },
      "body" : "micro-Nit: missing trailing `,`",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-06-16T09:32:34Z",
      "diff_hunk" : "@@ -137,6 +137,7 @@\n     'p2p-versionbits-warning.py',\n     'importprunedfunds.py',\n     'signmessages.py',\n+    'importmulti.py'",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314744",
      "id" : 67314744,
      "original_commit_id" : "8255b35f6cce36d4ce97e5cc7332ce2e07bbc42e",
      "original_position" : 4,
      "path" : "qa/pull-tester/rpc-tests.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314818"
         }
      },
      "body" : "Nit: Might as well place this in the header",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-06-16T09:33:01Z",
      "diff_hunk" : "@@ -0,0 +1,214 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        import time",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r67314818",
      "id" : 67314818,
      "original_commit_id" : "8255b35f6cce36d4ce97e5cc7332ce2e07bbc42e",
      "original_position" : 19,
      "path" : "qa/rpc-tests/importmulti.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67314818",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "Looks good to me - utACK https://github.com/bitcoin/bitcoin/pull/7551/commits/d72a88616f3ad0578ca6e6d8f025db5574f9bf07\r\n\r\n> Does not support internal and watchonly modes.\r\n\r\nSeems acceptable for a first version, it's not documented either so that's consistent.\r\n\r\n> We've made a major refactor and unfortunately we think we are late for the 0.13 milestone.\r\n\r\nI'm afraid so too, if we would merge it now it would be very last-minute, I don't think this code is well-tested enough. Code does get more testing on master, but so close to a release it's more risky, we don't want to release with something broken.\r\n",
      "created_at" : "2016-06-20T13:51:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-227147704",
      "id" : 227147704,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-20T13:51:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/227147704",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "> Code does get more testing on master, but so close to a release it's more risky, we don't want to release with something broken.\r\n\r\nI totally agree.\r\n\r\nStill we need help on how to implement internal mode and watch-only, and the consistency checking (technical doubts, so we'll need to do some researching).",
      "created_at" : "2016-06-20T14:29:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-227158766",
      "id" : 227158766,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-20T14:29:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/227158766",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "I promise to help with this (nag me if I forget), but after 0.13 is\nbranched off.\n",
      "created_at" : "2016-06-20T14:31:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-227159303",
      "id" : 227159303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-20T14:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/227159303",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> I promise to help with this (nag me if I forget), but after 0.13 is\r\nbranched off.\r\n\r\nThanks for the support.\r\n\r\n\r\nI have some doubts about the expected result in some situations:\r\n - When we have private keys on `keys` and `watch-only=true` what should we do:\r\n    - import the public key of each given key?\r\n    - import the private key and mark it somehow to unspentable / watchable only?\r\n - The watch-only concept should not import and save any private key, @sipa agree?\r\n\r\nAbout the internal concept I'm a bit confused on how it should work.",
      "created_at" : "2016-06-20T14:56:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-227166998",
      "id" : 227166998,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-20T14:56:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/227166998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "@pedrobranco Removing the 0.13 milestone then - thanks for your patience!",
      "created_at" : "2016-06-21T08:32:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-227375014",
      "id" : 227375014,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-06-21T08:32:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/227375014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "I think if private keys are given and watchonly, you should fail. The reason for the watchonly option is to indicate that you intentionally are not providing a private key, and are not expecting the ability to spend. It's there so that if someone just forgets to provide a private key (as opposed to making it intentionally watch-only), the call can warn them by failing.\r\n\r\nThe internal concept is similar to watchonly. When it is present, you're not adding the address to the addressbook (so no label, not even an empty label). This makes it incompatible with the label option. But also for example, when the scriptPubKey is given in hex form and not in a standard type that can be internally converted to a CTxDestination, internal _must_ be set, as there would be no way to add it to the address book (at this point).\r\n",
      "created_at" : "2016-07-01T10:04:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-229909250",
      "id" : 229909250,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-07-01T10:07:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/229909250",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Consistency check added + internal + watchonly.",
      "created_at" : "2016-07-18T17:12:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-233393881",
      "id" : 233393881,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-07-18T17:12:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/233393881",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Can someone please review the PR?",
      "created_at" : "2016-07-28T09:31:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-235846198",
      "id" : 235846198,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-07-28T09:31:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/235846198",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Will test today.",
      "created_at" : "2016-07-28T09:32:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-235846431",
      "id" : 235846431,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-07-28T09:32:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/235846431",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72596015"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72596015"
         }
      },
      "body" : "Using c++11 lambda here?\r\n\r\nSomething like:\r\n```c++\r\nstd::lower_bound(vChain.begin(), vChain.end(), nTime,\r\n   [](CBlockIndex* pBlock, const int64_t& time) -> bool { return pBlock->GetBlockTime() < time; }\r\n);\r\n```\r\n\r\nWould probably be less confusing to read.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-28T10:03:20Z",
      "diff_hunk" : "@@ -61,6 +61,20 @@ const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n     return pindex;\n }\n \n+\n+struct SmallerThanTimestamp {\n+    bool operator()(CBlockIndex* pBlock, const int64_t& time) const\n+    {\n+        return pBlock->GetBlockTime() < time;\n+    }\n+};\n+\n+CBlockIndex* CChain::FindLatestBefore(int64_t nTime) const\n+{\n+    std::vector<CBlockIndex*>::const_iterator lower = std::lower_bound(vChain.begin(), vChain.end(), nTime, SmallerThanTimestamp());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72596015",
      "id" : 72596015,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 14,
      "path" : "src/chain.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72596015",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72596877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72596877"
         }
      },
      "body" : "Are you sure this is correct?\r\nI can't see a link between the input timestamp and `nLowestTimestamp`.\r\nIn case of a rescan, `nLowestTimestamp` is always `chainActive.Tip()->GetBlockTime()` which is incorrect IMO.\r\n\r\nAlso, we should add a time- or block-delta between `nLowestTimestamp` and the actual rescan height. Timestamps could be slightly wrong (timezones, failed implementations, accuracy). Maybe we should go down another 144 blocks.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-28T10:10:47Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        const UniValue result = processImport(data);\n+        response.push_back(result);\n+    }\n+\n+    if (fRescan && fRunScan && request.size()) {\n+        CBlockIndex* pindex = nLowestTimestamp > 0 ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72596877",
      "id" : 72596877,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 379,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72596877",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72598662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72598662"
         }
      },
      "body" : "To bad we need to hold `cs_main` for this. But I think its not possible without it with the current lock structure.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-28T10:25:47Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        const UniValue result = processImport(data);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72598662",
      "id" : 72598662,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 374,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72598662",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72598900"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72598900"
         }
      },
      "body" : "nit: `;` can be removed;\r\nmini-nit: You are using \"ifs without brackets\" together with some \"ifs with brackets\".",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-28T10:27:55Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72598900",
      "id" : 72598900,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 141,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72598900",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72674539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72674539"
         }
      },
      "body" : "`fRunScan` is always `false` which result in never triggering a rescan.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-28T18:21:10Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72674539",
      "id" : 72674539,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 363,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 389,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72674539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "The rescan behavior seems not to work, I'm happy to test again once this is fixed.\r\nWe really want to have importmulti in 0.14.",
      "created_at" : "2016-07-28T18:22:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-235981345",
      "id" : 235981345,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-07-28T18:22:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/235981345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72774244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72774244"
         }
      },
      "body" : "I will check if any of the requests returns `success=true`, then allow the rescan (fRunScan  = true) if not disabled via options.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-29T10:47:47Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72774244",
      "id" : 72774244,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 363,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 389,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72774244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72775727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72775727"
         }
      },
      "body" : "It was left out in this latest proposal, so I will fix that. \r\n\r\n> Maybe we should go down another 144 blocks.\r\n\r\nI'm not quite sure about rescanning in a different timestamp that the user specifies, given that he knows what's he doing. Is there any reason for the 144 blocks?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-29T11:03:42Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        const UniValue result = processImport(data);\n+        response.push_back(result);\n+    }\n+\n+    if (fRescan && fRunScan && request.size()) {\n+        CBlockIndex* pindex = nLowestTimestamp > 0 ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72775727",
      "id" : 72775727,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 379,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72775727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72779705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72779705"
         }
      },
      "body" : "I think that is **not** correct.\r\nThere are two appearance of the variable `fRunScan`, one on L977 (`bool fRunScan = false;`) and one on L992 (`if (fRescan && fRunScan && request.size()) {`).\r\n\r\nI can't see a code part where fRunScan will be set to `true`.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-29T11:49:08Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72779705",
      "id" : 72779705,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 363,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 389,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72779705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72779789"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72779789"
         }
      },
      "body" : "144 blocks = 1day. I think going back/deeper one day is reasonable.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-29T11:50:10Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp = 0;\n+\n+    if (fRescan && chainActive.Tip())\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    else\n+        fRescan = false;\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        const UniValue result = processImport(data);\n+        response.push_back(result);\n+    }\n+\n+    if (fRescan && fRunScan && request.size()) {\n+        CBlockIndex* pindex = nLowestTimestamp > 0 ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72779789",
      "id" : 72779789,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 379,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72779789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72788960"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72788960"
         }
      },
      "body" : "What I have meant in the comment is that after pushing the fix it it will do what I've described:\r\n>I will check if any of the requests returns success=true, then allow the rescan (fRunScan = true) if not disabled via options.\r\n",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-07-29T13:15:08Z",
      "diff_hunk" : "@@ -622,3 +623,380 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE)\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+            // add to address book or update label\n+            if (address.IsValid())\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood)\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid())\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress))\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    ;\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey))\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid())\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood)\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid())\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress))\n+                    return false;\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid())\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+        if (options.exists(\"rescan\"))\n+            fRescan = options[\"rescan\"].get_bool();\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r72788960",
      "id" : 72788960,
      "original_commit_id" : "783220876027a20e9f91d7afc753bb9b036edb02",
      "original_position" : 363,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 389,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/72788960",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "@jonasschnelli Can you please test the rescan behavior?",
      "created_at" : "2016-08-03T09:31:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-237189631",
      "id" : 237189631,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-08-03T09:31:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/237189631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r73545904"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73545904"
         }
      },
      "body" : "I guess `nLowestTimestamp` is always > 0.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-08-04T15:34:19Z",
      "diff_hunk" : "@@ -644,3 +645,424 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, request.getValues()) {\n+        const UniValue result = processImport(data);\n+        response.push_back(result);\n+\n+        if (!fRescan) {\n+            continue;\n+        }\n+\n+        // If at least one request was successful then allow rescan.\n+        if (result[\"success\"].get_bool()) {\n+            fRunScan = true;\n+        }\n+\n+        // Get the lowest timestamp.\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        if (timestamp > 1 && timestamp < nLowestTimestamp) {\n+            nLowestTimestamp = timestamp;\n+        }\n+    }\n+\n+    if (fRescan && fRunScan && request.size()) {\n+        CBlockIndex* pindex = nLowestTimestamp > 0 ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r73545904",
      "id" : 73545904,
      "original_commit_id" : "51fd0d6a61efc0cd4fdce951d5c41aeddc7932ce",
      "original_position" : 423,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73545904",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "What needs to be done here?",
      "created_at" : "2016-09-09T10:17:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-245875699",
      "id" : 245875699,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-09-09T10:17:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/245875699",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "> What needs to be done here?\r\n\r\nMaybe add some tests for the rescan feature.",
      "created_at" : "2016-09-09T11:03:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-245883916",
      "id" : 245883916,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-09-09T11:03:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/245883916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Personally, I don't know the opinion of others, I'd really like to move forward and merge this if the base functionality is agreed on. There is still enough time before 0.14 to fix problems, add tests, add features etc.",
      "created_at" : "2016-09-19T14:03:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-248001959",
      "id" : 248001959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-09-19T14:03:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/248001959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80929574"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80929574"
         }
      },
      "body" : "nit: using `chainActive.Tip()`s blocktime with the later `FindLatestBefore(nLowestTimestamp)` will probably always result in re-scaning a couple 1-2 blocks when importing with a timestamp in future.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:28:30Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80929574",
      "id" : 80929574,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 395,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 394,
      "pull_request_review_id" : 1947473,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80929574",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80930561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80930561"
         }
      },
      "body" : "This `else` should be removed because it can only set a already `false` `fRescan` again to `false`.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:32:01Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80930561",
      "id" : 80930561,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 398,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 397,
      "pull_request_review_id" : 1948432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80930561",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80933944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80933944"
         }
      },
      "body" : "`fRescan` is initially set to `true`.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:44:38Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80933944",
      "id" : 80933944,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 398,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 397,
      "pull_request_review_id" : 1951605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80933944",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80934414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80934414"
         }
      },
      "body" : "Argh. Your right. Got fooled by `fRunScan`, `fRescan`.\r\nNevermind then.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:46:26Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80934414",
      "id" : 80934414,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 398,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 397,
      "pull_request_review_id" : 1952048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80934414",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80936636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80936636"
         }
      },
      "body" : "We can prevent rescanning if `nLowestTimestamp` is in the future:\r\n\r\n```cpp\r\nif (fRescan && fRunScan && request.size() && nLowestTimestamp <= chainActive.Tip()->GetBlockTime()) {\r\n(...)\r\n```",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:54:46Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80936636",
      "id" : 80936636,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 395,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 394,
      "pull_request_review_id" : 1954084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80936636",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80937273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80937273"
         }
      },
      "body" : "No problem @jonasschnelli .",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-09-28T14:57:06Z",
      "diff_hunk" : "@@ -644,3 +645,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const UniValue& params, bool fHelp)\n+{\n+    // clang-format off\n+    if (fHelp || params.size() < 1 || params.size() > 2) {\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+    }\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& request = params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (params.size() > 1) {\n+        const UniValue& options = params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r80937273",
      "id" : 80937273,
      "original_commit_id" : "1bcc021f7c27d605dbecebdcb40e0657a1501be2",
      "original_position" : 398,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 397,
      "pull_request_review_id" : 1954697,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/80937273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Rebased and nits addressed.",
      "created_at" : "2016-09-29T09:21:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-250414684",
      "id" : 250414684,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-09-29T09:21:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/250414684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r81989644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/81989644"
         }
      },
      "body" : "It looks like you're doing the IsMine/HaveWatchOnly/AddWatchOnly dance twice here. Why?",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-10-05T14:46:10Z",
      "diff_hunk" : "@@ -637,3 +638,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r81989644",
      "id" : 81989644,
      "original_commit_id" : "e4d03e7ab03a3262e69b183c9bdafe23735766cc",
      "original_position" : 216,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 216,
      "pull_request_review_id" : 2928465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/81989644",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r82152188"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/82152188"
         }
      },
      "body" : "I was wondering the same when I checked the RPC call `importpubkey`, which calls the same _dance_ in [here](https://github.com/bitcoin/bitcoin/blob/master/src/wallet/rpcdump.cpp#L395).\r\n\r\nIn doubt, and since I did want to change the behavior of importing pub keys, I've added the **TODO** mark for revision of this part of the code.",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-10-06T09:47:00Z",
      "diff_hunk" : "@@ -637,3 +638,425 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r82152188",
      "id" : 82152188,
      "original_commit_id" : "e4d03e7ab03a3262e69b183c9bdafe23735766cc",
      "original_position" : 216,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 216,
      "pull_request_review_id" : 3078483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-19T14:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/82152188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Needs (easy) rebase in rpcwallet.cpp after #8788",
      "created_at" : "2016-10-19T13:33:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-254813551",
      "id" : 254813551,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-19T13:33:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254813551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Rebased.",
      "created_at" : "2016-10-19T21:44:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-254950038",
      "id" : 254950038,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-19T21:44:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254950038",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4319748?v=3",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "body" : "Re-Tested ACK 215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40\r\nI think this is ready for merge. Possible optimizations and nit-fixing can be done separately.",
      "created_at" : "2016-10-20T06:57:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-255024637",
      "id" : 255024637,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-20T06:57:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255024637",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "> I think this is ready for merge. Possible optimizations and nit-fixing can be done separately.\r\n\r\nYes, agreed. The code is self-contained so the risk of regressions is minimal. The `importmulti` RPC call should be considered experimental for now, but 0.14 is still a few months away anyhow.\r\n",
      "created_at" : "2016-10-20T07:05:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-255025907",
      "id" : 255025907,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-20T07:05:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255025907",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "bisect identifies cb08fdbf78685b55029768524ca867772711c32b as the commit that causes the compile to fail with:-\r\n\r\n```\r\nmake src/qt/bitcoin-qt\r\nMakefile:1169: warning: overriding commands for target `src/qt/bitcoin-qt'\r\nMakefile:1107: warning: ignoring old commands for target `src/qt/bitcoin-qt'\r\nmake -C src qt/bitcoin-qt\r\nmake[1]: Entering directory `/home/rebroad/src/bitcoin/src'\r\n  CXX      wallet/libbitcoin_wallet_a-rpcdump.o\r\nwallet/rpcdump.cpp: In function Ã¢ÂÂUniValue processImport(const UniValue&)Ã¢ÂÂ:\r\nwallet/rpcdump.cpp:869:37: error: Ã¢ÂÂpubkeyÃ¢ÂÂ was not declared in this scope\r\n                 CKeyID vchAddress = pubkey.GetID();\r\n                                     ^\r\nmake[1]: *** [wallet/libbitcoin_wallet_a-rpcdump.o] Error 1\r\nmake[1]: Leaving directory `/home/rebroad/src/bitcoin/src'\r\nmake: *** [src/qt/bitcoin-qt] Error 2\r\n```\r\n\r\nI am confused as to how this tested ok and got merged when it doesn't compile..",
      "created_at" : "2016-10-25T02:31:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-255919644",
      "id" : 255919644,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-25T04:13:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255919644",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r84823393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84823393"
         }
      },
      "body" : "pubKey is not defined.... pubkey is though!",
      "commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "created_at" : "2016-10-25T02:53:58Z",
      "diff_hunk" : "@@ -637,3 +638,424 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#discussion_r84823393",
      "id" : 84823393,
      "original_commit_id" : "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "original_position" : 142,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 142,
      "pull_request_review_id" : 5575538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7551",
      "updated_at" : "2016-10-25T02:53:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84823393",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "This has not given any compile issues for anyone else besides a boost issue which was fixed later ( #8980).\r\nAlso when I look at the source, pubkey is simply defined as:\r\n```\r\nCPubKey pubkey = key.GetPubKey();\r\n```\r\nIf you are trying to merge this into some other code base do not complain here if the build breaks.",
      "created_at" : "2016-10-25T05:34:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7551#issuecomment-255940845",
      "id" : 255940845,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7551",
      "updated_at" : "2016-10-25T05:34:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255940845",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
