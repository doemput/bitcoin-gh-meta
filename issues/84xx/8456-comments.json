[
   {
      "body" : "Thanks! Looks good.\r\nConcept ACK will review and test soon.",
      "created_at" : "2016-08-05T10:56:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-237822346",
      "id" : 237822346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-08-05T10:56:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/237822346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322"
         }
      },
      "body" : "nit: Double negation makes it hards to read. I suggest to replace by\n\n```\n CAmount nOldFee = wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0;\n```\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:39:53Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322",
      "id" : 73769322,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 113,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911"
         }
      },
      "body" : "I'm not sure about this. The problem is that such case will rarely happen so applications risk to break during sudden peak usage, amplifying bad news. \n\nI suggest to silently bump fees to the minMempoolFeeRate.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:47:25Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911",
      "id" : 73769911,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 153,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122"
         }
      },
      "body" : "nit: \n\n```\n nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)\n```\n\nIs repeated. Suggest using variable.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:50:32Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122",
      "id" : 73770122,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489"
         }
      },
      "body" : "additional check should be done:\n\n```\nnDelta >= poutput->GetDustThreshold(::minRelayTxFee);\n```\n\nOr it won't get propagated.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:55:41Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489",
      "id" : 73770489,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556"
         }
      },
      "body" : "can you use C++11 loop style ?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:56:20Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556",
      "id" : 73770556,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 214,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774"
         }
      },
      "body" : "You should use the same SIGHASH than the previous one. (might be done separate PR ?)\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T22:58:48Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {\n+            const CScript& scriptPubKey = (*mi).second.vout[(*it).prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774",
      "id" : 73770774,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 219,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062"
         }
      },
      "body" : ">  (nIn < (int)(*mi).second.vout.size())\n\nI think this is a bug, why does the index of the input to sign should be below the number of vout of the parent ? Does not make sense.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-08-05T23:02:03Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062",
      "id" : 73771062,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 216,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "Needs rebase and reviewers... setting 0.14 milestone.",
      "created_at" : "2016-08-19T16:50:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-241071499",
      "id" : 241071499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-08-19T16:50:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/241071499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased and addressed feedback.\r\n",
      "created_at" : "2016-10-18T18:07:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-254590532",
      "id" : 254590532,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-18T18:07:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254590532",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915487"
         }
      },
      "body" : "Good idea, fixed.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:07:33Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915487",
      "id" : 83915487,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 214,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727308,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915487",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915534"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915534"
         }
      },
      "body" : "Let's punt to separate PR. \n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:07:47Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {\n+            const CScript& scriptPubKey = (*mi).second.vout[(*it).prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915534",
      "id" : 83915534,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 219,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727354,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915534",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915788"
         }
      },
      "body" : "Good catch, edited to bounds-check the prevout.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:09:04Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915788",
      "id" : 83915788,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 216,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916251"
         }
      },
      "body" : "I checked earlier that the bumped fee pays for the new relay fee;  I'm not following as to the relationship between nDelta and dust. \n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:11:13Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916251",
      "id" : 83916251,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916320"
         }
      },
      "body" : "Fixed.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:11:32Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916320",
      "id" : 83916320,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728114,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916647"
         }
      },
      "body" : "I edited the comment to explain why I'm reporting an error.  Especially if the user set totalFee (or had in the recent past used paytxfee to set an explicit fee rate) I think silently bumping could surprise the user. \n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:13:02Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916647",
      "id" : 83916647,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 153,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916680"
         }
      },
      "body" : "Fixed.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-18T18:13:12Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916680",
      "id" : 83916680,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 113,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Needs rebase again...",
      "created_at" : "2016-10-20T19:55:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-255210711",
      "id" : 255210711,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-20T19:55:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255210711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased and edited to use JSONRPCRequest, consistent with #8788.",
      "created_at" : "2016-10-21T15:44:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-255412618",
      "id" : 255412618,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-21T15:44:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255412618",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r84578211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84578211"
         }
      },
      "body" : "This line is outdated\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-22T14:35:52Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r84578211",
      "id" : 84578211,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 22,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5350229,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84578211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "I think it's very important for this command to actual figure out the change output on its own.  I understand that it's a bit messier and more fragile doing it here -- but it actually has enough information to do this, and by avoiding it, it just pushes that mess into the caller which comes at a very significant usability issue.\r\n\r\n\r\nCompare:\r\nTransaction stuck? Use `bumpfee $txid`\r\n\r\nvs\r\n\r\nTransaction stuck? First use `gettransaction $txid`, and now get the data from the \"hex\" field to feed into `decoderawtransaction $hex`  now go through the \"vout\" fields until you find \"addresses\" nested in the \"scriptPubKey\". Now try figure out which is a change address. (I can't even see this exposed over rpc at all?). So maybe go `validateaddress $address` and check the `ismine` field. If one of them is yours, but the other one isn't -- then the one that is yours is a change address, so now go back through the results of `decoderawtransaction` to figure out which index that is. And finally `bumpfee $txid $index`.  Oh yeah, becareful to handle all the edge cases, like the transaction only having 1 output, some of the outputs not having address, both having the same address etc.\r\n\r\n\r\nI think you'll find the usability problem of needing to know the index will prevent the majority of use by users and services for this =)",
      "created_at" : "2016-10-26T00:30:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256217731",
      "id" : 256217731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-26T00:37:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256217731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/9326759?v=3",
         "events_url" : "https://api.github.com/users/RHavar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RHavar/followers",
         "following_url" : "https://api.github.com/users/RHavar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RHavar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RHavar",
         "id" : 9326759,
         "login" : "RHavar",
         "organizations_url" : "https://api.github.com/users/RHavar/orgs",
         "received_events_url" : "https://api.github.com/users/RHavar/received_events",
         "repos_url" : "https://api.github.com/users/RHavar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RHavar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RHavar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RHavar"
      }
   },
   {
      "body" : "Also ideally, I think the `txid` argument should be an array of transaction ids to bump. And then it creates a single transaction that bumps the fees on all of those transactions (stripping out extraneous change outputs as it goes). However, I imagine this can be done separately and later as the `txid` argument could be overloaded to either accept a string or array of strings?",
      "created_at" : "2016-10-26T00:34:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256218209",
      "id" : 256218209,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-26T00:35:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256218209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/9326759?v=3",
         "events_url" : "https://api.github.com/users/RHavar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RHavar/followers",
         "following_url" : "https://api.github.com/users/RHavar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RHavar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RHavar",
         "id" : 9326759,
         "login" : "RHavar",
         "organizations_url" : "https://api.github.com/users/RHavar/orgs",
         "received_events_url" : "https://api.github.com/users/RHavar/received_events",
         "repos_url" : "https://api.github.com/users/RHavar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RHavar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RHavar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RHavar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85203030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85203030"
         }
      },
      "body" : "Perhaps make this fail if there are any options other than confTarget or totalFee passed in to guard against the case where a user has a typo or something.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T19:38:20Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85203030",
      "id" : 85203030,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 87,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85203030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85204987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85204987"
         }
      },
      "body" : "Maybe add a tighter limit to your bumpfee code, bumpfeeMaxTxFee. Set this to be an optional default parameter in options. maxTxFee is huge, so might be safer to have something smaller and not much added code. This parameter can be overridden if need be, but not to more the maxTxFee.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T19:48:41Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85204987",
      "id" : 85204987,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 106,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85204987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209694"
         }
      },
      "body" : "There is kind of a weird deal here where nDelta can be <= 0 if totalFee is set, and will be accepted on a race condition with mempool, I would explicitly guard against this case by restricting nDelta > 0.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T20:12:09Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209694",
      "id" : 85209694,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 159,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209694",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209934"
         }
      },
      "body" : "Using a nNewFee = 0 is fine here, it just slightly bothers me to use this as a null value when indeed 0 is a valid fee amount.\n\n-1 would be an invalid fee amount (creates coins) so I have a slight preference to use this.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T20:13:26Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209934",
      "id" : 85209934,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 118,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85211353"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85211353"
         }
      },
      "body" : "I would suggest that this should also return in the error message the txid of the furthest child, and suggest bumping the fee on that one if possible to take advantage of ancestor fee based mining and keep txs valid?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T20:21:00Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85211353",
      "id" : 85211353,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85211353",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85216916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85216916"
         }
      },
      "body" : "There is something kinda funky when a user is running in say blocksonlymode and doesn't know about any child transactions that may exist and therefore has trouble setting the fee correctly for those that they will invalidate.\n\nThis is probably a hard problem to solve; so I'm just pointing it out.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-26T20:48:30Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85216916",
      "id" : 85216916,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85216916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427104"
         }
      },
      "body" : "Done.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-27T21:03:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427104",
      "id" : 85427104,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 159,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 6145468,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427448"
         }
      },
      "body" : "As far as I can tell it's a little tricky to track down the furthest child (and there could be numerous furthest children at the same level) but I edited the error message to give the user more info (number of children and size of those transactions) and explaining the situation a bit better.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-10-27T21:05:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427448",
      "id" : 85427448,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 6145807,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427448",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Addressed JeremyRubin feedback, edited the python test, and made a few other small changes I noticed with further testing. \r\n\r\nRHavar:  I understand your point but I still think it's better for this command to be low-level and not fragile.  A more user-friendly RPC (e.g., \"bumpfeeauto\" or something) could be layered on top, identifying the change output and then using this code.  Then if the change-output-identifying code breaks, it might break the user-friendly version but it wouldn't dismantle RBF entirely. \r\n",
      "created_at" : "2016-10-27T21:10:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256770931",
      "id" : 256770931,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-27T21:10:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256770931",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "ACK f3833f4\r\nTested on Windows x64\r\n```\r\nbumpfee 8c56b13830405a55ec4bc58b26b531f1b187d2349ee19bd0dd01aa835972929a 1\r\n\r\n{\r\n  \"txid\": \"67d6af1a3e29e246eaef0b7ce272f745e2ae6178050ccb78fca515b13c0f9e92\",\r\n  \"oldfee\": 0.00000260,\r\n  \"fee\": 0.00000520\r\n}\r\n```",
      "created_at" : "2016-11-11T13:13:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-259954550",
      "id" : 259954550,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-11T13:16:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259954550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/11365204?v=3",
         "events_url" : "https://api.github.com/users/Victorsueca/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Victorsueca/followers",
         "following_url" : "https://api.github.com/users/Victorsueca/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Victorsueca/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Victorsueca",
         "id" : 11365204,
         "login" : "Victorsueca",
         "organizations_url" : "https://api.github.com/users/Victorsueca/orgs",
         "received_events_url" : "https://api.github.com/users/Victorsueca/received_events",
         "repos_url" : "https://api.github.com/users/Victorsueca/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Victorsueca/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Victorsueca/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Victorsueca"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586451"
         }
      },
      "body" : "nit: Maybe use txid to correspond with the call header at L2587 or use `transactionid` there?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-11T13:18:38Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586451",
      "id" : 87586451,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 32,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8194636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586451",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586523"
         }
      },
      "body" : "add third parameter `(\"options\")`?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-11T13:19:22Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586523",
      "id" : 87586523,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 22,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8194716,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586523",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586825"
         }
      },
      "body" : "I'm not sure if we want absolute fee values here.\nThe user can't be sure how many inputs are getting added when setting this value, probably resulting in an uncontrollable feerate.\n\nWhat about switching this to a feerate?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-11T13:22:38Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586825",
      "id" : 87586825,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587175"
         }
      },
      "body" : "This check looks really expensive for large wallets. Why not calling `mapWallet.find(hash)` and check `nDepth` (and maybe call `GetConflicts()` to ensure its not conflicted with a already mined tx)?\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-11T13:25:49Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    vector<COutput> vecOutputs;\n+    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    BOOST_FOREACH(const COutput& out, vecOutputs) {\n+        if (out.tx->GetHash().GetHex() == hash.GetHex() && out.nDepth > 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587175",
      "id" : 87587175,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 67,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195411,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587201"
         }
      },
      "body" : "Another possibility is to leave the RPC with an absolute value and use Fee/KB on the GUI.\nSome software may want to use it's own relative fee rate.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-11T13:26:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587201",
      "id" : 87587201,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/11365204?v=3",
         "events_url" : "https://api.github.com/users/Victorsueca/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Victorsueca/followers",
         "following_url" : "https://api.github.com/users/Victorsueca/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Victorsueca/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Victorsueca",
         "id" : 11365204,
         "login" : "Victorsueca",
         "organizations_url" : "https://api.github.com/users/Victorsueca/orgs",
         "received_events_url" : "https://api.github.com/users/Victorsueca/received_events",
         "repos_url" : "https://api.github.com/users/Victorsueca/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Victorsueca/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Victorsueca/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Victorsueca"
      }
   },
   {
      "body" : "Oh. I just realized that this PR does not add new inputs (it requires an output index to identify the change-output which then can be reduced).\r\n\r\nIMO we should...\r\n\r\n1.) not let the user identify which output is change\r\n2.) allow bumping fees including adding new inputs (some transactions do not have a change output, some will not allow a reasonable bumping without adding a new input).\r\n\r\nBut 1.) & 2.) can also be solved later.",
      "created_at" : "2016-11-11T13:31:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-259957619",
      "id" : 259957619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-11T13:31:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259957619",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Feedback addressed.  Good catch on checking whether the tx had already been mined - that code was able to be shortened to a single line.\r\nYes, the approach of this PR is to solve 1) and 2) later.\r\nIf this looks good I'll squash the commits. ",
      "created_at" : "2016-11-14T16:38:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-260387468",
      "id" : 260387468,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-14T16:38:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/260387468",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87878468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87878468"
         }
      },
      "body" : "I don't think this section makes sense.  Transactions which are in newer in the wallet are not a good indication of the most \"up to date\" spend of the outputs.  If anything, conflicts in the mempool would be a good proxy, because at least for those you'd be able to calculate any descendants fees.  But it may make the most sense to make this more of a utility function and just assume the user is trying to bump the right txid.  I would just eliminate this set of checks entirely.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-14T19:49:02Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87878468",
      "id" : 87878468,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 76,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8471777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87878468",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87879296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87879296"
         }
      },
      "body" : "Would be helpful to refer to this as the output index throughout...  (comments, help, and error messages)\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-14T19:53:20Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87879296",
      "id" : 87879296,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 33,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87879296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88117668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88117668"
         }
      },
      "body" : "We need to be sure we are calculating the correct fee here.  Either using new `IsAllFromMe` or getting the fee from the mempool.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-15T21:29:51Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88117668",
      "id" : 88117668,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 131,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88117668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88120736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88120736"
         }
      },
      "body" : "you don't need this, you can just leave it out as an argument\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-15T21:44:39Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88120736",
      "id" : 88120736,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 143,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88120736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88122200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88122200"
         }
      },
      "body" : "~~I think this reduces bumpfee to a two step process in the common case (whenever there are children) and makes it so the second step is going to require setting totalfee.  It seems more user friendly to just pay what it takes?~~\n\n~~On a separate note, I think it might be nice to check all of the children transactions and make sure their ancestor fee rate isn't higher than the new feerate you are bumping to.  If one of them has a higher ancestor fee rate you are actually make your situation worse.~~\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-15T21:52:42Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88122200",
      "id" : 88122200,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 200,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88122200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88474390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88474390"
         }
      },
      "body" : "I spoke with @sdaftuar and @mrbandrews about this and withdraw both of the above points.  If the transaction has children, it becomes quite complicated to decide whether bumping fee makes sense and by how much and its probably better to just report to the user the minimum fee that would be required to bump and let the user decide whether that makes sense.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-17T15:25:00Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88474390",
      "id" : 88474390,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 200,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9047192,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88474390",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488019"
         }
      },
      "body" : "Fixed (removed)\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-17T16:21:39Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488019",
      "id" : 88488019,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 76,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9060619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488069"
         }
      },
      "body" : "Done.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-17T16:21:47Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488069",
      "id" : 88488069,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 33,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9060666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488714"
         }
      },
      "body" : "This should be correct since now we're checking that the user owns all the inputs.\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-17T16:24:17Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488714",
      "id" : 88488714,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 131,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9061267,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488750"
         }
      },
      "body" : "Fixed. \n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-17T16:24:25Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88488750",
      "id" : 88488750,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 143,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9061300,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88488750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "morcos feedback addressed, including adding the first commit from #9167. ",
      "created_at" : "2016-11-17T16:26:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-261294348",
      "id" : 261294348,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-17T16:26:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261294348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88987177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88987177"
         }
      },
      "body" : "You should probably check that the depth is exactly 0, because otherwise the tx is already mined or conflicted with a mined tx and no point in bumping.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-21T21:04:02Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88987177",
      "id" : 88987177,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 65,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9541621,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88987177",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88991899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88991899"
         }
      },
      "body" : "@JeremyRubin how could nDelta be negative here?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-21T21:28:01Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88991899",
      "id" : 88991899,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 159,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9546280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88991899",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89264742"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89264742"
         }
      },
      "body" : "\"BIP 125\"",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:18:13Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89264742",
      "id" : 89264742,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 70,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89264742",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89264849"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89264849"
         }
      },
      "body" : "Maybe move output into options? Even if it's required in this version, it should ideally become optional in the future...",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:19:30Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89264849",
      "id" : 89264849,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 22,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89264849",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265083"
         }
      },
      "body" : "Just use `int64_t`? `int` is only guaranteed to be 15-bit, so it's too small anyway.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:22:02Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265083",
      "id" : 89265083,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 128,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265083",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265215"
         }
      },
      "body" : "`nNewFeeRate = payTxFee;`?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:23:58Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265215",
      "id" : 89265215,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 135,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265215",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265391"
         }
      },
      "body" : "`+ wtx.vin.size()` seems appropriate here too?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:26:17Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265391",
      "id" : 89265391,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 152,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265811"
         }
      },
      "body" : "s/would/may probably/\r\n\r\nIn the future, it may make sense to combine some children transactions (ie, our own) into this one while bumping the fee.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:31:49Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");\n+                strError += strprintf(\"The bumped fee must be at least: %s.\\n\", FormatMoney(nFeesWithDescendantsPlusRelay));\n+                strError += strprintf(\"Number of child transactions: %u, total size of child transactions: %u\\n\", numDescendants, sizeDescendants);\n+                strError += strprintf(\"Note that the child transactions would be evicted from the mempool and would not be mined.\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265811",
      "id" : 89265811,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 200,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265932"
         }
      },
      "body" : "@NicolasDorier I also don't see a need for that...",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:33:31Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265932",
      "id" : 89265932,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265943"
         }
      },
      "body" : "Why not just discard the change?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:33:40Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");\n+                strError += strprintf(\"The bumped fee must be at least: %s.\\n\", FormatMoney(nFeesWithDescendantsPlusRelay));\n+                strError += strprintf(\"Number of child transactions: %u, total size of child transactions: %u\\n\", numDescendants, sizeDescendants);\n+                strError += strprintf(\"Note that the child transactions would be evicted from the mempool and would not be mined.\\n\");\n+                strError += strprintf(\"To avoid mempool eviction, consider bumping fee on the child transactions (with fee to pay for the ancestors).\\n\");\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempool of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to require the user to force processing in this situation. If the user has not set the \"force\" option,\n+            // we throw an error. Otherwise, we bump/commit/relay the transaction.  If the tx has children and the fee is insufficient\n+            // to cover, peers will reject the tx on that basis, so we warn the user of this possibility.\n+            //\n+            if (fForce)\n+                LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+            else\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Set the \\'force\\' option to bump fee on a tx that is not in the mempool\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89265943",
      "id" : 89265943,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 235,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9810981,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89265943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89266113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89266113"
         }
      },
      "body" : "This needs to be rebased...",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T07:35:50Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");\n+                strError += strprintf(\"The bumped fee must be at least: %s.\\n\", FormatMoney(nFeesWithDescendantsPlusRelay));\n+                strError += strprintf(\"Number of child transactions: %u, total size of child transactions: %u\\n\", numDescendants, sizeDescendants);\n+                strError += strprintf(\"Note that the child transactions would be evicted from the mempool and would not be mined.\\n\");\n+                strError += strprintf(\"To avoid mempool eviction, consider bumping fee on the child transactions (with fee to pay for the ancestors).\\n\");\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempool of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to require the user to force processing in this situation. If the user has not set the \"force\" option,\n+            // we throw an error. Otherwise, we bump/commit/relay the transaction.  If the tx has children and the fee is insufficient\n+            // to cover, peers will reject the tx on that basis, so we warn the user of this possibility.\n+            //\n+            if (fForce)\n+                LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+            else\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Set the \\'force\\' option to bump fee on a tx that is not in the mempool\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, tx);\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get()))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89266113",
      "id" : 89266113,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 256,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9812244,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89266113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89270776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89270776"
         }
      },
      "body" : "No need for strprintf here",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T08:24:37Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89270776",
      "id" : 89270776,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 197,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9816759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89270776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89270794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89270794"
         }
      },
      "body" : "Also no strprintf here",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T08:24:50Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");\n+                strError += strprintf(\"The bumped fee must be at least: %s.\\n\", FormatMoney(nFeesWithDescendantsPlusRelay));\n+                strError += strprintf(\"Number of child transactions: %u, total size of child transactions: %u\\n\", numDescendants, sizeDescendants);\n+                strError += strprintf(\"Note that the child transactions would be evicted from the mempool and would not be mined.\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89270794",
      "id" : 89270794,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 200,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9816778,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89270794",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89278178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89278178"
         }
      },
      "body" : "I think, because every else use fee-ratres per KB, we should make clear at this point that `totalFee` and `maxFee` are absolute fee-values (and not per KB).",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T09:24:18Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89278178",
      "id" : 89278178,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9824056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89278178",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89287183"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89287183"
         }
      },
      "body" : "del strprintf",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-11-23T10:20:47Z",
      "diff_hunk" : "@@ -2575,6 +2577,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {\n+                uint64_t numDescendants = it->GetCountWithDescendants()-1;\n+                uint64_t sizeDescendants = it->GetSizeWithDescendants() - it->GetTxSize();\n+                std::string strError = strprintf(\"Insufficent fee due to the child transactions.\\n\");\n+                strError += strprintf(\"The bumped fee must be at least: %s.\\n\", FormatMoney(nFeesWithDescendantsPlusRelay));\n+                strError += strprintf(\"Number of child transactions: %u, total size of child transactions: %u\\n\", numDescendants, sizeDescendants);\n+                strError += strprintf(\"Note that the child transactions would be evicted from the mempool and would not be mined.\\n\");\n+                strError += strprintf(\"To avoid mempool eviction, consider bumping fee on the child transactions (with fee to pay for the ancestors).\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r89287183",
      "id" : 89287183,
      "original_commit_id" : "a0b7e342c65a9bc6b26a4000fdee81bfc6ed9572",
      "original_position" : 201,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 9833016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/89287183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "OK, rebased and squashed, with edits addressing the most recent feedback in a separate commit.\r\n\r\nI didn't separate code into non-rpc files because I'm not 100% sure which logic should be moved, and thought this decision could be made when using it from the GUI, as moving the code then should be easy enough. \r\n \r\n\r\n",
      "created_at" : "2016-12-01T19:52:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-264275910",
      "id" : 264275910,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-01T19:52:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/264275910",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r90770633"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90770633"
         }
      },
      "body" : "You should calculate txSize + wtx.vin.size() once and keep it in a const variable for these...\r\n\r\n```C++\r\nconst int64_t maxNewTxSize = txSize + wtx.vin.size();\r\n```",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-04T04:48:46Z",
      "diff_hunk" : "@@ -2582,6 +2584,262 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output index          (numeric, required) The output index to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"     \\\"force\\\":            \\\"true/false\\\", (boolean, optional) Force replacement even if txid is not in user's mempool\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that tx hasn't already been mined, not does it conflict with a mined transation\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // bounds-check the output index to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output index out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    bool fForce = false;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+                {\"force\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+        if (options.exists(\"force\")) {\n+            fForce = options[\"force\"].get_bool();\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize+wtx.vin.size()) + minRelayTxFee.GetFee(txSize+wtx.vin.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r90770633",
      "id" : 90770633,
      "original_commit_id" : "7d9f218dab0b4b152490923b5723061358b0f110",
      "original_position" : 149,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 11288639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90770633",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "Asking the user to identify change is unreasonable and dangerous.  Within our own wallet we should know which outputs are our own.  This also has a problem of creating a mess when the original version of the transaction it spent, but later sends may have spent the replacements output.\r\n\r\nI would suggest that a minimal bump-fee would do this:\r\n\r\n(1) Only be available on transactions where none of their outputs have been spent (even in mempool).\r\n(2) Preserve all the user provided outputs, potentially changing the change amount, potentially adding more inputs if needed to get past dust or just sufficient fees. Obey the opt-in RBF minimum increment\r\n(3) Mark its local output(s) as unspendable until confirmed.\r\n\r\n1/3 are required so that we don't end up with a mess when the 'wrong' version of the transaction confirms and invalidates the others.\r\n\r\nA somewhat more advanced -- and perhaps better to do instead-- would be a \"bumpunconfirmed\" which would not act on a single transaction but on all valid unconfirmed sends of the local wallet at once--  generating a single replacement transaction which conflicts each of the originals, pays a higher fee, and marks its own output as unspendable until confirmed.\r\n\r\nI suggest this might be better instead because it  would not need to have the requirement that its local outputs not be unspent, since it would replace all those spends at once. The reduced number of change outputs plus the ability to drop some of the inputs (so long as it still conflicts, and still marks them as unspendable until this transaction confirms) means that it can reduce the total transaction sizes. \r\n\r\n",
      "created_at" : "2016-12-04T21:55:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-264734557",
      "id" : 264734557,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-04T21:55:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/264734557",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Addressed the gmaxwell feedback as follows: now it identifies the change output and guards against spending outputs until the bumped transaction (or perhaps the original transaction) is mined.\r\n\r\nI reorganized this into two commits, the latter being the python test, which is updated. ",
      "created_at" : "2016-12-09T18:59:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-266093096",
      "id" : 266093096,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-09T18:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266093096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91820598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91820598"
         }
      },
      "body" : "Any reason not to automatically just switch to the new txid here?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-10T00:25:19Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91820598",
      "id" : 91820598,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 70,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12334073,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91820598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91820649"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91820649"
         }
      },
      "body" : "Just use a size_t here, not cast to int... And use ++i, not i++\r\n\r\nBut more importantly, better to use C++11 iterators in this case:\r\n\r\n```C++\r\nfor (const CTxOut& txout : wtx.tv->vout) {\r\n    if (pwalletMain->IsChange(txout)) {\r\n        if (nOutput != -1) {\r\n            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\r\n        }\r\n        nOutput = i;\r\n    }\r\n}\r\n```",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-10T00:25:56Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91820649",
      "id" : 91820649,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 80,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12334073,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91820649",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821141"
         }
      },
      "body" : "I think we're trying to keep CWalletDB only used by CWallet. @pstratem ?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-10T00:32:39Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+        strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason());\n+        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n+    }\n+\n+    // mark the original tx as bumped\n+    {\n+        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821141",
      "id" : 91821141,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 228,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12334073,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821141",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821594"
         }
      },
      "body" : "Probably this needs to go through CWallet::AddToWallet",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-10T00:39:17Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+        strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason());\n+        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n+    }\n+\n+    // mark the original tx as bumped\n+    {\n+        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821594",
      "id" : 91821594,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 228,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12335058,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821594",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821708"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821708"
         }
      },
      "body" : "May need to be atomic with adding the new one as well...",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-10T00:41:05Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+        strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason());\n+        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n+    }\n+\n+    // mark the original tx as bumped\n+    {\n+        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91821708",
      "id" : 91821708,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 228,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12335174,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91821708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "I wonder if this ought to interact with abandontransaction in some way?",
      "created_at" : "2016-12-10T00:51:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-266163465",
      "id" : 266163465,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-10T00:51:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266163465",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91956751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91956751"
         }
      },
      "body" : "@luke-jr  That won't compile since`i` is undefined...  Is there a better way to loop here where the index is needed?  Also I'd suggest that this kind of style nit can be cleaned up in a later pull anyway; this one has been open for long enough.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T14:30:36Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91956751",
      "id" : 91956751,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 80,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12465546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91956751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91984171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91984171"
         }
      },
      "body" : "This line in the help text needs to be updated for the latest semantics (no descendants in mempool or wallet).",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T16:34:31Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91984171",
      "id" : 91984171,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 29,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91984171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91984951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91984951"
         }
      },
      "body" : "I found this sentence, and the ones below (\"This command will fail if fee is not high enough...\") to be confusing.  Perhaps some explanation of what automatic fee calculation will occur, unless overriden/modified by the options, and that if the resulting fee isn't high enough then the command will fail? ",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T16:37:50Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91984951",
      "id" : 91984951,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 28,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91984951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91985184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91985184"
         }
      },
      "body" : "`<output>` should not be here anymore.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T16:38:54Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91985184",
      "id" : 91985184,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 48,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91985184",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91995460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91995460"
         }
      },
      "body" : "I think this cast isn't correct after #8580 was merged; looks like the correct way to do this is `GetVirtualTransactionSize(*wtx->tx)`.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T17:24:43Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91995460",
      "id" : 91995460,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 131,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91995460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91997774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91997774"
         }
      },
      "body" : "I don't think we should rely on the CMerkleTx function\r\n```    \r\noperator const CTransaction&() const { return *tx; }\r\n```\r\nthat makes this work, as that function has a comment saying it should be removed.  `*wtx->tx` here again I think?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T17:35:58Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r91997774",
      "id" : 91997774,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 188,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91997774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92012040"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92012040"
         }
      },
      "body" : "I think this line should be removed now that the output is no longer specified?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-12T18:47:08Z",
      "diff_hunk" : "@@ -112,6 +112,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setnetworkactive\", 0 },\n     { \"getmempoolancestors\", 1 },\n     { \"getmempooldescendants\", 1 },\n+    { \"bumpfee\", 1 },\n+    { \"bumpfee\", 2 },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92012040",
      "id" : 92012040,
      "original_commit_id" : "64a17d6b95ed1eb1a9af118eb3376d6108debad2",
      "original_position" : 5,
      "path" : "src/rpc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 12493443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92012040",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92224356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92224356"
         }
      },
      "body" : "For now, I'd rather leave it as is, and let the user resubmit with the correct txid.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-13T17:42:26Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92224356",
      "id" : 92224356,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 70,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12735765,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92224356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92224536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92224536"
         }
      },
      "body" : "Changed to a size_t (and ++i)",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-13T17:43:20Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92224536",
      "id" : 92224536,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 80,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12735951,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92224536",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92225380"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92225380"
         }
      },
      "body" : "I moved this code into a new method on the wallet so the CWalletDB is only used from CWallet.  I looked at AddToWallet but I would need to have edited it a bit, plus it does some stuff I don't need so I thought a new but concise method was a better approach. \r\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-13T17:48:04Z",
      "diff_hunk" : "@@ -2581,6 +2584,233 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or if there were multiple change outputs, fail\n+    int nOutput = -1;\n+    for (int i=0; i < (int) wtx.tx->vout.size(); i++) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+        strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason());\n+        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n+    }\n+\n+    // mark the original tx as bumped\n+    {\n+        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92225380",
      "id" : 92225380,
      "original_commit_id" : "d16db273381e249d84e55f8377d9c0dd50123936",
      "original_position" : 228,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12736816,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92225380",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Pushed a new commit addressing the recent feedback and rebased due to a conflict in rpc-tests.py.\r\n\r\n",
      "created_at" : "2016-12-13T17:49:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-266810046",
      "id" : 266810046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-13T17:49:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266810046",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92449789"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92449789"
         }
      },
      "body" : "Why use `0.01 * COIN` instead of the global `maxTxFee`? I think it would be worth explaining in a comment. Also, if `0.01 * COIN` is a significant value, maybe it would be good to declare it in validation.h alongside similar sounding constants like `HIGH_MAX_TX_FEE`.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T17:51:16Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92449789",
      "id" : 92449789,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 94,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92449789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92452706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92452706"
         }
      },
      "body" : "I would move this declaration down closer to where the variable is first used (line 2719 `nNewFee = nNewFeeRate.GetFee(maxNewTxSize);`",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T18:06:40Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92452706",
      "id" : 92452706,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 136,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92452706",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92459085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92459085"
         }
      },
      "body" : "Seems like if this condition is true, the work done above gets thrown away. Maybe that code could be moved into an else block so the sematics of the totalFee > 0 case are more straightforward.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T18:37:21Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92459085",
      "id" : 92459085,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 152,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92459085",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92461226"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92461226"
         }
      },
      "body" : "This block of code seems very similar to existing code in `CWallet::GetMinimumFee`. If you tweaked that function to return the fee rate in addition to the fee, could that function be reused here?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T18:48:35Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92461226",
      "id" : 92461226,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 138,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92461226",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92463667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92463667"
         }
      },
      "body" : "What should the user do when this case happens? Should they report a bug because it should not be possible for this condition to happen? Or should they just try passing in a high(er) totalFee value? I think it'd be good to clarify in the error message.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:00:44Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92463667",
      "id" : 92463667,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 175,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92463667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92463788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92463788"
         }
      },
      "body" : "Would suggest changing error code below to RPC_INTERNAL_ERROR if it's really not possible for this condition to happen at this point.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:01:22Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92463788",
      "id" : 92463788,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 174,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92463788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92466211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92466211"
         }
      },
      "body" : "I think it would make sense to move this check up towards the top of this function near the pwalletMain / wtx checks, instead of leaving it down here after fee estimation & option parsing. As a user I wouldn't want to first resolve a bunch of errors about fees and options before finding out that the transaction I am trying to bump can't be bumped in the first place.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:13:54Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92466211",
      "id" : 92466211,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 178,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92466211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92467255"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92467255"
         }
      },
      "body" : "Think `<=` would be better than `<` here. Thinking in a theoretical situation where nValue was 0 and dust threshould was somehow also 0, it would be more consistent to remove the output than keep it.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:18:35Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92467255",
      "id" : 92467255,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 196,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92467255",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92468014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92468014"
         }
      },
      "body" : "Maybe use `poutput->nValue -= nDelta` syntax here (and `nNewFee += poutput->nValue` below). `+=` and `-=` operators I think would make the code easier to read and less prone to typo errors.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:21:57Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92468014",
      "id" : 92468014,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 195,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92468014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92469677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92469677"
         }
      },
      "body" : "Maybe say this will decrease and possibly remove the change output, but leave other outputs alone. Also could say explicitly that this will not change existing inputs.\r\n\r\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:29:00Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92469677",
      "id" : 92469677,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 27,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92469677",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92470862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92470862"
         }
      },
      "body" : "`it` isn't really a good name for this variable, since it's a direct reference to the input, and not an iterator. Maybe `in` or `input` would be a better name.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:34:31Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92470862",
      "id" : 92470862,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 205,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92470862",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92471236"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92471236"
         }
      },
      "body" : "Maybe use auto here since you're already using it one line up.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:36:15Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92471236",
      "id" : 92471236,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 206,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92471236",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92471762"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92471762"
         }
      },
      "body" : "Would suggest replacing `tx.vin[nIn]` here with `it` or replacing the opposite way above to be consistent about how the input is referred to inside the loop.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:38:43Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92471762",
      "id" : 92471762,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 212,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92471762",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92473397"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92473397"
         }
      },
      "body" : "Maybe add `|| !state.IsValid()` to the condition here or assert(state.IsValid()) as a sanity check below.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:45:16Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {\n+            const CScript& scriptPubKey = (*mi).second.tx->vout[it.prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+            tx.vin[nIn].scriptSig = sigdata.scriptSig;\n+        }\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92473397",
      "id" : 92473397,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 222,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92473397",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92474152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92474152"
         }
      },
      "body" : "Unclear what good having this variable does. Seems like it's always just set in one line then thrown in the next line, making the code more verbose and causing unnecessary string copies.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:48:40Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92474152",
      "id" : 92474152,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 55,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92474152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92475795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92475795"
         }
      },
      "body" : "Can write mi->second instead of (*mi).second.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:56:12Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate = payTxFee;\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+    if (nNewFeeRate.GetFeePerK() == 0)\n+        nNewFeeRate = CWallet::fallbackFee;\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+    nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    // Fail if the tx has any descendants - check both the wallet and the mempool\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue = poutput->nValue - nDelta;\n+    if (poutput->nValue < poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee = nNewFee + poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto &it : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(it.prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && it.prevout.n < (*mi).second.tx->vout.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92475795",
      "id" : 92475795,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 207,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92475795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92476143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92476143"
         }
      },
      "body" : "self isn't being used here, would suggest making this a standalone function like submit_block_with_tx below.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T19:57:43Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework import blocktools\n+from test_framework.mininode import CTransaction\n+from test_framework.util import *\n+from test_framework.util import *\n+\n+import io\n+import time\n+\n+class BumpFeeTest (BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-walletrbf\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        connect_nodes_bi(self.nodes,0,1)\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def create_fund_sign_send(self, node, outputs, feerate=0):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92476143",
      "id" : 92476143,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 30,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92476143",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92478972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92478972"
         }
      },
      "body" : "This test is long and it's not clear right away whether the different parts of it depend on each other. If it could be broken up in some way, I think it would be more readable and easier to work with in the future. E.g.\r\n\r\n```\r\nself.test_simple_bumpfee_succeeds(a1)\r\nself.test_nonrbf_bumpfee_fails(a1)\r\nself.test_notmine_bumpfee_fails(a0)\r\n...\r\n```",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T20:11:50Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework import blocktools\n+from test_framework.mininode import CTransaction\n+from test_framework.util import *\n+from test_framework.util import *\n+\n+import io\n+import time\n+\n+class BumpFeeTest (BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-walletrbf\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        connect_nodes_bi(self.nodes,0,1)\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def create_fund_sign_send(self, node, outputs, feerate=0):\n+        if feerate != 0:\n+            node.settxfee(feerate)\n+        rawtx = node.createrawtransaction([], outputs)\n+        fundtx = node.fundrawtransaction(rawtx)\n+        signedtx = node.signrawtransaction(fundtx['hex'])\n+        txid = node.sendrawtransaction(signedtx['hex'])\n+        return txid\n+\n+\n+    def run_test (self):\n+\n+        print(\"Mining blocks...\")\n+\n+        # fund node0 with 10 coins of 0.001 btc (100,000 satoshis)\n+        self.nodes[1].generate(110)\n+        self.sync_all()\n+        a0 = self.nodes[0].getnewaddress()\n+        a1 = self.nodes[1].getnewaddress()\n+        for i in range(10):\n+            self.nodes[1].sendtoaddress(a0, 0.001)\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), Decimal('0.01'))\n+\n+        # create and bump an RBF transaction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92478972",
      "id" : 92478972,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 56,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 12965641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92478972",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92496592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92496592"
         }
      },
      "body" : "Regardless, we don't want to use flops for CAmount.\r\n\r\n(I know that in this case the compiler can do static analysis and figure out the exact result, but we should not promote bad practice; It is proved to break on 32 bit platforms when static code analysis does not catch the flop.)",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-14T21:47:04Z",
      "diff_hunk" : "@@ -2581,6 +2584,228 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs.\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"     \\\"maxFee\\\":           \\\"n\\\",          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r92496592",
      "id" : 92496592,
      "original_commit_id" : "c215e1dcb37ae28bbdc2fd9b098524b05f25b38d",
      "original_position" : 94,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 13013653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/92496592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "Pushed a new commit addressing ryanofsky's feedback.  \r\n\r\nI removed the maxFee option.  The rationale for this option was to have a more conservative tx fee limit for a bumpfee user, as the default maxTxFee (0.1 btc) is quite high and in particular, if bumping fee on a transaction with lots of descendants a user might end up paying a pretty high fee for the parent transaction alone (since the descendants would be removed).  Since the new approach is to not allow bumpfee to be used on a tx with descendants at all, this rationale mostly goes away and I think the maxFee option is not worth it. \r\n\r\nI moved the python test above 'nulldummy.py' in the pull-tester list for the purpose of avoiding a conflict.\r\n \r\n",
      "created_at" : "2016-12-15T16:55:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-267380319",
      "id" : 267380319,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-15T16:55:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/267380319",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "I got a travis failure I think due to the default transaction version=2, which caused a failure in the python test.  I corrected the test, rebased, and force-pushed.\r\n",
      "created_at" : "2016-12-15T20:15:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-267432232",
      "id" : 267432232,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-12-15T20:15:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/267432232",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r93022670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/93022670"
         }
      },
      "body" : "I don't think we should promise this...?",
      "commit_id" : "244319366ef1e5e4991c4184db20c53ff73a8622",
      "created_at" : "2016-12-19T12:32:40Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs or alter existing inputs.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r93022670",
      "id" : 93022670,
      "original_commit_id" : "244319366ef1e5e4991c4184db20c53ff73a8622",
      "original_position" : 27,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 27,
      "pull_request_review_id" : 13542665,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-12-19T12:32:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/93022670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r93170722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/93170722"
         }
      },
      "body" : "I don't think we should guarantee this. (sorry for reposting)",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2016-12-20T04:38:42Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs or alter existing inputs.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r93170722",
      "id" : 93170722,
      "original_commit_id" : "244319366ef1e5e4991c4184db20c53ff73a8622",
      "original_position" : 27,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 13692154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/93170722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94610929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94610929"
         }
      },
      "body" : "Thanks, I changed the wording to describe the current behavior but suggest it could be improved in the future.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-04T16:08:24Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will not add new inputs or alter existing inputs.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94610929",
      "id" : 94610929,
      "original_commit_id" : "244319366ef1e5e4991c4184db20c53ff73a8622",
      "original_position" : 27,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15140586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94610929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94807302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94807302"
         }
      },
      "body" : "I think this include is not needed.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-05T17:03:24Z",
      "diff_hunk" : "@@ -11,9 +11,12 @@\n #include \"init.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n+#include \"script/sign.h\"\n #include \"timedata.h\"\n+#include \"ui_interface.h\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94807302",
      "id" : 94807302,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 9,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15345817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94807302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94812614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94812614"
         }
      },
      "body" : "nit: We're calling RPCTypeCheck multiple times, which I don't think should be needed.  I believe we can just change this to `RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ))` and remove the one at line 2675 below.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-05T17:31:46Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+                            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+                            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94812614",
      "id" : 94812614,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 53,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15345817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94812614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94819938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94819938"
         }
      },
      "body" : "I think this should be `CFeeRate(totalFee, maxNewTxSize)`.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-05T18:10:47Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+                            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+                            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+          throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94819938",
      "id" : 94819938,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 145,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15345817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94819938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958773"
         }
      },
      "body" : "Thanks, removed.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-06T15:09:18Z",
      "diff_hunk" : "@@ -11,9 +11,12 @@\n #include \"init.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n+#include \"script/sign.h\"\n #include \"timedata.h\"\n+#include \"ui_interface.h\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958773",
      "id" : 94958773,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 9,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15502501,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958806"
         }
      },
      "body" : "Fixed.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-06T15:09:30Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+                            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+                            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958806",
      "id" : 94958806,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 53,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15502536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958806",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958882"
         }
      },
      "body" : "Added a comment. I think this was probably intentional since it makes the fee rate check below more conservative.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-06T15:10:05Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+                            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+                            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+          throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94958882",
      "id" : 94958882,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 145,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15502622,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94958882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94961158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94961158"
         }
      },
      "body" : "Now fixed (got this backward).",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-06T15:24:54Z",
      "diff_hunk" : "@@ -2581,6 +2584,212 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+                            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+                            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+                            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+                            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+                            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+                            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+                            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+                            \"The user can specify a confirmation target for estimatefee.\\n\"\n+                            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+          throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+      throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i=0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r94961158",
      "id" : 94961158,
      "original_commit_id" : "eb50c62afdd3a2cc95c3fb4d02d9d4f523975c89",
      "original_position" : 145,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15505193,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/94961158",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "~ACK b1a06207ed57425e0e4cccaad4588485d4483b08 (feel free to squash).~ EDIT: ACK pending resolution of https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95196336\r\n\r\nI believe all of @gmaxwell's comments in https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-264734557 have been addressed, with the exception of being able to add new inputs to a transaction to bump the fee.  I think that would be a fine improvement for the future, but I think this is still a useful feature even without it, so I don't think that should be a merge blocker.  @gmaxwell -- what do you think?",
      "created_at" : "2017-01-06T15:32:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-270928450",
      "id" : 270928450,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-09T18:11:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/270928450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Squashed b1a06207ed57425e0e4cccaad4588485d4483b08 -> f4fa93b29a59c6d0f0341f442fd1805972b43ca1.",
      "created_at" : "2017-01-06T15:41:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-270930464",
      "id" : 270930464,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-06T15:41:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/270930464",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95196336"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95196336"
         }
      },
      "body" : "@sdaftuar points out that this won't correctly update scriptWitness for witness transactions\r\nProbably better to use the UpdateTransaction function\r\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-09T16:54:09Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        input.scriptSig = sigdata.scriptSig;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95196336",
      "id" : 95196336,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 194,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15743456,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95196336",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95208926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95208926"
         }
      },
      "body" : "nit: mentioning fallbackfee is too much implementation detail here",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-09T17:57:27Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95208926",
      "id" : 95208926,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 29,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15756715,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95208926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95211699"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95211699"
         }
      },
      "body" : "Should there be a check against providing both options",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-09T18:12:09Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95211699",
      "id" : 95211699,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 15759605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95211699",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95228707"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95228707"
         }
      },
      "body" : "i'd abandon bumpid here so it doesn't accidentally rereplace rbfid if its reaccepted from the wallet\r\n\r\nif later abandoning conflicts/replacements frees up the original to spend again then thats a change in behavior that can result in changing the test",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-09T19:33:43Z",
      "diff_hunk" : "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework import blocktools\n+from test_framework.mininode import CTransaction\n+from test_framework.util import *\n+from test_framework.util import *\n+\n+import io\n+import time\n+\n+# Sequence number that is BIP 125 opt-in and BIP 68-compliant\n+BIP125_SEQUENCE_NUMBER = 0xfffffffd\n+\n+\n+class BumpFeeTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-walletrbf\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        rbf_node, peer_node = self.nodes\n+        rbf_node_address = rbf_node.getnewaddress()\n+\n+        # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n+        print(\"Mining blocks...\")\n+        self.nodes[1].generate(110)\n+        self.sync_all()\n+        for i in range(10):\n+            self.nodes[1].sendtoaddress(rbf_node_address, 0.001)\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), Decimal(\"0.01\"))\n+\n+        print(\"Running tests\")\n+        dest_address = peer_node.getnewaddress()\n+        test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address)\n+        test_nonrbf_bumpfee_fails(peer_node, dest_address)\n+        test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address)\n+        test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address)\n+        test_small_output_fails(rbf_node, dest_address)\n+        test_dust_to_fee(rbf_node, dest_address)\n+        test_settxfee(rbf_node, dest_address)\n+        test_rebumping(rbf_node, dest_address)\n+        test_unconfirmed_not_spendable(rbf_node, rbf_node_address)\n+        print(\"Success\")\n+\n+\n+def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    sync_mempools((rbf_node, peer_node))\n+    assert rbfid in rbf_node.getrawmempool() and rbfid in peer_node.getrawmempool()\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] - abs(rbftx[\"fee\"]) > 0\n+    # check that bumped_tx propogates, original tx was evicted and has a wallet conflict\n+    sync_mempools((rbf_node, peer_node))\n+    assert bumped_tx[\"txid\"] in rbf_node.getrawmempool()\n+    assert bumped_tx[\"txid\"] in peer_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+    assert rbfid not in peer_node.getrawmempool()\n+    oldwtx = rbf_node.gettransaction(rbfid)\n+    assert len(oldwtx[\"walletconflicts\"]) > 0\n+    # check wallet transaction replaces and replaced_by values\n+    bumpedwtx = rbf_node.gettransaction(bumped_tx[\"txid\"])\n+    assert_equal(oldwtx[\"replaced_by_txid\"], bumped_tx[\"txid\"])\n+    assert_equal(bumpedwtx[\"replaces_txid\"], rbfid)\n+\n+\n+def test_nonrbf_bumpfee_fails(peer_node, dest_address):\n+    # cannot replace a non RBF transaction (from node which did not enable RBF)\n+    not_rbfid = create_fund_sign_send(peer_node, {dest_address: 0.00090000})\n+    assert_raises_message(JSONRPCException, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n+\n+\n+def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n+    # cannot bump fee unless the tx has only inputs that we own.\n+    # here, the rbftx has a peer_node coin and then adds a rbf_node input\n+    # Note that this test depends upon the RPC code checking input ownership prior to change outputs\n+    # (since it can't use fundrawtransaction, it lacks a proper change output)\n+    utxos = [node.listunspent()[-1] for node in (rbf_node, peer_node)]\n+    inputs = [{\n+        \"txid\": utxo[\"txid\"],\n+        \"vout\": utxo[\"vout\"],\n+        \"address\": utxo[\"address\"],\n+        \"sequence\": BIP125_SEQUENCE_NUMBER\n+    } for utxo in utxos]\n+    output_val = sum(utxo[\"amount\"] for utxo in utxos) - Decimal(\"0.001\")\n+    rawtx = rbf_node.createrawtransaction(inputs, {dest_address: output_val})\n+    signedtx = rbf_node.signrawtransaction(rawtx)\n+    signedtx = peer_node.signrawtransaction(signedtx[\"hex\"])\n+    rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction contains inputs that don't belong to this wallet\",\n+                          rbf_node.bumpfee, rbfid)\n+\n+\n+def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n+    # cannot bump fee if the transaction has a descendant\n+    # parent is send-to-self, so we don't have to check which output is change when creating the child tx\n+    parent_id = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00050000})\n+    tx = rbf_node.createrawtransaction([{\"txid\": parent_id, \"vout\": 0}], {dest_address: 0.00020000})\n+    tx = rbf_node.signrawtransaction(tx)\n+    txid = rbf_node.sendrawtransaction(tx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction has descendants in the wallet\", rbf_node.bumpfee, parent_id)\n+\n+\n+def test_small_output_fails(rbf_node, dest_address):\n+    # cannot bump fee with a too-small output\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbf_node.bumpfee(rbfid, {\"totalFee\": 10000})\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    assert_raises_message(JSONRPCException, \"Change output is too small\", rbf_node.bumpfee, rbfid, {\"totalFee\": 10001})\n+\n+\n+def test_dust_to_fee(rbf_node, dest_address):\n+    # check that if output is reduced to dust, it will be converted to fee\n+    # the bumped tx sets fee=9900, but it converts to 10,000\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    fulltx = rbf_node.getrawtransaction(rbfid, 1)\n+    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 9900})\n+    full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n+    assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00010000\"))\n+    assert_equal(len(fulltx[\"vout\"]), 2)\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  #change output is eliminated\n+\n+\n+def test_settxfee(rbf_node, dest_address):\n+    # check that bumpfee reacts correctly to the use of settxfee (paytxfee)\n+    # increase feerate by 2.5x, test that fee increased at least 2x\n+    rbf_node.settxfee(Decimal(\"0.00001000\"))\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    rbf_node.settxfee(Decimal(\"0.00002500\"))\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] > 2 * abs(rbftx[\"fee\"])\n+    rbf_node.settxfee(Decimal(\"0.00000000\"))  # unset paytxfee\n+\n+\n+def test_rebumping(rbf_node, dest_address):\n+    # check that re-bumping the original tx fails, but bumping the bumper succeeds\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000}, Decimal(\"0.00001000\"))\n+    bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 1000})\n+    assert_raises_message(JSONRPCException, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 2000})\n+    rbf_node.bumpfee(bumped[\"txid\"], {\"totalFee\": 2000})\n+\n+\n+def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n+    # check that unconfirmed outputs from bumped transactions are not spendable\n+    rbfid = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)[\"hex\"]\n+    assert rbfid in rbf_node.getrawmempool()\n+    bumpid = rbf_node.bumpfee(rbfid)[\"txid\"]\n+    assert bumpid in rbf_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+\n+    # check that outputs from the bump transaction are not spendable\n+    # due to the replaces_txid check in CWallet::AvailableCoins\n+    assert_equal([t for t in rbf_node.listunspent(0) if t[\"txid\"] == bumpid], [])\n+\n+    # submit a block with the rbf tx to clear the bump transaction out\n+    # of the mempool, then invalidate the block so the rbf transaction will be\n+    # put back in the mempool. this makes it possible to check whether the rbf\n+    # transaction outputs are spendable before the rbf tx is confirmed.\n+    block = submit_block_with_tx(rbf_node, rbftx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95228707",
      "id" : 95228707,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 177,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 15777019,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95228707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "ACK modulo comments above.  ",
      "created_at" : "2017-01-09T19:35:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-271384781",
      "id" : 271384781,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-09T19:35:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271384781",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "Concept ACK, needs rebase.",
      "created_at" : "2017-01-10T19:37:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-271675511",
      "id" : 271675511,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-10T19:37:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271675511",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Rebased to handle named arguments.",
      "created_at" : "2017-01-10T22:44:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-271722085",
      "id" : 271722085,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-10T22:44:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271722085",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475856"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475856"
         }
      },
      "body" : "Added UpdateTransaction in e4a766291a90440d0ee8b8b25619cdd91329ffc2, and after a lot of struggle, eventually got a test to work which creates a segwit transaction and makes sure scriptWitness is set.\r\n\r\nThe test also uncovered another bug in the TransactionSignatureCreator call above where the SIGHASH_ALL value was incorrectly being interpretted as a CAmount. This is also fixed in e4a766291a90440d0ee8b8b25619cdd91329ffc2.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-10T22:48:48Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        input.scriptSig = sigdata.scriptSig;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475856",
      "id" : 95475856,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 194,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16031993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475915"
         }
      },
      "body" : "Removed in e4a766291a90440d0ee8b8b25619cdd91329ffc2.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-10T22:49:09Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475915",
      "id" : 95475915,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 29,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16032052,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475942"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475942"
         }
      },
      "body" : "Added in e4a766291a90440d0ee8b8b25619cdd91329ffc2.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-10T22:49:19Z",
      "diff_hunk" : "@@ -2581,6 +2583,209 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee/fallbackfee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95475942",
      "id" : 95475942,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16032076,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95475942",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95477645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95477645"
         }
      },
      "body" : "Added abandontransaction call in b0d4f9323250d81b53668362413134bc7a13d998.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-10T22:59:37Z",
      "diff_hunk" : "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework import blocktools\n+from test_framework.mininode import CTransaction\n+from test_framework.util import *\n+from test_framework.util import *\n+\n+import io\n+import time\n+\n+# Sequence number that is BIP 125 opt-in and BIP 68-compliant\n+BIP125_SEQUENCE_NUMBER = 0xfffffffd\n+\n+\n+class BumpFeeTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-walletrbf\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        rbf_node, peer_node = self.nodes\n+        rbf_node_address = rbf_node.getnewaddress()\n+\n+        # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n+        print(\"Mining blocks...\")\n+        self.nodes[1].generate(110)\n+        self.sync_all()\n+        for i in range(10):\n+            self.nodes[1].sendtoaddress(rbf_node_address, 0.001)\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), Decimal(\"0.01\"))\n+\n+        print(\"Running tests\")\n+        dest_address = peer_node.getnewaddress()\n+        test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address)\n+        test_nonrbf_bumpfee_fails(peer_node, dest_address)\n+        test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address)\n+        test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address)\n+        test_small_output_fails(rbf_node, dest_address)\n+        test_dust_to_fee(rbf_node, dest_address)\n+        test_settxfee(rbf_node, dest_address)\n+        test_rebumping(rbf_node, dest_address)\n+        test_unconfirmed_not_spendable(rbf_node, rbf_node_address)\n+        print(\"Success\")\n+\n+\n+def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    sync_mempools((rbf_node, peer_node))\n+    assert rbfid in rbf_node.getrawmempool() and rbfid in peer_node.getrawmempool()\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] - abs(rbftx[\"fee\"]) > 0\n+    # check that bumped_tx propogates, original tx was evicted and has a wallet conflict\n+    sync_mempools((rbf_node, peer_node))\n+    assert bumped_tx[\"txid\"] in rbf_node.getrawmempool()\n+    assert bumped_tx[\"txid\"] in peer_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+    assert rbfid not in peer_node.getrawmempool()\n+    oldwtx = rbf_node.gettransaction(rbfid)\n+    assert len(oldwtx[\"walletconflicts\"]) > 0\n+    # check wallet transaction replaces and replaced_by values\n+    bumpedwtx = rbf_node.gettransaction(bumped_tx[\"txid\"])\n+    assert_equal(oldwtx[\"replaced_by_txid\"], bumped_tx[\"txid\"])\n+    assert_equal(bumpedwtx[\"replaces_txid\"], rbfid)\n+\n+\n+def test_nonrbf_bumpfee_fails(peer_node, dest_address):\n+    # cannot replace a non RBF transaction (from node which did not enable RBF)\n+    not_rbfid = create_fund_sign_send(peer_node, {dest_address: 0.00090000})\n+    assert_raises_message(JSONRPCException, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n+\n+\n+def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n+    # cannot bump fee unless the tx has only inputs that we own.\n+    # here, the rbftx has a peer_node coin and then adds a rbf_node input\n+    # Note that this test depends upon the RPC code checking input ownership prior to change outputs\n+    # (since it can't use fundrawtransaction, it lacks a proper change output)\n+    utxos = [node.listunspent()[-1] for node in (rbf_node, peer_node)]\n+    inputs = [{\n+        \"txid\": utxo[\"txid\"],\n+        \"vout\": utxo[\"vout\"],\n+        \"address\": utxo[\"address\"],\n+        \"sequence\": BIP125_SEQUENCE_NUMBER\n+    } for utxo in utxos]\n+    output_val = sum(utxo[\"amount\"] for utxo in utxos) - Decimal(\"0.001\")\n+    rawtx = rbf_node.createrawtransaction(inputs, {dest_address: output_val})\n+    signedtx = rbf_node.signrawtransaction(rawtx)\n+    signedtx = peer_node.signrawtransaction(signedtx[\"hex\"])\n+    rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction contains inputs that don't belong to this wallet\",\n+                          rbf_node.bumpfee, rbfid)\n+\n+\n+def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n+    # cannot bump fee if the transaction has a descendant\n+    # parent is send-to-self, so we don't have to check which output is change when creating the child tx\n+    parent_id = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00050000})\n+    tx = rbf_node.createrawtransaction([{\"txid\": parent_id, \"vout\": 0}], {dest_address: 0.00020000})\n+    tx = rbf_node.signrawtransaction(tx)\n+    txid = rbf_node.sendrawtransaction(tx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction has descendants in the wallet\", rbf_node.bumpfee, parent_id)\n+\n+\n+def test_small_output_fails(rbf_node, dest_address):\n+    # cannot bump fee with a too-small output\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbf_node.bumpfee(rbfid, {\"totalFee\": 10000})\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    assert_raises_message(JSONRPCException, \"Change output is too small\", rbf_node.bumpfee, rbfid, {\"totalFee\": 10001})\n+\n+\n+def test_dust_to_fee(rbf_node, dest_address):\n+    # check that if output is reduced to dust, it will be converted to fee\n+    # the bumped tx sets fee=9900, but it converts to 10,000\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    fulltx = rbf_node.getrawtransaction(rbfid, 1)\n+    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 9900})\n+    full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n+    assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00010000\"))\n+    assert_equal(len(fulltx[\"vout\"]), 2)\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  #change output is eliminated\n+\n+\n+def test_settxfee(rbf_node, dest_address):\n+    # check that bumpfee reacts correctly to the use of settxfee (paytxfee)\n+    # increase feerate by 2.5x, test that fee increased at least 2x\n+    rbf_node.settxfee(Decimal(\"0.00001000\"))\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    rbf_node.settxfee(Decimal(\"0.00002500\"))\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] > 2 * abs(rbftx[\"fee\"])\n+    rbf_node.settxfee(Decimal(\"0.00000000\"))  # unset paytxfee\n+\n+\n+def test_rebumping(rbf_node, dest_address):\n+    # check that re-bumping the original tx fails, but bumping the bumper succeeds\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000}, Decimal(\"0.00001000\"))\n+    bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 1000})\n+    assert_raises_message(JSONRPCException, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 2000})\n+    rbf_node.bumpfee(bumped[\"txid\"], {\"totalFee\": 2000})\n+\n+\n+def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n+    # check that unconfirmed outputs from bumped transactions are not spendable\n+    rbfid = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)[\"hex\"]\n+    assert rbfid in rbf_node.getrawmempool()\n+    bumpid = rbf_node.bumpfee(rbfid)[\"txid\"]\n+    assert bumpid in rbf_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+\n+    # check that outputs from the bump transaction are not spendable\n+    # due to the replaces_txid check in CWallet::AvailableCoins\n+    assert_equal([t for t in rbf_node.listunspent(0) if t[\"txid\"] == bumpid], [])\n+\n+    # submit a block with the rbf tx to clear the bump transaction out\n+    # of the mempool, then invalidate the block so the rbf transaction will be\n+    # put back in the mempool. this makes it possible to check whether the rbf\n+    # transaction outputs are spendable before the rbf tx is confirmed.\n+    block = submit_block_with_tx(rbf_node, rbftx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95477645",
      "id" : 95477645,
      "original_commit_id" : "f4fa93b29a59c6d0f0341f442fd1805972b43ca1",
      "original_position" : 177,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 16033804,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95477645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95582692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95582692"
         }
      },
      "body" : "This should take place after `submit_block_with_tx` and before `invalidateblock`\r\nThat is the only time it is guaranteed that bumpid is not in the mempool.\r\n",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-11T14:00:59Z",
      "diff_hunk" : "@@ -213,6 +213,10 @@ def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n     assert bumpid not in rbf_node.getrawmempool()\n     assert rbfid in rbf_node.getrawmempool()\n \n+    # call abandontransaction to make sure the wallet does not add the bump\n+    # transaction back into the mempool.\n+    rbf_node.abandontransaction(bumpid)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95582692",
      "id" : 95582692,
      "original_commit_id" : "b0d4f9323250d81b53668362413134bc7a13d998",
      "original_position" : 6,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 16142046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95582692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95598215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95598215"
         }
      },
      "body" : "Oops, yes, I got confused about what the test was doing with the two transactions. Fixed and updated the comment in a1046e099e4fac8b82d6e268eeb9fb97e4a9c9ef.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-11T15:16:54Z",
      "diff_hunk" : "@@ -213,6 +213,10 @@ def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n     assert bumpid not in rbf_node.getrawmempool()\n     assert rbfid in rbf_node.getrawmempool()\n \n+    # call abandontransaction to make sure the wallet does not add the bump\n+    # transaction back into the mempool.\n+    rbf_node.abandontransaction(bumpid)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95598215",
      "id" : 95598215,
      "original_commit_id" : "b0d4f9323250d81b53668362413134bc7a13d998",
      "original_position" : 6,
      "path" : "qa/rpc-tests/bumpfee.py",
      "position" : null,
      "pull_request_review_id" : 16158462,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95598215",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "I believe this should make the new transaction non-RBF replaceable.  (1) we currently won't replace it, (2) if someone made an original payment and the receiver is squaking because it's replaceable, a mechanism is needed to issue a non-replacable version.   Since we won't replace it, we can do this in one step.   Does this make sense? ",
      "created_at" : "2017-01-12T01:26:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272049263",
      "id" : 272049263,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T01:26:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272049263",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Hm. I expected this to change the walletrbf default. ",
      "created_at" : "2017-01-12T01:31:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272050079",
      "id" : 272050079,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T01:31:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272050079",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95732721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95732721"
         }
      },
      "body" : "I can't see where it checks if the wallet is unlocked. Am I missing it?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T06:38:58Z",
      "diff_hunk" : "@@ -2582,6 +2584,211 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95732721",
      "id" : 95732721,
      "original_commit_id" : "a1046e099e4fac8b82d6e268eeb9fb97e4a9c9ef",
      "original_position" : 57,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16296522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95732721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "> Hm. I expected this to change the walletrbf default.\r\n\r\nI don't think we should change that last-minute for 0.14 (only mentioning that because this is tagged 0.14).\r\n\r\nEdit: Concept ACK otherwise.",
      "created_at" : "2017-01-12T11:09:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272136812",
      "id" : 272136812,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T13:54:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272136812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95792084"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95792084"
         }
      },
      "body" : "yikes that seems like a pretty big oversight",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T13:40:40Z",
      "diff_hunk" : "@@ -2582,6 +2584,211 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95792084",
      "id" : 95792084,
      "original_commit_id" : "a1046e099e4fac8b82d6e268eeb9fb97e4a9c9ef",
      "original_position" : 57,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16357840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95792084",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95815232"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95815232"
         }
      },
      "body" : "Added EnsureWalletIsUnlocked call in 59e425aa8e634a939e12594ce7c8824e9764e61c",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-12T15:29:24Z",
      "diff_hunk" : "@@ -2582,6 +2584,211 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\":       \\\"n\\\",          (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\":         \\\"n\\\",          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95815232",
      "id" : 95815232,
      "original_commit_id" : "a1046e099e4fac8b82d6e268eeb9fb97e4a9c9ef",
      "original_position" : 57,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16381814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95815232",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Created https://github.com/bitcoin/bitcoin/pull/9527 for changing the walletrbf default.",
      "created_at" : "2017-01-12T15:33:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272193979",
      "id" : 272193979,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T15:33:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272193979",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Added replaceable option in 8d3cd2844b844cad92d741d848ee0ffebdffef40, to allow users to create replacement transactions that are not replaceable.\r\n\r\nI ran into a lot of spurious errors related to `fundrawtransaction` in the bumpfee tests while trying to add a simple test for this. fundrawtransaction would sometimes chose different sized inputs than the `small_output_fails` and `dust_to_fee tests` were expecting, so I rewrote these tests in 13960f870c1ba94f391012f9c9243c59951ea6ab to manually create RBF transactions with the right inputs.\r\n\r\nI also ran into problems with `fundrawtransaction` using up all the right-sized inputs before these tests could use them, so I changed the order of the tests so they would run before any fundrawtransaction calls.\r\n\r\nI also ran into problems with `fundrawtransaction` sometimes chosing a higher fee for the RBF transaction than the `test_rebumping` test expected, causing the bumpfee command in the test to fail with an \"Invalid totalFee, must be at least ...\" error. I did not figure out what was causing this, but it seemed to somehow be related to the number of `peer_node.sendtoaddress(rbf_node_address, 0.001)` calls made during the test setup.",
      "created_at" : "2017-01-12T19:22:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272256286",
      "id" : 272256286,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T19:22:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272256286",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "re-ACK 8d3cd28",
      "created_at" : "2017-01-12T20:56:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272280878",
      "id" : 272280878,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T20:56:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272280878",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "tested ACK 8d3cd28\r\n",
      "created_at" : "2017-01-12T21:12:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272284948",
      "id" : 272284948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-12T21:12:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272284948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95889148"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95889148"
         }
      },
      "body" : "painfully obvious, but needs to be in mempool as well :)",
      "commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "created_at" : "2017-01-12T21:31:39Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95889148",
      "id" : 95889148,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 24,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 24,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-13T15:12:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95889148",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890149"
         }
      },
      "body" : "nit: maybe name the relay fee constant in case user wants to look it up.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T21:36:34Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890149",
      "id" : 95890149,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 32,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890149",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890163"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890163"
         }
      },
      "body" : "nit: add `n` here as well as below",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T21:36:38Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890163",
      "id" : 95890163,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 108,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890163",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890379"
         }
      },
      "body" : "can you explain why user-chosen feerate isn't an option, but absolute fee?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T21:37:40Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95890379",
      "id" : 95890379,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 38,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95890379",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95891750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95891750"
         }
      },
      "body" : "nit: or full RBF nodes relay it",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T21:45:08Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95891750",
      "id" : 95891750,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 44,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95891750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95892125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95892125"
         }
      },
      "body" : "nit: you already check that the wallet is available above, I believe unneeded. ",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T21:47:29Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95892125",
      "id" : 95892125,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 62,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95892125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95899033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95899033"
         }
      },
      "body" : "if this is the intended user flow, we might want to inform them via the following error message by including a totalfee guess alongside the minimum required feerate with a suggestion to use that option.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-12T22:25:15Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r95899033",
      "id" : 95899033,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 266,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95899033",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "Squashed 8d3cd2844b844cad92d741d848ee0ffebdffef40 -> 1d71fd0dab96430643b818ea993acea2aaa09256",
      "created_at" : "2017-01-13T14:02:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272449558",
      "id" : 272449558,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-13T14:02:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272449558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96012078"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96012078"
         }
      },
      "body" : "just set it",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T15:06:55Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96012078",
      "id" : 96012078,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 202,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 293,
      "pull_request_review_id" : 16460005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96012078",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96026308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96026308"
         }
      },
      "body" : "why does it need to be in the mempool?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T16:36:28Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96026308",
      "id" : 96026308,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 24,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16601686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96026308",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96026776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96026776"
         }
      },
      "body" : "(weird, comments are in wrong order) it doesn't you're right. ",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T16:39:48Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96026776",
      "id" : 96026776,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 24,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16602098,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96026776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96028852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96028852"
         }
      },
      "body" : "I guess I don't see how it makes a difference, but it seems to me that the whole point of this PR is to change the transaction to the least degree possible.  I don't know why someone would have chosen to set their sequence to 0xffffffff, but if they did, why should we change it for them here?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T16:52:11Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96028852",
      "id" : 96028852,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 202,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 293,
      "pull_request_review_id" : 16604347,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96028852",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033375"
         }
      },
      "body" : "Added in 7c9ad69f946f1db623d4243aa4a10fe57296cc4d",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:16:45Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033375",
      "id" : 96033375,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 32,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033441"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033441"
         }
      },
      "body" : "Removed in 7c9ad69f946f1db623d4243aa4a10fe57296cc4d",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:17:07Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033441",
      "id" : 96033441,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 62,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033483"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033483"
         }
      },
      "body" : "Added in 7c9ad69f946f1db623d4243aa4a10fe57296cc4d",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:17:22Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96033483",
      "id" : 96033483,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 266,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96033483",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96034071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96034071"
         }
      },
      "body" : "Options style here is the same as the style used in fundrawtransaction (and it seems clearer without all the n's and extra punctuation).",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:20:39Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96034071",
      "id" : 96034071,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 108,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96034071",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96035383"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96035383"
         }
      },
      "body" : "User chosen feerate is possible with settxfee, and could be added as another option here in the future. Absolute fee is a reasonable thing a user might want to set, probably determining it from the fee of the previous transaction.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:28:24Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96035383",
      "id" : 96035383,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 38,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96035383",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96036049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96036049"
         }
      },
      "body" : "Referring to nodes that don't follow BIP-125? Maybe a more general note about these nodes would be helpful, but it seems like an odd thing to mention only in this context.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T17:32:14Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96036049",
      "id" : 96036049,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 44,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16609310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96036049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96043848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96043848"
         }
      },
      "body" : "Hum, should we be ignoring the return value here? (We check it in some places, ignore it in others in wallet.cpp, but it seems wrong to ignore it).",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T18:17:20Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96043848",
      "id" : 96043848,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16620382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96043848",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96044619"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96044619"
         }
      },
      "body" : "I'm super not convinced that this is sufficient. See all the places where isAbandoned is checked - we probably need to check for replacement in most, if not all, of the same places.\r\n\r\neg probably want to check in RelayWalletTransaction and possibly isSpent?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T18:21:39Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96044619",
      "id" : 96044619,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16620382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96044619",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96045410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96045410"
         }
      },
      "body" : "Do we need/want a MarkDirty here, too? I think we might not need it, but it seems strange to not have it here when we have it in all the other similar things (conflicted, abandon, etc).",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T18:26:04Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);\n+\n+    NotifyTransactionChanged(this, originalHash, CT_UPDATED);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96045410",
      "id" : 96045410,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 36,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16620382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96045410",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96046375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96046375"
         }
      },
      "body" : "Obviously prefer to leave this in because belt-and-suspenders, but shouldn't this check be redundant with the !InMempool() check, two checks above?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T18:31:03Z",
      "diff_hunk" : "@@ -1958,6 +2011,35 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\"))\n+                continue;\n+\n+            // Similarly, we should not consider coins from transactions that\n+            // have been replaced. In the example above, we would want to prevent\n+            // creation of a transaction A' spending an output of A, because if\n+            // transaction B were initially confirmed, conflicting with A and\n+            // A', we wouldn't want to the user to create a transaction D\n+            // intending to replace A', but potentially resulting in a scenario\n+            // where A, A', and D could all be accepted (instead of just B and\n+            // D, or just A and A' like the user would want).\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\"))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96046375",
      "id" : 96046375,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 111,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16620382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96046375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96054845"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96054845"
         }
      },
      "body" : "This is being set specifically to change the behavior of AvailableCoins to avoid creating new transactions which spend outputs of rbf & bumpfee transactions, for reasons described in comments in AvailableCoins.\r\n\r\nI'm actually not sure why we don't mark the transaction that is being replaced to be abandoned. But I don't think it should make any practical difference right now.\r\n\r\nRelayWalletTransaction in the normal case should already skip this transaction because it conflicts with the bumpfee transaction and won't be in mempool.\r\n\r\nIsSpent could perhaps be written to not consider inputs of a transaction that's been replaced to be spent, though in practice it doesn't make a difference because the bumpfee replacing transaction always spends the same inputs as the replaced transaction.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T19:16:28Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96054845",
      "id" : 96054845,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16631966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96054845",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96060042"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96060042"
         }
      },
      "body" : "It's not completely redundant (see https://github.com/mrbandrews/bitcoin/blob/1d71fd0dab96430643b818ea993acea2aaa09256/qa/rpc-tests/bumpfee.py#L251 for the test which triggers this condition), but this is checking for a really esoteric case. See description above for all the gory details, but in this can happen when the replaced transaction A temporarily becomes part of a block instead of the replacing transaction B, and then gets added back to the mempool when there's a reorg.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T19:42:16Z",
      "diff_hunk" : "@@ -1958,6 +2011,35 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\"))\n+                continue;\n+\n+            // Similarly, we should not consider coins from transactions that\n+            // have been replaced. In the example above, we would want to prevent\n+            // creation of a transaction A' spending an output of A, because if\n+            // transaction B were initially confirmed, conflicting with A and\n+            // A', we wouldn't want to the user to create a transaction D\n+            // intending to replace A', but potentially resulting in a scenario\n+            // where A, A', and D could all be accepted (instead of just B and\n+            // D, or just A and A' like the user would want).\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\"))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96060042",
      "id" : 96060042,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 111,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16631966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96060042",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96062364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96062364"
         }
      },
      "body" : "Fee bumped should not imply abandoned -- it's entirely possible the original version of the transaction will confirm.\r\n\r\nChanging IsSpent as you suggest ought to have no visible effect (since bumpfee spends all the same inputs, currently), yet I think it would be incorrect to make your change -- if we add smarter fee bumping behavior in the future, and it becomes possible to drop an input from the original tx in a replacement transaction, we would still want to treat the original input as spent until the transaction that spends it becomes conflicted (or the user explicitly abandons it).\r\n\r\nIn RelayWalletTransaction, I think it's more debatable whether to attempt relay of the original version, but since it would only succeed if somehow the feebumped version dropped out of your mempool, I think it's reasonable for the wallet to attempt to relay unless the user explicitly calls abandontransaction on it.  We don't care which version gets mined, and if something is subtly wrong with the bumped transaction then we might as well attempt the original.  The effect on tx relay bandwidth should be negligible.\r\n\r\nAlso -- I believe this is no different behavior than if we have conflicting transactions in our wallet that originate via some means other than bumpfee.  For instance if someone sends funds to us and then fee bumps it themselves, we'll wind up with both transactions in our wallet, and we'll attempt to relay both, which I think is correct behavior.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T19:54:19Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96062364",
      "id" : 96062364,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16639616,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96062364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96063132"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96063132"
         }
      },
      "body" : "Will look more, but I would want to find a specific case it is needed before adding MarkDirty here. I have another PR https://github.com/bitcoin/bitcoin/pull/9381 which eliminates MarkDirty from AddToWallet() and will get rid of this entire MarkReplaced() method, replacing it with an AddToWallet call.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T19:58:49Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);\n+\n+    NotifyTransactionChanged(this, originalHash, CT_UPDATED);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96063132",
      "id" : 96063132,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 36,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16631966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96063132",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96063240"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96063240"
         }
      },
      "body" : "Will add a check.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T19:59:30Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96063240",
      "id" : 96063240,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16631966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96063240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96064667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96064667"
         }
      },
      "body" : "100% agree with sdaftuar.  it would be incorrect to auto abandon the bumpee.  ",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T20:08:12Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96064667",
      "id" : 96064667,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16642065,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96064667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96065043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96065043"
         }
      },
      "body" : "I don't think we should treat this differently from any other unconfirmed, conflicting transaction entering the wallet, so I don't believe this is necessary (and it seems confusing to me to add calls like that in places where we think that balances shouldn't be changing).",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T20:10:17Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);\n+\n+    NotifyTransactionChanged(this, originalHash, CT_UPDATED);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96065043",
      "id" : 96065043,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 36,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16642424,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96065043",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96065599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96065599"
         }
      },
      "body" : "I think we can just clean this up in a subsequent PR?  I agree that the differing behaviors are not good, but perhaps this is a small enough issue to not hold this up...",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T20:13:34Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96065599",
      "id" : 96065599,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16642972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96065599",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96068068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96068068"
         }
      },
      "body" : "Abandoned doesn't imply the original version of the transaction won't confirm, it just means \"pretend this isnt here, unless it somehow gets confirmed\"?\r\n\r\nBut, ok, fair point regarding IsSpent - I'm not convinced thats is definitely The Right Behavior to not allow a user to spend something they removed from their transaction, but this is the more conservative option, so have no problem with it for now.\r\n\r\nre: RelayWalletTransaction: I think this absolutely should have a replacement check...if a transaction has been replaced it shouldn't make it back into our mempool without the other transaction also replacing it, sure, but belt-and-suspenders. Plus a user could, theoretically, restart with a higher min relay fee (or upgrade to a new version), and this could break.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T20:27:57Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96068068",
      "id" : 96068068,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16645642,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96068068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96070260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96070260"
         }
      },
      "body" : "Either way seems fine. Added a check and error print for now in f9c4007977a25d53cc5ad9459db51a831fb8ae89.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T20:42:24Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96070260",
      "id" : 96070260,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16647935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96070260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96070737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96070737"
         }
      },
      "body" : "I only brought it up because I'd prefer new code to check it...it seems bad to not do so.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T20:45:33Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96070737",
      "id" : 96070737,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16648440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96070737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96074805"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96074805"
         }
      },
      "body" : "Agreed, check is added in f9c4007977a25d53cc5ad9459db51a831fb8ae89.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T21:12:14Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+    walletdb.WriteTx(wtx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96074805",
      "id" : 96074805,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 34,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16652854,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96074805",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96075289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96075289"
         }
      },
      "body" : "I'll withdraw my request after IRC discussion. I've been convinced that in some use-cases a user might prefer us to accept the old version of a transaction which has been bumped, so no need to change that.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T21:15:35Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96075289",
      "id" : 96075289,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16653403,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96075289",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96077369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96077369"
         }
      },
      "body" : "Long discussion in IRC about this beginning here: https://botbot.me/freenode/bitcoin-core-dev/msg/79332875/.\r\n\r\nI think the conclusion is that it is preferable to keep the current code which attempts to add all replaced and replacing transactions to the mempool , because there are cases when there is a problem with the replacing tx (e.g. output too close to dust limit) that would cause it to get rejected from mempool, and where it would be preferable to relay the original replaced transaction.\r\n\r\nAlso, the risk of the wallet relaying both replaced and replaced transactions to peers is very low. It will not happen unless a CWallet::ResendWalletTransactions call somehow is made before the initial CWallet::ReacceptWalletTransactions call in CWallet::postInitProcess finishes.\r\n",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-13T21:28:06Z",
      "diff_hunk" : "@@ -826,6 +833,29 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+    if (mi == mapWallet.end())\n+        return false;\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96077369",
      "id" : 96077369,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 31,
      "path" : "src/wallet/wallet.cpp",
      "position" : 32,
      "pull_request_review_id" : 16655623,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96077369",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96082690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96082690"
         }
      },
      "body" : "It says in the wallet, not the mempool...?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T22:01:14Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96082690",
      "id" : 96082690,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 24,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16661267,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96082690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96084174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96084174"
         }
      },
      "body" : "\"(though it may still be replacable in practice)\" seems sufficient.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T22:11:12Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96084174",
      "id" : 96084174,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 44,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16662882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96084174",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092534"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092534"
         }
      },
      "body" : "`>3` now... but I don't know that we need an explicit check here. Seems like asking for bugs.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:13:07Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092534",
      "id" : 96092534,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 112,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092534",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092748"
         }
      },
      "body" : "Should be `1` now (as of #9239). Maybe make a const int in some header for this number...",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:14:56Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092748",
      "id" : 96092748,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 126,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092748",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092826"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092826"
         }
      },
      "body" : "`get_int64`",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:15:44Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96092826",
      "id" : 96092826,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 129,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96092826",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96093010"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96093010"
         }
      },
      "body" : "Prefer to just do:\r\n\r\n```C++\r\nif (options.exists(\"replaceable\")) {\r\n    replaceable = options[\"replaceable\"].get_bool();\r\n}\r\n```\r\n\r\nSo that if the default changes, this still works right.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:17:21Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96093010",
      "id" : 96093010,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 137,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96093010",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96094023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96094023"
         }
      },
      "body" : "So long as the user is explicitly setting a total fee, we should either fail when discarding dust, or at least document this behaviour in the RPC help.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:25:31Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96094023",
      "id" : 96094023,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 195,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 287,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96094023",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96094125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96094125"
         }
      },
      "body" : "Agreed with @morcos, leave this as-is.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:26:29Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96094125",
      "id" : 96094125,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 202,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 293,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96094125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96095311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96095311"
         }
      },
      "body" : "Maybe just add `\"errors\"` to the response below?",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-13T23:38:06Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        UpdateTransaction(tx, nIn, sigdata);\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state) || !state.IsValid())\n+        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+\n+    // mark the original tx as bumped\n+    if (!pwalletMain->MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n+        // TODO: see if JSON-RPC has a standard way of returning a response\n+        // along with an exception. It would be good to return information about\n+        // wtxBumped to the caller even if marking the original transaction\n+        // replaced does not succeed for some reason.\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Unable to mark the original transaction as replaced.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96095311",
      "id" : 96095311,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 234,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16671446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96095311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96098001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96098001"
         }
      },
      "body" : "nothing bad happens if you call it with 1, i think it makes most sense to allow users to select 1 meaning as fast as possible, and then we just return the fastest estimate we're comfortable with",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-14T00:06:42Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96098001",
      "id" : 96098001,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 126,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16676880,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96098001",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96098610"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96098610"
         }
      },
      "body" : "Okay",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-14T00:14:17Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96098610",
      "id" : 96098610,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 126,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16677539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96098610",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149281"
         }
      },
      "body" : "Makes sense, removed in 23c389ab8697bc0040cfd45a32d282906554a84a.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:21:00Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149281",
      "id" : 96149281,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 112,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149281",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149335"
         }
      },
      "body" : "Ok, keeping as is to change the transaction as little as possible.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:22:29Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\",\n+                                               FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149335",
      "id" : 96149335,
      "original_commit_id" : "1d71fd0dab96430643b818ea993acea2aaa09256",
      "original_position" : 202,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 293,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149671"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149671"
         }
      },
      "body" : "Clarified the error message in 23c389ab8697bc0040cfd45a32d282906554a84a. If there are other examples of returning an \"errors\" key in a RPC response, I could change this to conform. But my preference would be to keep the exception (since this would be a sign of a serious problem that should not be ignored) and to just return more complete status information with the exception.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:35:42Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        UpdateTransaction(tx, nIn, sigdata);\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state) || !state.IsValid())\n+        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+\n+    // mark the original tx as bumped\n+    if (!pwalletMain->MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n+        // TODO: see if JSON-RPC has a standard way of returning a response\n+        // along with an exception. It would be good to return information about\n+        // wtxBumped to the caller even if marking the original transaction\n+        // replaced does not succeed for some reason.\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Unable to mark the original transaction as replaced.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149671",
      "id" : 96149671,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 234,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149671",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149705"
         }
      },
      "body" : "morcos was responding to a review comment \"painfully obvious, but needs to be in mempool as well :)\" that is gone now.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:37:41Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96149705",
      "id" : 96149705,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 24,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96149705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150047"
         }
      },
      "body" : "Reworded, adding \"for example\" in 23c389ab8697bc0040cfd45a32d282906554a84a. Just saying non-replaceable transactions are replaceable sounds mysterious. Maybe I'm less knowledgeable than the target user, but at least I would find it confusing.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:51:51Z",
      "diff_hunk" : "@@ -2582,6 +2584,232 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150047",
      "id" : 96150047,
      "original_commit_id" : "8d3cd2844b844cad92d741d848ee0ffebdffef40",
      "original_position" : 44,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150117"
         }
      },
      "body" : "Thanks, fixed in 23c389ab8697bc0040cfd45a32d282906554a84a.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:54:59Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150117",
      "id" : 96150117,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 129,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150124"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150124"
         }
      },
      "body" : "Good point, fixed in 23c389ab8697bc0040cfd45a32d282906554a84a.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T22:55:10Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150124",
      "id" : 96150124,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 137,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150124",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150335"
         }
      },
      "body" : "Added note to totalFee documentation in 4e1a04002b0783d53c27eaed8df4ddb2bded6bf7.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-15T23:04:17Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96150335",
      "id" : 96150335,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 195,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 287,
      "pull_request_review_id" : 16725044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96150335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "I know other ways of calling getbalance are pretty broken (#8183), but I think we need to fix a bit of how bumpfee interacts with getbalance \"\\*\". In testing I got getbalance \"\\*\" to give me a negative number, which seems super shitty.\r\n\r\nAdditionally, we need documentation on how bumpfee interacts with listunspent. While I dont mind the change outputs from bumpfee not appearing in the results, this is likely to be surprising to users (I believe this only otherwise occurs if the transaction was abandoned), so needs documented.",
      "created_at" : "2017-01-16T00:39:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272750912",
      "id" : 272750912,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-16T22:58:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272750912",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96156341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96156341"
         }
      },
      "body" : "I'd vote against making this statement.\r\nI think it should be a more general principle of our wallet that you might always lose unexpectedly something on the order of the dust threshold, rather than explicitly mention it every time we think it could happen.   But if I'm outvoted, so be it..\r\n",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-16T02:10:09Z",
      "diff_hunk" : "@@ -2609,7 +2609,10 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             \"2. options               (object, optional)\\n\"\n             \"   {\\n\"\n             \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n-            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96156341",
      "id" : 96156341,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 6,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16731890,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96156341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "@TheBlueMatt I don't see how this PR has any affect on any of the getbalance calls.  I think what you are seeing is pre-existing misbehavior for multiple spends of the same outputs being present in the wallet.   \r\n\r\nI went through all the calls to AvailableCoins (which is the only thing this PR changes) and I think the only open decision is deciding what we want the interaction with listunspent to be and documenting it.\r\n\r\n",
      "created_at" : "2017-01-16T02:30:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-272760263",
      "id" : 272760263,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-16T02:30:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/272760263",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96330335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96330335"
         }
      },
      "body" : "I think if you have specified a manual confTarget you probably want to always take this branch.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-17T01:33:53Z",
      "diff_hunk" : "@@ -2582,6 +2584,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+    }\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) { // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+            }\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int64();\n+            if (totalFee <= 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            } else if (totalFee > maxTxFee) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+            }\n+        }\n+\n+        if (options.exists(\"replaceable\")) {\n+            replaceable = options[\"replaceable\"].get_bool();\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96330335",
      "id" : 96330335,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 175,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16908479,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96330335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96332908"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96332908"
         }
      },
      "body" : "I believe this and the check further down should have a fOnlyConfirmed && at the beginning to avoid not showing the tx currently in mempool's change output in listunspent, which I think would be the correct behavior.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-17T02:08:58Z",
      "diff_hunk" : "@@ -1958,6 +2017,37 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96332908",
      "id" : 96332908,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 106,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16910930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96332908",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96333048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96333048"
         }
      },
      "body" : "Or maybe only the one below, but in either case should be well-documented.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-17T02:10:50Z",
      "diff_hunk" : "@@ -1958,6 +2017,37 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96333048",
      "id" : 96333048,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 106,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 16911065,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96333048",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96440795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96440795"
         }
      },
      "body" : "Added in 0f83aa3a1e1b2668a6231a1660ed864e2da3a341.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-17T15:51:07Z",
      "diff_hunk" : "@@ -1958,6 +2017,37 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96440795",
      "id" : 96440795,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 106,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 17022253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96440795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96443450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96443450"
         }
      },
      "body" : "note: in the future we should rename and invert the AvailableCoins argument to this. ",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-17T16:01:29Z",
      "diff_hunk" : "@@ -2413,11 +2417,17 @@ UniValue listunspent(const JSONRPCRequest& request)\n         }\n     }\n \n+    bool include_untrusted = true;\n+    if (request.params.size() > 3 && !request.params[3].isNull()) {\n+        RPCTypeCheckArgument(request.params[3], UniValue::VBOOL);\n+        include_untrusted = request.params[3].get_bool();\n+    }\n+\n     UniValue results(UniValue::VARR);\n     vector<COutput> vecOutputs;\n     assert(pwalletMain != NULL);\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n-    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    pwalletMain->AvailableCoins(vecOutputs, !include_untrusted, NULL, true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96443450",
      "id" : 96443450,
      "original_commit_id" : "759a7cd0b602003dc1dc990b8fca5025bd03ae7e",
      "original_position" : 62,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 17025124,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-17T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96443450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96450396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96450396"
         }
      },
      "body" : "Done in a29b3f557fe8b7bb8e1b28933f3d5a4a3a36d362.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-17T16:27:49Z",
      "diff_hunk" : "@@ -2582,6 +2584,258 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+    }\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) { // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+            }\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int64();\n+            if (totalFee <= 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            } else if (totalFee > maxTxFee) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+            }\n+        }\n+\n+        if (options.exists(\"replaceable\")) {\n+            replaceable = options[\"replaceable\"].get_bool();\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96450396",
      "id" : 96450396,
      "original_commit_id" : "4e1a04002b0783d53c27eaed8df4ddb2bded6bf7",
      "original_position" : 175,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 17032285,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96450396",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Squashed 28fd457a73fc6291f72d89d9dd3532ada9ebe35c -> ce3a363049bf8fdd8be926ca3ab8c803c98de6d2.",
      "created_at" : "2017-01-17T17:20:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273235705",
      "id" : 273235705,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-17T17:20:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273235705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "utACK ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-17T18:08:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273249816",
      "id" : 273249816,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-17T18:08:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273249816",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "tested previous iteration ACK ce3a363",
      "created_at" : "2017-01-17T18:09:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273250019",
      "id" : 273250019,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-17T18:09:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273250019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96696736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96696736"
         }
      },
      "body" : "I would worry that a caller might ignore the error and try again, but I guess the harm risk of that is minimal with bumpfee.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-18T18:04:02Z",
      "diff_hunk" : "@@ -2582,6 +2584,236 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice if it has unconfirmed ancestors which are\\n\"\n+            \"                         replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash))\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1)\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\"))\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1)\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        if (options.size() > 2)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+        }\n+\n+        if (options.exists(\"replaceable\") && !options[\"replaceable\"].get_bool()) {\n+            replaceable = false;\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        nNewFeeRate = payTxFee;\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0)\n+            nNewFeeRate = CWallet::fallbackFee;\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK())\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK())\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta)\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        UpdateTransaction(tx, nIn, sigdata);\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state) || !state.IsValid())\n+        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+\n+    // mark the original tx as bumped\n+    if (!pwalletMain->MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n+        // TODO: see if JSON-RPC has a standard way of returning a response\n+        // along with an exception. It would be good to return information about\n+        // wtxBumped to the caller even if marking the original transaction\n+        // replaced does not succeed for some reason.\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Unable to mark the original transaction as replaced.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96696736",
      "id" : 96696736,
      "original_commit_id" : "f9c4007977a25d53cc5ad9459db51a831fb8ae89",
      "original_position" : 234,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 17286343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-18T18:04:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96696736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96697253"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96697253"
         }
      },
      "body" : "This seems redundant. Type-checking is the purpose of the .get_&lt;type> methods on UniValue.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-18T18:06:40Z",
      "diff_hunk" : "@@ -79,16 +79,20 @@ void RPCTypeCheck(const UniValue& params,\n             break;\n \n         const UniValue& v = params[i];\n-        if (!((v.type() == t) || (fAllowNull && (v.isNull()))))\n-        {\n-            string err = strprintf(\"Expected type %s, got %s\",\n-                                   uvTypeName(t), uvTypeName(v.type()));\n-            throw JSONRPCError(RPC_TYPE_ERROR, err);\n+        if (!(fAllowNull && v.isNull())) {\n+            RPCTypeCheckArgument(v, t);\n         }\n         i++;\n     }\n }\n \n+void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96697253",
      "id" : 96697253,
      "original_commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "original_position" : 16,
      "path" : "src/rpc/server.cpp",
      "position" : 16,
      "pull_request_review_id" : 17286929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-18T18:06:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96697253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96697761"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96697761"
         }
      },
      "body" : "We absolutely do not use .get_<type>'s built-in type check anywhere - it throws a different type of exception which will not be correctly reported as an RPC_TYPE_ERROR.",
      "commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "created_at" : "2017-01-18T18:09:19Z",
      "diff_hunk" : "@@ -79,16 +79,20 @@ void RPCTypeCheck(const UniValue& params,\n             break;\n \n         const UniValue& v = params[i];\n-        if (!((v.type() == t) || (fAllowNull && (v.isNull()))))\n-        {\n-            string err = strprintf(\"Expected type %s, got %s\",\n-                                   uvTypeName(t), uvTypeName(v.type()));\n-            throw JSONRPCError(RPC_TYPE_ERROR, err);\n+        if (!(fAllowNull && v.isNull())) {\n+            RPCTypeCheckArgument(v, t);\n         }\n         i++;\n     }\n }\n \n+void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96697761",
      "id" : 96697761,
      "original_commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "original_position" : 16,
      "path" : "src/rpc/server.cpp",
      "position" : 16,
      "pull_request_review_id" : 17287459,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-18T18:09:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96697761",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "utACK ce3a363049bf8fdd8be926ca3ab8c803c98de6d2 (reviewed diff from last iteration I tested and ACKed above).",
      "created_at" : "2017-01-18T19:59:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273584313",
      "id" : 273584313,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-18T19:59:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273584313",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96727363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96727363"
         }
      },
      "body" : "Changed wording in 4beb7c92c70b7668042383d37c49545198aa00cd.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-18T20:32:49Z",
      "diff_hunk" : "@@ -2364,6 +2366,10 @@ UniValue listunspent(const JSONRPCRequest& request)\n             \"      \\\"address\\\"   (string) bitcoin address\\n\"\n             \"      ,...\\n\"\n             \"    ]\\n\"\n+            \"4. include_unsafe (bool, optional, default=true) Include outputs that are not safe to spend\\n\"\n+            \"                  because they come from unconfirmed untrusted transactions or unconfirmed\\n\"\n+            \"                  replacement transactions (cases where we can't be sure a conflicting\\n\"\n+            \"                  transaction won't be mined).\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96727363",
      "id" : 96727363,
      "original_commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "original_position" : 30,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 17318476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96727363",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96727791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96727791"
         }
      },
      "body" : "Interesting. I wasn't following the named argument discussion in detail, but I thought named arguments would be preferable to options because they are easier to specify on the command line. But maybe there are advantages to options objects that I'm not aware of.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-18T20:34:58Z",
      "diff_hunk" : "@@ -2350,9 +2352,9 @@ UniValue listunspent(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (request.fHelp || request.params.size() > 3)\n+    if (request.fHelp || request.params.size() > 4)\n         throw runtime_error(\n-            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] )\\n\"\n+            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] )\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96727791",
      "id" : 96727791,
      "original_commit_id" : "ce3a363049bf8fdd8be926ca3ab8c803c98de6d2",
      "original_position" : 19,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 19,
      "pull_request_review_id" : 17318902,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T16:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96727791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Squashed 4beb7c92c70b7668042383d37c49545198aa00cd -> cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-19T16:31:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273825274",
      "id" : 273825274,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-19T16:31:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273825274",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Still ACK cc0243a",
      "created_at" : "2017-01-19T18:13:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-273853554",
      "id" : 273853554,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2017-01-19T18:13:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273853554",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96925962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96925962"
         }
      },
      "body" : "ultra-nit: \"bumped\" is a bit confusing since it's already used in another sense(bumped fee), \"replace\" is likely better.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-19T18:34:56Z",
      "diff_hunk" : "@@ -2595,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r96925962",
      "id" : 96925962,
      "original_commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "original_position" : 96,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 165,
      "pull_request_review_id" : 17524852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-19T18:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96925962",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97000879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97000879"
         }
      },
      "body" : "Should probably have an option to override this.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-20T02:10:26Z",
      "diff_hunk" : "@@ -2582,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97000879",
      "id" : 97000879,
      "original_commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "original_position" : 160,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 160,
      "pull_request_review_id" : 17601366,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-20T02:10:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97000879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3298484?v=3",
         "events_url" : "https://api.github.com/users/jameshilliard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jameshilliard/followers",
         "following_url" : "https://api.github.com/users/jameshilliard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jameshilliard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jameshilliard",
         "id" : 3298484,
         "login" : "jameshilliard",
         "organizations_url" : "https://api.github.com/users/jameshilliard/orgs",
         "received_events_url" : "https://api.github.com/users/jameshilliard/received_events",
         "repos_url" : "https://api.github.com/users/jameshilliard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jameshilliard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jameshilliard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jameshilliard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97013772"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97013772"
         }
      },
      "body" : "An option to signal RBF in the original transaction (which already exists, see -walletrbf option, and #9592, #9527), or an option to create a bumpfee transaction even if the original doesn't signal RBF?",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-20T05:14:37Z",
      "diff_hunk" : "@@ -2582,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97013772",
      "id" : 97013772,
      "original_commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "original_position" : 160,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 160,
      "pull_request_review_id" : 17614336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-20T05:14:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97013772",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97014539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97014539"
         }
      },
      "body" : "An option to create a bumpfee transaction regardless of if the original signaled RBF since some nodes may accept it.",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-20T05:26:55Z",
      "diff_hunk" : "@@ -2582,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97014539",
      "id" : 97014539,
      "original_commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "original_position" : 160,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 160,
      "pull_request_review_id" : 17615143,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-20T05:26:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97014539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3298484?v=3",
         "events_url" : "https://api.github.com/users/jameshilliard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jameshilliard/followers",
         "following_url" : "https://api.github.com/users/jameshilliard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jameshilliard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jameshilliard",
         "id" : 3298484,
         "login" : "jameshilliard",
         "organizations_url" : "https://api.github.com/users/jameshilliard/orgs",
         "received_events_url" : "https://api.github.com/users/jameshilliard/received_events",
         "repos_url" : "https://api.github.com/users/jameshilliard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jameshilliard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jameshilliard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jameshilliard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97621411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97621411"
         }
      },
      "body" : "There was some discussion about this idea in IRC https://botbot.me/freenode/bitcoin-core-dev/msg/79836432/ (unclear what the outcome was)",
      "commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "created_at" : "2017-01-24T18:51:32Z",
      "diff_hunk" : "@@ -2582,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r97621411",
      "id" : 97621411,
      "original_commit_id" : "cc0243ad32cee1cc9faab317364b889beaf07647",
      "original_position" : 160,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 160,
      "pull_request_review_id" : 18237114,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2017-01-24T18:51:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/97621411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   }
]
