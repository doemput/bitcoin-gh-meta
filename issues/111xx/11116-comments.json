[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134655141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134655141"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-08-23T04:32:16Z",
      "diff_hunk" : "@@ -46,6 +46,8 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n+    isInvalid = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134655141",
      "id" : 134655141,
      "original_commit_id" : "0d8d5d6fd40a25fb2fa162218fefed027ee3c8e4",
      "original_position" : 4,
      "path" : "src/script/ismine.cpp",
      "position" : 4,
      "pull_request_review_id" : 57971157,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134655141",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134718483"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134718483"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This variable is unused.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-08-23T10:51:15Z",
      "diff_hunk" : "@@ -0,0 +1,752 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    solutions.clear();\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+    CTxDestination dest;\n+\n+    // CKeyID\n+    dest = pubkeys[0].GetID();\n+    expected.clear();\n+    expected << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForDestination(pubkeys[0].GetID());\n+    BOOST_CHECK(result == expected);\n+\n+    // CScriptID\n+    CScript redeemScript(result);\n+    dest = CScriptID(redeemScript);\n+    expected.clear();\n+    expected << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    result = GetScriptForDestination(CScriptID(redeemScript));\n+    BOOST_CHECK(result == expected);\n+\n+    // CNoDestination\n+    expected.clear();\n+    result = GetScriptForDestination(CNoDestination());\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForRawPubKey\n+    expected.clear();\n+    expected << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    result = GetScriptForRawPubKey(pubkeys[0]);\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForMultisig\n+    expected.clear();\n+    expected << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    result = GetScriptForMultisig(2, std::vector<CPubKey>(pubkeys, pubkeys + 3));\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForWitness\n+    CScript witnessScript;\n+\n+    witnessScript << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_1 << ToByteVector(pubkeys[0]) << OP_1 << OP_CHECKMULTISIG;\n+\n+    uint256 scriptHash;\n+    CSHA256().Write(&witnessScript[0], witnessScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(scriptHash);\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n+{\n+    CKey keys[2];\n+    CPubKey pubkeys[2];\n+    for (int i = 0; i < 2; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CPubKey uncompressedPubkey0(pubkeys[0]);\n+    uncompressedPubkey0.Decompress();\n+\n+    CScript scriptPubKey;\n+    isminetype result;\n+    bool isInvalid;\n+\n+    // P2PK compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PK uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(uncompressedPubkey0) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKeyPubKey(keys[0], uncompressedPubkey0);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PKH compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PKH uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_DUP << OP_HASH160 << ToByteVector(uncompressedPubkey0.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKeyPubKey(keys[0], uncompressedPubkey0);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2SH\n+    {\n+        CBasicKeyStore keystore;\n+\n+        CScript redeemScript;\n+        redeemScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+\n+        // Keystore does not have redeemScript or key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has redeemScript but no key\n+        keystore.AddCScript(redeemScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has redeemScript and key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2WPKH compressed\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        CScript witnessScript;\n+        witnessScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134718483",
      "id" : 134718483,
      "original_commit_id" : "0d8d5d6fd40a25fb2fa162218fefed027ee3c8e4",
      "original_position" : 514,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 58041350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134718483",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134808635"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134808635"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could you please explain why? Since `isValid` is a return parameter, I think it should get set to `false` from an initial value of `true` if the script is not invalid.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-08-23T16:53:21Z",
      "diff_hunk" : "@@ -46,6 +46,8 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n+    isInvalid = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r134808635",
      "id" : 134808635,
      "in_reply_to_id" : 134655141,
      "original_commit_id" : "0d8d5d6fd40a25fb2fa162218fefed027ee3c8e4",
      "original_position" : 4,
      "path" : "src/script/ismine.cpp",
      "position" : 4,
      "pull_request_review_id" : 58145155,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/134808635",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "body" : "> Without a6564cc, P2WPKH scripts where the pubkey is uncompressed are incorrectly\r\n\r\nsounds correct to change; but how would a P2WPKH redeem script for such a key end up in the wallet in the first place? (trying to gauge severity; if it's only accessible inside the code it's good to fix but not e.g. something we need to worry about end users hitting.)",
      "created_at" : "2017-08-26T00:26:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-325063107",
      "id" : 325063107,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-08-26T00:28:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325063107",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@gmaxwell I haven't looked through the wallet code enough to know. I assume it would not happen, and it's just a bug in some internals that wouldn't be exercised, but I'm not 100% sure. I came across it through unit tests, not end-to-end testing of the wallet.",
      "created_at" : "2017-08-26T00:30:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-325063617",
      "id" : 325063617,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-08-26T00:30:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325063617",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "body" : "Great okay! just making sure you weren't aware of any.",
      "created_at" : "2017-08-26T00:31:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-325063686",
      "id" : 325063686,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-08-26T00:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325063686",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@jimpo If a6564cc has any effect, I think it's a sign there is a more severe issue, namely that the CKeyID and the CKey in the CBasicKeyStore's map are not in sync with each other (as the CKey stores the compressedness too). I'd rather investigate that discrepancy first.\r\n\r\nEDIT: it seems it's just the test code that's wrong. You're calling AddKeyPubKey with a CKey and CPubKey that don't correspond (different compressedness).",
      "created_at" : "2017-08-27T19:52:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-325220347",
      "id" : 325220347,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-08-27T19:55:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325220347",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r135419689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/135419689"
         }
      },
      "author_association" : "OWNER",
      "body" : "You're adding a compressed CKey (`keys[0]`) with an uncompressed CPubKey, which is incorrect use of the function. You should first change the CKey's compressedness.\r\n\r\nPerhaps this warrants a comment on AddKeyPubKey or even an assert. It should alleviate the need for a6564cca7d443789671778f769a24bbb5a4a0652 though.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-08-27T19:57:05Z",
      "diff_hunk" : "@@ -0,0 +1,746 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    solutions.clear();\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+    CTxDestination dest;\n+\n+    // CKeyID\n+    dest = pubkeys[0].GetID();\n+    expected.clear();\n+    expected << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForDestination(pubkeys[0].GetID());\n+    BOOST_CHECK(result == expected);\n+\n+    // CScriptID\n+    CScript redeemScript(result);\n+    dest = CScriptID(redeemScript);\n+    expected.clear();\n+    expected << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    result = GetScriptForDestination(CScriptID(redeemScript));\n+    BOOST_CHECK(result == expected);\n+\n+    // CNoDestination\n+    expected.clear();\n+    result = GetScriptForDestination(CNoDestination());\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForRawPubKey\n+    expected.clear();\n+    expected << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    result = GetScriptForRawPubKey(pubkeys[0]);\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForMultisig\n+    expected.clear();\n+    expected << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    result = GetScriptForMultisig(2, std::vector<CPubKey>(pubkeys, pubkeys + 3));\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForWitness\n+    CScript witnessScript;\n+\n+    witnessScript << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_1 << ToByteVector(pubkeys[0]) << OP_1 << OP_CHECKMULTISIG;\n+\n+    uint256 scriptHash;\n+    CSHA256().Write(&witnessScript[0], witnessScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(scriptHash);\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n+{\n+    CKey keys[2];\n+    CPubKey pubkeys[2];\n+    for (int i = 0; i < 2; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CPubKey uncompressedPubkey0(pubkeys[0]);\n+    uncompressedPubkey0.Decompress();\n+\n+    CScript scriptPubKey;\n+    isminetype result;\n+    bool isInvalid;\n+\n+    // P2PK compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PK uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(uncompressedPubkey0) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKeyPubKey(keys[0], uncompressedPubkey0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r135419689",
      "id" : 135419689,
      "original_commit_id" : "e6eed352fbcfd69f82815ecfaf1e367018c8c3ba",
      "original_position" : 438,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 58830335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/135419689",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r135420496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/135420496"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, will change.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-08-27T20:28:11Z",
      "diff_hunk" : "@@ -0,0 +1,746 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    solutions.clear();\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+    CTxDestination dest;\n+\n+    // CKeyID\n+    dest = pubkeys[0].GetID();\n+    expected.clear();\n+    expected << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForDestination(pubkeys[0].GetID());\n+    BOOST_CHECK(result == expected);\n+\n+    // CScriptID\n+    CScript redeemScript(result);\n+    dest = CScriptID(redeemScript);\n+    expected.clear();\n+    expected << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    result = GetScriptForDestination(CScriptID(redeemScript));\n+    BOOST_CHECK(result == expected);\n+\n+    // CNoDestination\n+    expected.clear();\n+    result = GetScriptForDestination(CNoDestination());\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForRawPubKey\n+    expected.clear();\n+    expected << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    result = GetScriptForRawPubKey(pubkeys[0]);\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForMultisig\n+    expected.clear();\n+    expected << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    result = GetScriptForMultisig(2, std::vector<CPubKey>(pubkeys, pubkeys + 3));\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForWitness\n+    CScript witnessScript;\n+\n+    witnessScript << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_1 << ToByteVector(pubkeys[0]) << OP_1 << OP_CHECKMULTISIG;\n+\n+    uint256 scriptHash;\n+    CSHA256().Write(&witnessScript[0], witnessScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(scriptHash);\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n+{\n+    CKey keys[2];\n+    CPubKey pubkeys[2];\n+    for (int i = 0; i < 2; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CPubKey uncompressedPubkey0(pubkeys[0]);\n+    uncompressedPubkey0.Decompress();\n+\n+    CScript scriptPubKey;\n+    isminetype result;\n+    bool isInvalid;\n+\n+    // P2PK compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PK uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(uncompressedPubkey0) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKeyPubKey(keys[0], uncompressedPubkey0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r135420496",
      "id" : 135420496,
      "in_reply_to_id" : 135419689,
      "original_commit_id" : "e6eed352fbcfd69f82815ecfaf1e367018c8c3ba",
      "original_position" : 438,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 58830989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/135420496",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "body" : "Thanks for the review @sipa. I had forgotten that CKey tracks the compressedness. Updated the test and removed the change to CBasicKeyStore.",
      "created_at" : "2017-08-28T16:41:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-325406975",
      "id" : 325406975,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-08-28T16:41:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325406975",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r137856830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137856830"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ok, got it.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-08T18:18:13Z",
      "diff_hunk" : "@@ -46,6 +46,8 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n+    isInvalid = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r137856830",
      "id" : 137856830,
      "in_reply_to_id" : 134655141,
      "original_commit_id" : "0d8d5d6fd40a25fb2fa162218fefed027ee3c8e4",
      "original_position" : 4,
      "path" : "src/script/ismine.cpp",
      "position" : 4,
      "pull_request_review_id" : 61583770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137856830",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK",
      "created_at" : "2017-09-08T18:44:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#issuecomment-328183935",
      "id" : 328183935,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11116",
      "updated_at" : "2017-09-08T18:44:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328183935",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r139928791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/139928791"
         }
      },
      "author_association" : "MEMBER",
      "body" : "why? It is the task of the solver to set the size of the vector to 0. Otherwise you could as well remove the `BOOST_CHECK_EQUAL(solutions.size(), 0);`, no?",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-20T10:11:57Z",
      "diff_hunk" : "@@ -0,0 +1,747 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r139928791",
      "id" : 139928791,
      "original_commit_id" : "323dd0e2b7bf18312b674a9a1b111ddeb3612d62",
      "original_position" : 86,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 63927462,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/139928791",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140048661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140048661"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good point.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-20T18:09:53Z",
      "diff_hunk" : "@@ -0,0 +1,747 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140048661",
      "id" : 140048661,
      "in_reply_to_id" : 139928791,
      "original_commit_id" : "323dd0e2b7bf18312b674a9a1b111ddeb3612d62",
      "original_position" : 86,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 64066764,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140048661",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140118269"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140118269"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I believe this is practically unused.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-20T23:32:51Z",
      "diff_hunk" : "@@ -0,0 +1,743 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+    CTxDestination dest;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140118269",
      "id" : 140118269,
      "original_commit_id" : "184a07d5b6131c13238397db1b1e9a0a1c58c54f",
      "original_position" : 323,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 64145437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140118269",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140336875"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140336875"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, removed.",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-21T19:25:25Z",
      "diff_hunk" : "@@ -0,0 +1,743 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+    CTxDestination dest;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140336875",
      "id" : 140336875,
      "in_reply_to_id" : 140118269,
      "original_commit_id" : "184a07d5b6131c13238397db1b1e9a0a1c58c54f",
      "original_position" : 323,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 64395897,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-21T19:25:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140336875",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140642842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140642842"
         }
      },
      "author_association" : "OWNER",
      "body" : "Posthumous review (and fixed in #11167): this does not construct a valid TX_WITNESS_V0_SCRIPTHASH but a TX_WITNESS_V0_KEYHASH (as the pushed size is 20, not 32)",
      "commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "created_at" : "2017-09-23T22:11:57Z",
      "diff_hunk" : "@@ -0,0 +1,740 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n+\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11116#discussion_r140642842",
      "id" : 140642842,
      "original_commit_id" : "7a1e873b27b790c965d9927ecd465710dc103136",
      "original_position" : 233,
      "path" : "src/test/script_standard_tests.cpp",
      "position" : 233,
      "pull_request_review_id" : 64749060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11116",
      "updated_at" : "2017-09-23T22:11:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140642842",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
